---
title: "Feature Engineering"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
output:
  html_document:
    toc: yes
    number_sections: true
    df_print: paged
    code_folding: hide
    fig_width: 10
    fig_height: 6
    theme: cerulean
    highlight: kate
    toc_float: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include=F}
knitr::opts_chunk$set(fig.width=10, fig.height=5, message = F, warning = F, cache = T)
library(tidyverse)
library(plotly)
library(ggpubr)
library(GGally)
```

This is a notebook for creating various features and their exploration

# Structure of the main table

Which will contain all features and will be suitable for EDA

It should contain the following variables:

-   repeat length,
-   repeat counts,
-   AR length,
-   center spanning,
-   within gene location (of a repeat),
-   distance to oriC,
-   density of matches,
-   density of RG (they often go together)
-   IS presence (?),
-   IS length (=activity)
-   number of plasmids,
-   number of plasmids carrying RGs with repeats,
-   is an RG located on a plasmid,
-   "the black box" of AR

Its tidy structure should look like this:

Each strain contains:

-   [x] 1 AB label

-   [x] 1 resistance label

-   [ ] 1 label for presence of an RG

-   [x] 1 value for plasmid count,

-   [x] 1 value for alternate plasmid count,

-   [ ] 1 value for a number plasmids carrying RGs,

-   [x] repeat count with min 100

-   [x] repeat count with min 500

-   [x] median repeat length

-   [x] median repeat length with min 100

-   [x] median repeat length with min 500

-   [x] maximum repeat length

-   [x] median AR length

-   [x] median AR length with min 100

-   [x] median AR length with min 500

-   [ ] 1 value for repeat count adjusted by number of plasmids,

-   [x] tens of genes; each gene (e.g. region) contains:

    -   [x] 1 distance to oriC,

    -   [ ] 1 density value,

    -   [x] 'on a plasmid' label,

    -   [x] 1 value for repeat count,

    -   [ ] 1 value for IS count,

    -   [ ] value for max IS length,

    -   [x] RGI resistance mechanism,

    -   [x] RGI resistance SNP,

    -   [x] RGI other SNP,

    -   [x] RGI cut-off,

    -   [x] RGI best identities,

    -   [x] RGI AMR gene family,

    -   [x] RGI Model type,

    -   [x] RGI Drug class,

    -   [x] RGI ORF ID,

    -   [x] RGI Percentage Length of Reference Sequence,

    -   [x] a lot of repeat pairs; each repeat pair has:

        -   [x] 1 AR length,
        -   [ ] 1 AR black box matrix,
        -   [x] 1 repeat length,
        -   [x] 1 center spanning label,
        -   [ ] 'inside the gene' label,

# Making a table with features

Start from a table with repeat.

```{r, eval=FALSE}
load("/home/andrei/Data/HeteroR/notebooks/features.RData")
```

## Read table with repeats - create Features

This one will a basic table for the rest of the analysis.

To build this table anew run the code chunk below (its evaluation is OFF
by default)

```{r, eval=TRUE}
# a new way of getting repeat data frame across all strains
strains <- dir("/home/andrei/Data/HeteroR/results/direct_repeats")
repeat_csv_paths <- sapply(strains, function(x){paste0("/home/andrei/Data/HeteroR/results/annotations/",x ,"/repeats/", x, "_repeats.csv")})

repeat_df <- bind_rows(lapply(repeat_csv_paths, function(x){read.csv(x)}))
# calculate AR length
repeat_df$AR_length <- repeat_df$start_2 - repeat_df$end_1 + 1

# read bed files to determine center spanning repeat pairs
bed_df <- bind_rows(lapply(strains, function (x){
  filename <- paste0("/home/andrei/Data/HeteroR/results/direct_repeats/", x, "/regions/regions_within.bed")
  df <- read.delim(filename, header=FALSE)
  df$strain <- x
  return(df)
}))

# find gene center
bed_df$gene_center <- round((bed_df$V3 - bed_df$V2 + 1)/2)
bed_df <- rename(bed_df, "record_id"=V4)
bed_df <- select(bed_df, strain, record_id, gene_center)

# bed_df contains slightly more genes than repeat_df (+624)
# BUT repeat_df is important, that's why I use left_join() below

# join the two tables
repeat_df <- left_join(repeat_df, bed_df, by="record_id")
repeat_df$spans_center <- if_else(repeat_df$end_1 <= repeat_df$gene_center & repeat_df$start_2 >= repeat_df$gene_center, "yes", "no")
repeat_df$record_id <- sub("_gene", "", repeat_df$record_id)
repeat_df <- repeat_df %>% 
  rename("repeat_length"=length) %>% 
  select(-strain.y) %>% 
  rename("strain"=strain.x) %>% 
  relocate(strain, .before=record_id)


# copy for features
# and filter strains you want to exclude
features <- as_tibble(repeat_df) %>% 
  select(-c(gene_center, start_1, end_1, start_2, end_2, X))

# look at this!
features
```

Or read it from the file *repeat_summary.csv* that was made during the pipeline run.

It contains strains, gene names, repeat coordinates, repeat lengths, AR
lengths and 'spans center' label.

Each gene name (aka record_id) is unique.

```{r, eval=FALSE}
repeat_df <- as_tibble(read.csv("/home/andrei/Data/HeteroR/results/tables/repeats_summary.csv")) %>% 
  select(-X) %>% 
  relocate(strain, .before=record_id)

repeat_df$record_id <- sub("_gene", "", repeat_df$record_id)
repeat_df <- rename(repeat_df, "repeat_length"=length)

# copy for features
features <- as_tibble(repeat_df) %>% 
  select(-c(gene_center, start_1, end_1, start_2, end_2))

# look at this!
features
```


In this table we have `r length(unique(features$record_id))` resistance genes with detected repeats from `r length(unique(features$strain))` strains.

Number of repeat pairs detected `r nrow(features)`.

## Add RGI annotations

They are required for filtering of resistance genes and much more...

### Read RGI annotations

'Loose' hits to be removed!

```{r}
strains <- unique(features$strain)[!is.na(unique(features$strain))]

rgi <- bind_rows(lapply(strains, function(x){
  df <- read.delim(paste0("/home/andrei/Data/HeteroR/results/resistance_genes/", x, "/rgi_table.txt"), na.strings = "n/a")
  df$strain <- x
  return(df)
}) )

ab_groups <- unique(rgi$Drug.Class)

# filter out Loose hits and some columns
rgi <- rgi %>% 
  filter( Cut_Off != "Loose" ) %>% 
  select(-c(Predicted_Protein, CARD_Protein_Sequence, Contig, Start, Stop, Orientation, Predicted_DNA, Note))

# turn into a tibble
rgi <- as_tibble(rgi)

# add record id and put it in front of the table
rgi$record_id <- map_chr(rgi$ORF_ID, function(x) strsplit(x, " ")[[1]][1])
rgi <- relocate(rgi, strain, record_id, .before=ORF_ID)

rgi
```

In this table `r length(unique(rgi$ORF_ID))` resistance genes have been detected from `r length(unique(rgi$strain))` strains

### How many RG don't have repeats?

It's the difference between record IDs from RGI and record IDs from Features (or repeat_df).

RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

`r length(setdiff(rgi$record_id, features$record_id))` resistant genes don't have repeats around them.

Since all record IDs in both tables are unique, difference between record IDs of both tables should equal the same number: `r length(unique(rgi$record_id)) - length(unique(features$record_id))`

### Filtering RGI results

**OBS!** Minimum number of RGs found should be much lower than 60 per
strain

Criteria:

1.  Identity percent

2.  Percentage length of reference sequence

3.  efflux pumps should go; target alteration should go; permeability
    should go; inactivation and modification should stay

4.  genes with SNPs should go

#### Number of RGs per strain: before filtering

```{r}
n_RG <- rgi %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG, aes(n_res_genes))+ geom_histogram(fill="steelblue")
```

```{r}
summary(n_RG$n_res_genes)
```

These numbers should be lower!

#### Identity percent

For *Strict* hits you may consider *Identity_percent* as another
filtering criterion, hits with too low identities should be discarded.

##### Distribution of Identity percentages before filtering

```{r, message=F}
hit.ident <- ggplot(rgi %>% select(Cut_Off, Best_Identities), aes(Best_Identities)) +
  geom_histogram(bins = 100, aes(fill=Cut_Off), alpha=0.8) +
  ggtitle("Distribution of identity percentages")

hit.ident
```

##### Leave only 90% and higher

```{r}
rgi_filt <- rgi %>% filter(Best_Identities >= 90)
summary(rgi_filt$Best_Identities)
```

### Percentage length of reference sequence

Before filtering (except for Best_Identities) it looks like this

```{r}
hist.len <-ggplot(rgi_filt %>% select(Cut_Off, Percentage.Length.of.Reference.Sequence), aes(Percentage.Length.of.Reference.Sequence)) +
  geom_histogram(bins = 100, aes(fill=Cut_Off), alpha=0.8) +
  geom_rug(aes(color=Cut_Off))+
  ggtitle("Distribution of percenatge length of reference sequence")

hist.len
```

```{r}
summary(rgi_filt$Percentage.Length.of.Reference.Sequence)
```

How short is too short? 90%

Filtering:

```{r}
rgi_filt <- filter(rgi_filt, Percentage.Length.of.Reference.Sequence >= 90)
summary(rgi_filt$Percentage.Length.of.Reference.Sequence)
```

### Number of RGs per strain : after the 1st filtering

```{r}
n_RG_filt <- rgi_filt %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG_filt, aes(n_res_genes))+ geom_histogram(fill="steelblue")
```

More filtering required!

### Filtering by Resistance.Mechanism

How many resistance mechanisms do we have?

```{r}
unique(rgi_filt$Resistance.Mechanism)
```

What have we decided to filter out?

-   efflux

-   target alteration

-   permeability

What should stay:

-   inactivation

-   modification

-   target replacement?

-   target protection?

**OBS!** Leave those records that *contain* what should stay

```{r}
stay <- c("antibiotic target replacement", "antibiotic target protection", "antibiotic inactivation")

rgi_filt <- rgi_filt %>% 
  filter(Resistance.Mechanism %in% stay)

rgi_filt
```

### Filtering SNPs

How many SNPs do we have now?

```{r}
filter(rgi_filt, !is.na(SNPs_in_Best_Hit_ARO))
```

No SNPs in the filtered RGI table.

### Number of RGs per strain: after the 2nd filtering

```{r}
n_RG_filt <- rgi_filt %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG_filt, aes(n_res_genes))+ 
  geom_histogram(fill="steelblue")+
  xlab("Number of RGs per strain")
```

Summary

```{r}
summary(n_RG_filt$n_res_genes)
```

It's OK!

In total, I have `r length(unique(rgi_filt$record_id))` Resistance Genes in the filtered RGI

### How many genes from filtered RGI don't have repeats?

Same approach as above: it's the difference between filtered RGI's genes IDs and gene IDs from features (=repeat_df)

Filtered RGI - Features:

```{r}
length(setdiff(rgi_filt$record_id, features$record_id))
```

`r length(setdiff(rgi_filt$record_id, features$record_id))` resistance genes after filtering don't have repeats around them.

### Any NAs in features?

```{r}
apply(features, 2, function(x){sum(is.na(x))})
```

### Any NAs in filtered RGI?

```{r}
apply(rgi_filt, 2, function(x){sum(is.na(x))})
# nrow(rgi_filt) 1996
```

### Add filtered RGI annotations to Features

Use gene names as key since they are unique and make a full join with features.

**OBS!** N genes in RGI don't have repeats => N rows in Features won't have repeat_length (N = Filtered RGI - Features)

```{r}
features <- full_join(features, rgi_filt, by=c("strain", "record_id"))

features %>% filter(is.na(repeat_length)) %>% select(strain, record_id, ORF_ID, repeat_length)
```

Number of rows here should be equal to Filtered RGI - Features (see above)

Number of rows in Features: `r nrow(features)`

### Remove RGI columns that we don't need for prediction

Like ARO, Cut_Off etc.

```{r}
features <- features %>% 
  select(-c(ARO, Cut_Off, Pass_Bitscore, Best_Hit_Bitscore, Best_Hit_ARO, 
            Best_Identities, Model_ID, Model_type, Nudged, SNPs_in_Best_Hit_ARO,
            Other_SNPs, ID, Percentage.Length.of.Reference.Sequence))
features
```

**OBS!** Features still contain resistance genes without repeats!

### Remove rows with excluded genes

Since many genes were excluded from RGI results but their repeats,
counts and AR lengths stay in Features, let's make `features_filtered` without
these genes

#### Remove rows in Features without Resistance.Mechanism

How many rows don't have resistance mechanisms (i.e. have been filtered
out during RGI filtering?):
`r sum(is.na(features$Resistance.Mechanism))`

Filtering

```{r}
features_filtered <- filter(features, !is.na(Resistance.Mechanism))
features_filtered
```

#### Remove rows in features without repeat length

Those genes that don't have repeats

So far I decided to keep them but to replace NAs with 0 in gene repeat counts

```{r, eval=FALSE}
features_filtered <- filter(features_filtered, !is.na(repeat_length))
```


Number of rows in Features after filtering: `r nrow(features_filtered)`

## Add repeat counts

Repeat counts (per stain and per gene), AR lengths, averaged counts and lengths - all should be calculated for genes specific to each AB.

Go to AMP section.

## Add AB testing data

### Read and process AB testing table

**OBS!** *resistance_testing.csv* may be updated

```{r}
resistance_df <- read_csv("/home/andrei/Data/HeteroR/resources/resistance_testing.csv", show_col_types = FALSE, col_select = contains("SIR") | contains("strain"))

# make factors, because col_types skips NA :(
resistance_df <- resistance_df %>% 
  mutate(across(names(resistance_df)[grepl("SIR",names(resistance_df))], factor))

# remove .SIR from names
names(resistance_df) <- sub(".SIR", "", names(resistance_df))
resistance_df
```

Overview

```{r}
skimr::skim(resistance_df)
```


### Make a tidy version

```{r}
resistance_df_td <- gather(resistance_df, key="AB", value="resistance", 1:8)
resistance_df_td$AB <- as.factor(resistance_df_td$AB)
resistance_df_td$resistance <- factor(resistance_df_td$resistance, ordered=T, levels = c("S", "I", "R"))
```

I'm not sure which version (regular or tidy) to add to `features`

To use AB and results of testing in plots I need a tidy version

### Add tidy version to features

```{r}
features_filtered <- left_join(features_filtered, resistance_df_td, by="strain")
features_filtered
```

**OBS!** Now filtered Features contain `r nrow(features_filtered)` rows.

## Number of plasmids

Per strain

Info on plasmids is in tables `summary.tsv` in
`results/assemblies_joined` and it has been collected in
`genome_assembly_summary.Rmd`

To build the table anew run the following chunk of code (by default its
evaluation is OFF)

```{r, eval=TRUE}
assembly_summary_files <- dir(path="/home/andrei/Data/HeteroR/results/assemblies_joined",  pattern = "summary.tsv", recursive=TRUE)
assembly_summary <- lapply(assembly_summary_files, function(x){
  df <- read_delim(paste0("/home/andrei/Data/HeteroR/results/assemblies_joined/", x))
  df$Links <- as.integer(gsub(",", "", df$Links, fixed=TRUE))
  df$Length <- as.integer(gsub(",", "", df$Length, fixed=TRUE))
  df$N50 <- as.integer(gsub(",", "", df$N50, fixed=TRUE))
  df$Longest_component <- as.integer(gsub(",", "", df$Longest_component, fixed=TRUE))
  return(df)
  })

assembly_summary <- bind_rows(assembly_summary)
assembly_summary
```

Or read the table from a file:

```{r, eval=FALSE}
assembly_summary <- read_csv("/home/andrei/Data/HeteroR/results/tables/genome_assembly_summary.csv", show_col_types = F) %>% 
  select(-...1)

assembly_summary
```

### Calculate plasmid counts from summary files

```{r}
plasmid_counts <- assembly_summary %>% group_by(Strain, Type) %>% 
  summarise(n_plasmids=n()) %>% 
  filter(Type=="Plasmid") %>% 
  select(-Type) %>% 
  rename("strain"=Strain)
```

and add it to `features`

```{r}
features_filtered <- left_join(features_filtered, plasmid_counts, by="strain")
# NA in n_plasmids means 0
features_filtered$n_plasmids <- ifelse(is.na(features_filtered$n_plasmids), 0, features_filtered$n_plasmids)
features_filtered <- features_filtered %>% relocate(n_plasmids, .before="ORF_ID")
head(features_filtered)
```

### Calculate number of plasmids from fasta headers + their relative coverage

We should take into account relative coverage of plasmids (i.e. number
of copies), which can be found in an assembly header, but not every
plasmid has this measure, since it is calculated only by Unicycler but not SPAdes.

```{r, eval=TRUE}
# use fread from data.table
assemblies_path <- "/home/andrei/Data/HeteroR/results/assemblies_joined/"
assembly_files <- dir(path=assemblies_path, pattern="assembly.fasta$", recursive=T)

headers <- lapply(assembly_files, function(x){
  df <- data.table::fread(cmd=paste0("grep '>' ", assemblies_path, x), fill=TRUE, header = F, sep = " ", drop = 1, na.strings = "")
  df$strain <- strsplit(x, "/")[[1]][1]
  return(df)
})

headers <- bind_rows(headers)

headers$depth.rounded <- sapply(headers$V3, function(y){round(as.numeric(substr(y, 7, 10)))})
headers$length <- sapply(headers$V2, function(y){round(as.numeric(strsplit(y, "=")[[1]][2]))})
headers$circular <- sapply(headers$V4, function(y){strsplit(y, "=")[[1]][2]})

# headers_df <- fread(cmd='grep ">" /home/andrei/Data/HeteroR/results/assemblies_joined/DA68966/assembly.fasta', fill=TRUE)

# sapply(headers_df$V3, function(x){round(as.numeric(substr(x, 7, 10)))})
# sapply(headers_df$V2, function(x){round(as.numeric(strsplit(x, "=")[[1]][2]))})

headers <- headers %>% select(-c(V2, V3, V4))
headers
```

From this table I can calculate number of plasmids as sum of depths

First, remove DA68966 until it is resequenced.

```{r}
headers <- headers %>% 
  filter(strain != "DA68966")
```

Let's look at the lengths distribution because length is the key to
"smart" filtering of plasmids

```{r, fig.width=12, fig.height=4}
require(ggpubr)

h1 <- ggplot(headers, aes(length)) + 
  geom_histogram(fill="steelblue", bins = 200)+
  geom_rug() + 
  ggtitle("assembly segments lengths")

h2 <- ggplot(headers %>% filter(length >= 1000), aes(length)) + 
  geom_histogram(fill="steelblue", bins = 200)+
  geom_rug() + 
  ggtitle("assembly segments lengths, min length = 1000")

ggarrange(h1, h2, ncol=2, nrow=1)
```

Let's remove all segments shorter than 1000 bp

```{r}
headers <- headers %>% 
  filter(length >= 1000)
```

Distribution of longest segments in each strain

```{r}
headers.longest <- headers %>% group_by(strain) %>% summarise(max.length=max(length))

ggplot(headers.longest, aes(max.length))+
  geom_histogram(fill="steelblue")+
  ggtitle("Longest segments in each strain")
```

So...

How to distinguish between segmented chromosomes and real plasmids?

I can try to count a segment as "plasmid" if this segment goes after
other segments that sum up to 4.5 Mpb

Pseudo code looks like this:

For each strain:

set N=0

for each segment: if N \> 4.5 Mbp N =+ segment length mark segment as
chromosome

if unmarked segments left: mark them as plasmids

Let's try

```{r}
df.tmp <- headers %>% filter(strain=="DA62886")
sum.len <- 0
marks <- c()
for (L in df.tmp$length){
  if (sum.len < 4500000){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
  } else {
    marks <- c(marks, "plasmid")
  }
}

df.tmp$type <- marks

df.tmp
```

Apply it to full headers table

```{r}
# Naive algorithm will look like this

get.labels <- function(lengths.vec, max.sum.len){
  sum.len <- 0
  marks <- c()
  
  for (L in lengths.vec){
    if (sum.len < max.sum.len){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
    } else {
    marks <- c(marks, "plasmid")
    }
  }
  
  return(marks)
}

# apply this function to each strain's subset of the headers table
labels.total <- c()
for (S in unique(headers$strain)){
  sub.df <- filter(headers, strain==S)
  labels.sub.df <- get.labels(sub.df$length, 4500000)
  labels.total <- c(labels.total, labels.sub.df)
}

headers$label <- labels.total

headers
```

Now, I can calculate "real" plasmid count per strain and add it to the
features table

```{r}
plasmid_counts_alt <- headers %>% 
  filter(label=="plasmid") %>% 
  group_by(strain) %>% 
  summarise(n_plasmids_alt=sum(depth.rounded))

plasmid_counts_alt
```

Add this data set to filtered features

```{r}
features_filtered <- left_join(features_filtered, plasmid_counts_alt, by="strain")
```


## Black-box

One-hot encoding of DNA sequences.

The function below is borrowed from [this repo](https://github.com/btmonier/monier/blob/master/R/oneHot.R)

```{r}
oneHot <- function(s, n = c("A", "C", "G", "T")) {

    # Construct matrix
    s <- toupper(s)
    seq_len <- nchar(s)
    seq_split <- unlist(strsplit(x = s, split = ""))

    seq_mat <- matrix(data = rep(0, seq_len * length(n)), nrow = 4)

    rownames(seq_mat) <- n
    colnames(seq_mat) <- seq_split

    # Encode
    for (i in n) {
        seq_mat[rownames(seq_mat) == i, colnames(seq_mat) == i] <- 1
    }

    return(seq_mat)

}
```

Every one-hot encoded amplifiable region is a matrix.

What is still unclear it's how to 'average' this feature across many amplifiable regions that every gene/strain has.

Maybe it will be better to use **CNN** on Amplifiable region's sequences - and get nucleotides' importance.


# AMP tested strains

Here I will analyse only strains tested for resistance to AMP

## Create a data set

**OBS!** Only per strain features should be kept in this table

```{r}
# filter those strains that were tested for AMP
# keep for per gene feature calculations
features_amp <- features_filtered %>% filter(AB=="AMP") %>% distinct()
# this df is for per strain calculation
features_amp_strain <- features_amp %>% select(strain, n_plasmids, AB, resistance) %>% distinct()
head(features_amp_strain)
```

Number of strains tested for AMP resistance `r length(unique(features_amp$strain))`

## Add RG presence column

We need a column with number of beta-lactamase genes per strain (instead of absence/presence)

Those genes or strains that don't have b-l genes should have zeros in repeat counts, length etc.

```{r}
f_amp_filt <- features_amp %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct()

f_amp_filt$is_beta_lac <- grepl("beta-lactamase", f_amp_filt$AMR.Gene.Family)

n.beta.lac <- f_amp_filt %>% group_by(strain) %>% summarise(n.beta.lac=sum(is_beta_lac))

# join with features_amp_strain
features_amp_strain <- left_join(features_amp_strain, n.beta.lac, by="strain")

# add is beta lac to features amp for future calculations
features_amp <- left_join(features_amp, f_amp_filt %>% select(record_id, is_beta_lac), by="record_id") %>% 
  relocate(is_beta_lac, .before="AB")

head(features_amp_strain)
```


## Location on plasmid

`features_amp` contains gene names, so I can find if it's located on a plasmid.

**OBS!** This feature should be "averaged" by strain!

t.ex.: number of genes located on plasmids (can be 0, 1, 2, 3, 4...) 

```{r}
# the only working way to read gff files in rR
# genbankr::read.GenBank() didn't work
# ape::read.gff() and ape::read.GenBank() didn't work
# read_delim() didn't work
# biomartr couldn't be installed

# a function to read GFF files using STANDARD read.delim
read_gff <- function(gff_filename){
  # read and process
  df <- as_tibble(read.delim(gff_filename, header=F, comment.char="#")) %>%
  select(V1, V3, V4, V5, V7, V9) %>% 
  filter(V3=="gene")
  return(df)
  }



# get gff full paths using strain names vector
gff_files <- map_chr(strains, ~ str_c("/home/andrei/Data/HeteroR/results/annotations/", ., "/prokka/", ., "_genomic.gff"))

# read gff files right in a tibble
# it works quite long time
gff <- map_dfr(gff_files, ~ read_gff(.))

# transform the last column to get the same record_id as in features_amp
gff <- separate(data = gff, col=V9, sep = ";locus_tag=", into=c("V10", "V11")) %>%  select(-V10)

# give new names
names(gff) <- c("seq.region", "type", "start", "stop", "strand", "record_id")

# filter out genes that are not in features_amp
gff_amp <- filter(gff, record_id %in% unique(features_amp$record_id))

# remove this 2 million rows 
rm(gff)

# add 'located on plasmid' - if there is '1' in seq.region then its a chromosome (the first element of an assembly)
gff_amp$located.on.plasmid <- str_detect(gff_amp$seq.region, "1", negate = T)
gff_amp$on.plasmid <- factor(if_else(gff_amp$located.on.plasmid, 1, 0))

```

## Distance to *oriC*

`features_amp` contains gene names, 

I can find this in annotation files (gff, gbk etc) and assembly summary tables (completeness)

**OBS!** This feature should be "averaged" by strain! 

t.ex.: closest distance to oriC or median/mean distance to oriC

If I assume that oriC is available only in circularized genomes then I might get NAs in some strains

```{r}
# find distance to oriC (here I assume that all genomes begin from oriC)
gff_amp <- rename(gff_amp, "dist.to.oriC"=start)
```

## On pos strain

It might also be useful

```{r}
gff_amp$pos.strand <- if_else(gff_amp$strand == "+", 1, 0)

# remove some columns
gff_amp <- select(gff_amp, c(record_id, dist.to.oriC, pos.strand, on.plasmid))
```


### GFF overview

```{r}
gff_amp
```

### Join GFF and features_amp

to get strain labels

```{r}
gff_amp <- left_join(gff_amp, select(features_amp, c(strain, record_id)) %>% distinct(), by="record_id")

```

### Summarize features per strain

- minimum distance to oriC

- average (median) distance to oriC

- number of genes on a positive strand 

- number of genes on plasmids

```{r}
min_dist_oriC <- gff_amp %>% group_by(strain) %>% 
  summarise(min.dist.oriC=min(dist.to.oriC))

med_dist_oriC <- gff_amp %>% group_by(strain) %>% 
  summarise(med.dist.oriC=median(dist.to.oriC))

n_genes_plus_strand <- gff_amp %>% group_by(strain) %>% 
  summarise(n.genes.plus.strand=sum(pos.strand))

n_genes_plasmids <- gff_amp %>% group_by(strain) %>% 
  summarise(n.genes.plasmids=sum(on.plasmid))

features_amp_strain <- list(features_amp_strain, min_dist_oriC, med_dist_oriC, n_genes_plus_strand, n_genes_plasmids) %>% 
  reduce(left_join, by="strain")

dim(features_amp_strain)
```


## Repeat count

**OBS!** Repeat in the current context is *a pair of identical regions of a certain length*.

### Add total repeat count

Repeats from around non-beta-lactamase genes should not be counted!


```{r}
# in features_amp every row is a repeat, to find number of repeats per strain,
# count number of rows per strains
# exclude non-beta-lac genes
# according to the current repeat definition distinct() should not be used
repeat_counts_strain <- features_amp %>% 
  filter(is_beta_lac) %>% 
  group_by(strain) %>%
  summarise("n.rep.total"=n())

features_amp_strain <- left_join(features_amp_strain, repeat_counts_strain, by="strain")

# count number of repeats spanning center
rep_count_center_strain <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  group_by(strain) %>%
  summarise("n.rep.tot.cen"=n())

features_amp_strain <- left_join(features_amp_strain, rep_count_center_strain, by="strain")

# number of repeats not spanning center
features_amp_strain$n.rep.tot.non.cen <- features_amp_strain$n.rep.total - features_amp_strain$n.rep.tot.cen


# repeats per gene = number of rows per record_id
# exclude non-beta-lac genes
repeat_counts_gene <- features_amp %>%
  filter(is_beta_lac) %>% 
  group_by(record_id) %>%
  summarise("n_repeats_gene"=n())

# join only those counts that are in features_amp
features_amp <- left_join(features_amp, repeat_counts_gene, by="record_id")

# NAs to 0s
# there is no NAs
#features_amp$n_repeats_gene <- ifelse(is.na(features_amp$n_repeats_gene), 0, features_amp$n_repeats_gene)
#features_amp$n_repeats_strain <- ifelse(is.na(features_amp$n_repeats_strain), 0, features_amp$n_repeats_strain)

# locate
features_amp <- features_amp %>% relocate(n_repeats_gene, .before="ORF_ID")


```

### Add repeat count, min length 100 bp

```{r}
# n reads longer than 100 bp
repeat_counts_strain_100 <- features_amp %>% 
  filter(is_beta_lac) %>%
  filter(repeat_length >= 100) %>% 
  group_by(strain) %>% 
  summarise("n.rep.100"=n())

# add
features_amp_strain <- left_join(features_amp_strain, repeat_counts_strain_100, by="strain")
# NAs to 0s
features_amp_strain$n.rep.100 <- ifelse(is.na(features_amp_strain$n.rep.100), 0, features_amp_strain$n.rep.100)

# n repeats longer than 100 and spanning center
repeat_counts_strain_100_center <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes", repeat_length >= 100) %>%
  group_by(strain) %>% 
  summarise("n.rep.100.cen"=n())

# add to the table, there will be NAs
features_amp_strain <- left_join(features_amp_strain, repeat_counts_strain_100_center, by="strain")
# replace NAs with 0s
features_amp_strain$n.rep.100.cen <- ifelse(is.na(features_amp_strain$n.rep.100.cen), 0, features_amp_strain$n.rep.100.cen)

## non spanning center
features_amp_strain$n.rep.100.non.cen <- features_amp_strain$n.rep.100 - features_amp_strain$n.rep.100.cen

#############################
## PER GENE
#############################

repeat_counts_gene_100 <- features_amp %>% 
  filter(is_beta_lac) %>% 
  filter(repeat_length >= 100) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min100"=n())

# join 
features_amp <- left_join(features_amp, repeat_counts_gene_100, by="record_id")

# not all beta-lac genes/strains have repeats longer than 100
# they are NA
# turn these NAs to 0s
features_amp$n_repeats_gene_min100 <- ifelse(is.na(features_amp$n_repeats_gene_min100), 0, features_amp$n_repeats_gene_min100)

# locate
features_amp <- features_amp %>% relocate(n_repeats_gene_min100, .before="ORF_ID")

##################################
## SHOW FEATURES STRAIN
##################################

head(features_amp_strain)
```

### Add repeat count, min length 500 bp

```{r}
# n reads longer than 500 bp
repeat_counts_strain_500 <- features_amp %>% 
  filter(is_beta_lac) %>%
  filter(repeat_length >= 500) %>% 
  group_by(strain) %>% 
  summarise("n.rep.500"=n())

# add
features_amp_strain <- left_join(features_amp_strain, repeat_counts_strain_500, by="strain")
# NAs to 0s
features_amp_strain$n.rep.500 <- ifelse(is.na(features_amp_strain$n.rep.500), 0, features_amp_strain$n.rep.500)

# n repeats longer than 500 and spanning center
repeat_counts_strain_500_center <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes", repeat_length >= 500) %>%
  group_by(strain) %>% 
  summarise("n.rep.500.cen"=n())

# add to the table, there will be NAs
features_amp_strain <- left_join(features_amp_strain, repeat_counts_strain_500_center, by="strain")
# replace NAs with 0s
features_amp_strain$n.rep.500.cen <- ifelse(is.na(features_amp_strain$n.rep.500.cen), 0, features_amp_strain$n.rep.500.cen)

## non spanning center
features_amp_strain$n.rep.500.non.cen <- features_amp_strain$n.rep.500 - features_amp_strain$n.rep.500.cen

#############################
## PER GENE
#############################

repeat_counts_gene_500 <- features_amp %>% 
  filter(is_beta_lac) %>% 
  filter(repeat_length >= 500) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min500"=n())

# join 
features_amp <- left_join(features_amp, repeat_counts_gene_500, by="record_id")

# not all beta-lac genes/strains have repeats longer than 500
# they are NA
# turn these NAs to 0s
features_amp$n_repeats_gene_min500 <- ifelse(is.na(features_amp$n_repeats_gene_min500), 0, features_amp$n_repeats_gene_min500)

# locate
features_amp <- features_amp %>% relocate(n_repeats_gene_min500, .before="ORF_ID")

##################################
## SHOW FEATURES STRAIN
##################################

head(features_amp_strain)

```

## Median sum of repeat length

total repeat length in each gene divided by number of genes

total repeat length = sum of all repeats on one side of a gene from center-spanning repeat pairs

```{r}
# calculate summarized repeat sum
rep_len_sum_strain <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  group_by(strain, record_id) %>%
  summarise(total_repeat_length=sum(repeat_length)) %>% 
  group_by(strain) %>% 
  summarise(med.tot.rep.len=median(total_repeat_length))

features_amp_strain <- left_join(features_amp_strain, rep_len_sum_strain, by="strain")

# per gene
rep_len_sum <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  group_by(record_id) %>%
  summarise(total_repeat_length=sum(repeat_length))

features_amp <- left_join(features_amp, rep_len_sum, by="record_id") %>%
  relocate(total_repeat_length, .before = "AR_length")

head(features_amp_strain)
```

## Repeat density

Under construction.

This metric reflects maximum number of repeats per sliding window.

## Median repeat length

Only repeats found around beta-lactamase genes should be taken into account.

According to the current definition of *repeat*, `distinct()` should not be used.

### All repeats

```{r}
# I have removed distinct() and added filter(spans_center=="yes")
# it significantly changes everything
med_rep_len <- features_amp %>% 
  filter(is_beta_lac) %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len=median(repeat_length, na.rm = T))

# spanning gene center
med_rep_len_center <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.cen=median(repeat_length, na.rm = T))

# non spanning
med_rep_len_non_center <- features_amp %>% 
  filter(is_beta_lac, spans_center=="no") %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.non.cen=median(repeat_length, na.rm = T))

# add
features_amp_strain <- left_join(features_amp_strain, med_rep_len_center, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_rep_len_non_center, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_rep_len, by="strain") # features_amp_strain <- features_amp_strain %>% relocate(med.rep.len, .before = "med.rep.len.cen")


# NAs to 0s
features_amp_strain$med.rep.len.cen <- ifelse(is.na(features_amp_strain$med.rep.len.cen), 0, features_amp_strain$med.rep.len.cen)
features_amp_strain$med.rep.len.non.cen <- ifelse(is.na(features_amp_strain$med.rep.len.non.cen), 0, features_amp_strain$med.rep.len.non.cen)

# older way of counting
# med_rep_len_old <- features_amp %>% 
#   filter(is_beta_lac) %>% 
#   select(strain, repeat_length) %>% 
#   distinct() %>% 
#   group_by(strain) %>% 
#   summarize(median_repeat_length=median(repeat_length, na.rm = T))

head(features_amp_strain)
```

### Repeats min 100

```{r}
med_rep_len_m100 <- features_amp %>% 
  filter(is_beta_lac, repeat_length >= 100) %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.100=median(repeat_length, na.rm = T))

# spanning gene center
med_rep_len_center_m100 <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes", repeat_length >= 100) %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.cen.100=median(repeat_length, na.rm = T))

# non spanning
med_rep_len_non_center_m100 <- features_amp %>% 
  filter(is_beta_lac, spans_center=="no", repeat_length >= 100) %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.non.cen.100=median(repeat_length, na.rm = T))

# add
features_amp_strain <- left_join(features_amp_strain, med_rep_len_m100, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_rep_len_center_m100, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_rep_len_non_center_m100, by="strain")

# replace NAs
features_amp_strain$med.rep.len.100 <- ifelse(is.na(features_amp_strain$med.rep.len.100), 0, features_amp_strain$med.rep.len.100)
features_amp_strain$med.rep.len.cen.100 <- ifelse(is.na(features_amp_strain$med.rep.len.cen.100), 0, features_amp_strain$med.rep.len.cen.100)
features_amp_strain$med.rep.len.non.cen.100 <- ifelse(is.na(features_amp_strain$med.rep.len.non.cen.100), 0, features_amp_strain$med.rep.len.non.cen.100)

# show
head(features_amp_strain)
```

## Maximum repeat length

```{r}
max_rep_len_all <- features_amp %>% group_by(strain) %>% summarize(max.rep.len=max(repeat_length, na.rm = T))

max_rep_len_cen <- features_amp %>% filter(spans_center=="yes") %>% group_by(strain) %>% summarize(max.rep.len.cen=max(repeat_length, na.rm = T))

max_rep_len_non_cen <- features_amp %>% filter(spans_center=="no") %>% group_by(strain) %>% summarize(max.rep.len.non.cen=max(repeat_length, na.rm = T))

# add
features_amp_strain <- left_join(features_amp_strain, max_rep_len_all, by="strain")
features_amp_strain <- left_join(features_amp_strain, max_rep_len_cen, by="strain")
features_amp_strain <- left_join(features_amp_strain, max_rep_len_non_cen, by="strain")

# NAs to 0
features_amp_strain$max.rep.len.cen <- ifelse(is.na(features_amp_strain$max.rep.len.cen), 0, features_amp_strain$max.rep.len.cen)

head(features_amp_strain)
```


## Median amplifiable region size

### All repeat pairs

`distinct()` should not be used again

```{r}
med_ar_len <- features_amp %>% 
  filter(is_beta_lac) %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len=median(AR_length, na.rm = T))


med_ar_len_cen <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.cen=median(AR_length, na.rm = T))

med_ar_len_non_cen <- features_amp %>% 
  filter(is_beta_lac, spans_center=="no") %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.non.cen=median(AR_length, na.rm = T))

# add
features_amp_strain <- left_join(features_amp_strain, med_ar_len, by="strain") # relocate(features_amp_strain, med.AR.len, .before="med.AR.len.cen")
features_amp_strain <- left_join(features_amp_strain, med_ar_len_cen, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_ar_len_non_cen, by="strain")

head(features_amp_strain)
```

### Repeats min 100

```{r}
med_ar_len_m100 <- features_amp %>% 
  filter(is_beta_lac, repeat_length >= 100) %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.100=median(AR_length, na.rm = T))

med_ar_len_cen_m100 <- features_amp %>% 
  filter(is_beta_lac, spans_center=="yes", repeat_length >= 100) %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.cen.100=median(AR_length, na.rm = T))

med_ar_len_non_cen_m100 <- features_amp %>% 
  filter(is_beta_lac, spans_center=="no", repeat_length >= 100) %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.non.cen.100=median(AR_length, na.rm = T))

# add
# NA can appear
features_amp_strain <- left_join(features_amp_strain, med_ar_len_m100, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_ar_len_cen_m100, by="strain")
features_amp_strain <- left_join(features_amp_strain, med_ar_len_non_cen_m100, by="strain")

# replace NAs with 0
features_amp_strain$med.AR.len.cen.100 <- ifelse(is.na(features_amp_strain$med.AR.len.cen.100), 0, features_amp_strain$med.AR.len.cen.100)
features_amp_strain$med.AR.len.non.cen.100 <- ifelse(is.na(features_amp_strain$med.AR.len.non.cen.100), 0, features_amp_strain$med.AR.len.non.cen.100)
features_amp_strain$med.AR.len.100 <- ifelse(is.na(features_amp_strain$med.AR.len.100), 0, features_amp_strain$med.AR.len.100)

head(features_amp_strain)
```

## Repeats around ampC genes

Each strain has at least one *ampC* gene. Let's add the same variables but calculated only on *ampC* genes.

```{r}
features_amp %>% select(strain, record_id, AMR.Gene.Family) %>% distinct() %>% group_by(strain, record_id) %>% summarise(n.ampC = sum(grepl("ampC", AMR.Gene.Family))) %>% group_by(strain) %>% summarize(n.ampC = sum(n.ampC)) %>% filter(n.ampC == 0)
```

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_ampC <- filter(features_amp, grepl("ampC", AMR.Gene.Family))

# add total rep count, med repeat length, max repeat length, sum repeat length, med AR length

###########
## TOT REP
###########

repeat_counts_ampC <- features_ampC %>% 
  filter(is_beta_lac) %>% 
  group_by(strain) %>%
  summarise("ampC.n.rep.tot"=n())

features_amp_strain <- left_join(features_amp_strain, repeat_counts_ampC, by="strain")

###############
## MED REP LEN
###############

med_rep_len_ampC <- features_ampC %>% 
  filter(is_beta_lac) %>% 
  select(strain, repeat_length) %>% 
  group_by(strain) %>% 
  summarize("ampC.med.rep.len"=median(repeat_length, na.rm = T))

features_amp_strain <- left_join(features_amp_strain, med_rep_len_ampC, by="strain")

################
## MAX REP LEN
################

max_rep_len_all_ampC <- features_ampC %>% 
  group_by(strain) %>% 
  summarize("ampC.max.rep.len"=max(repeat_length, na.rm = T))

features_amp_strain <- left_join(features_amp_strain, max_rep_len_all_ampC, by="strain")

#####################################
## SUM REP LEN only spanning center!
#####################################

rep_len_sum_ampC <- features_ampC %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  group_by(strain, record_id) %>%
  summarise("total_repeat_length"=sum(repeat_length)) %>% 
  group_by(strain) %>% 
  summarise("ampC.med.tot.rep.len"=median(total_repeat_length))

features_amp_strain <- left_join(features_amp_strain, rep_len_sum_ampC, by="strain")

################
## MED AR SIZE
################

med_ar_len_ampC <- features_ampC %>% 
  filter(is_beta_lac) %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize("ampC.med.AR.len"=median(AR_length, na.rm = T))

features_amp_strain <- left_join(features_amp_strain, med_ar_len_ampC, by="strain")

###################
## MED AR SPANNING
###################

med_ar_len_cen_ampC <- features_ampC %>% 
  filter(is_beta_lac, spans_center=="yes") %>% 
  select(strain, AR_length) %>% 
  group_by(strain) %>% 
  summarize("ampC.med.AR.len.cen"=median(AR_length, na.rm = T))

features_amp_strain <- left_join(features_amp_strain, med_ar_len_cen_ampC, by="strain")
features_amp_strain$ampC.med.AR.len.cen <- ifelse(is.na(features_amp_strain$ampC.med.AR.len.cen), 0, features_amp_strain$ampC.med.AR.len.cen)

```



## Final version

Remove intermediate resistance and not tested strains

```{r}
# add plasmids if you forgot
# features_amp_strain <- left_join(features_amp_strain, features_amp %>% select(strain, n_plasmids) %>% distinct(), by="strain") %>% relocate(n_plasmids, .before="n.rep.total")
features_amp_strain <- features_amp_strain %>% filter(resistance != "I", !is.na(resistance))
features_amp_strain
```

# Write table required for EDA to files

```{r}
write.csv(n.beta.lac, "/home/andrei/Data/HeteroR/results/tables/n_beta_lac.csv", row.names = F)

write.csv(features_amp_strain, "/home/andrei/Data/HeteroR/results/tables/features_amp_strain.csv", row.names = F)

write.csv(features_amp, "/home/andrei/Data/HeteroR/results/tables/features_amp.csv", row.names = F)
```

# Save the workspace

```{r, eval=TRUE}
save.image(f="/home/andrei/Data/HeteroR/notebooks/features.RData")
```
