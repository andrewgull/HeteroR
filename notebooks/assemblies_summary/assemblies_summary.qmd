---
title: "Genome assemblies summary"
author: "by AG"
date: "last update: `r format(Sys.time(), format = '%d %B %Y, %H:%M CET')`"
format: 
  html:
    theme: "sandstone"
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    df-print: paged
    standalone: true
    code-fold: true
editor: visual
---

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(plotly)
library(GGally)

# paths
ass_join <- "/home/andrei/Data/HeteroR/results/assemblies_joined/"
assemblies_output_file <- "/home/andrei/Data/HeteroR/results/genome_assembly_summary.csv"

busco_path <- "/home/andrei/Data/HeteroR/results/qualcheck_assembly/"
busco_filename <- "short_summary.specific.gammaproteobacteria_odb10.busco_results.txt"
```

# Assemblies summary table

```{r read, message = FALSE, warning = FALSE}

# get paths to assembly summary files
summary_files <- dir(path=ass_join,  pattern = "summary.tsv", recursive=TRUE)

assemblies <- map_dfr(summary_files, function(x){read_delim(paste0(ass_join, x), col_types = "cccccccccccc")}) %>% 
  mutate(Links = as.integer(gsub(",", "", Links, fixed = TRUE)),
                Length = as.integer(gsub(",", "", Length, fixed = TRUE)),
                N50 = as.integer(gsub(",", "", N50, fixed = TRUE)),
                Longest_component = as.integer(gsub(",", "", Longest_component, fixed = TRUE)),
                Status2 = case_when(Status == "incomplete" ~ "linear",
                             Status == "complete" | Status == "Y" ~ "circular",
                             Status == "scaffold" ~ "add.plasmid"))

```

Assembly summary information has been taken from Unicycler's log files and Flye's info files, total number of summary files `r length(summary_files)`

# Descriptive stat

```{r}
assemblies %>% 
  group_by(Status2) %>% 
  count()
```

# Plot of 'Status' counts, max count is 100 

```{r, fig.width=14, fig.height=6}
library(plotly)

ass.counts.100 <- assemblies %>% 
  group_by(Strain, Status2) %>% 
  count() %>% 
  filter(n < 100)

plot_ly(
  data = ass.counts.100,
  x = ~Strain,
  y = ~n,
  type = "bar",
  color = ~Status2
 ) %>% 
  layout(title="assembly status")
```


```{r, fig.width=14, fig.height=6}
assemblies %>% 
  group_by(Strain, Type, Status2) %>% 
  count() %>% 
  filter(n < 100) %>% 
  ggplot(aes(Strain, n)) +
    geom_bar(stat = "identity", position = "dodge", aes(fill = Type)) +
    scale_fill_brewer(palette = "Set2") +
    facet_grid(rows = vars(Status2)) +
    coord_trans(y = "sqrt")
```


# Plot of 'Status' counts, min count is 100 

```{r}
assemblies %>% 
  group_by(Strain, Status2) %>% 
  count() %>% 
  filter(n >= 100) %>% 
  ggplot(aes(Strain, n)) +
    geom_bar(stat = "identity", position = "dodge", aes(fill = Status2)) +
    scale_fill_brewer(palette = "Set2") +
    coord_trans(y = "sqrt")

# Ony four strains
```

Extremely fragmented assemblies.

## Incomplete chromosomes

```{r}
assemblies %>% 
  filter(Type == "Chromosome") %>% 
  group_by(Status2) %>% 
  count() %>% 
  ggplot(aes(Status2, n)) +
    geom_bar(stat = "identity", position = "dodge", aes(fill = Status2)) +
    scale_fill_brewer(palette = "Set2") 

# 0.822 completeness rate
```

Out of `r nrow(assemblies %>% filter(Type == "Chromosome"))` chromosomes `r nrow(assemblies %>% filter(Type == "Chromosome", Status2 == "circular"))/nrow(assemblies %>% filter(Type == "Chromosome"))` are circular (i.e. complete).

# Coverage

Is coverage affecting circularity?

### Make data set with coverage

```{bash, eval=FALSE}
cd /home/andrei/Data/HeteroR

workflow/scripts/coverage_cli.py resources/strain_lists/strains525.txt 5131220 results/coverage/strains525.tsv filtered

```

### Join with assemblies summary 

Read and process coverage data

```{r, message=F, warning=FALSE, fig.width=10, fig.height=8}
coverage <- read_delim("/home/andrei/Data/HeteroR/results/coverage/strains525.tsv", na = c("", "NaN")) %>% 
  mutate(Strain = str_extract(file, "DA[0-9]*"))
  
assemblies %>% 
  filter(Type == "Chromosome") %>% 
  left_join(coverage, by ="Strain") %>% 
  select(Status2, N50, num_seqs, sum_len, min_len, avg_len, max_len, coverage) %>% 
  GGally::ggpairs(aes(fill = Status2, color = Status2, alpha=0.3)) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
```

- Status2 strongly depends on N50 and max_len; 

- N50 correlates with coverage/sum_len.



## Circularity vs reads max length

Ryan Wick writes the following:

> ... assuming that your reads are sufficiently long. Practically, this means longer than the longest repeat in the genome, as this will allow most assemblies to reach completion. For many bacterial genomes, the longest repeat will be the ribosomal RNA operon which is \~5.5 kbp, in which case a read N50 of 10 kbp is sufficient. However, some genomes have much longer repeats and will require longer reads. Overly-long reads rarely cause a problem, so you should aim for the longest reads you reasonably can.

### Lowest coverage

Some of the strains were not re-sequenced yet

```{r}
assemblies %>% 
  filter(Type=="Chromosome" & Status2 == "linear") %>% 
  select(Strain, coverage) %>% 
  arrange(coverage)
```

### Highest coverage

To resequence or re-assemble with Flye-Medaka-Polypolish

```{r}
assemblies %>% 
  filter(Type=="Chromosome" & Status2 == "linear") %>% 
  select(Strain, coverage) %>% 
  arrange(-coverage)
```

# Number of plasmids per strain

```{r, message = FALSE}
assemblies %>% 
  group_by(Strain, Type) %>% 
  count() %>% 
  filter(Type == "Plasmid")

```

Total number of strains with plasmids identified `r length(plasmids_count$Strain)`

Could not find any plasmids in `r length(unique(assemblies$Strain)) - length(plasmids_count$Strain)` strains

## Plasmid counts per strain

**All following plots are interactive (zoomable, clickable and draggable), in case of problems reload the page**

```{r, message=FALSE, warning=FALSE, fig.width=12}
plasmids_count <- arrange(plasmids_count, -Count)

bar_plasmid <- plot_ly(
  x = plasmids_count$Strain,
  y = plasmids_count$Count,
  type = "bar" 
)

bar_plasmid %>% layout(title="Plasmids count per strain")
```

### Plasmid counts distribution

```{r, message=FALSE, warning=FALSE, fig.width=12}
# boxplot and violin plot
box_plasmid <- plasmids_count %>%
  plot_ly(
    y = ~Count,
    type = 'violin',
    box = list(
      visible = T
    ),
    meanline = list(
      visible = T
    ),
    x0 = 'Plasmid'
  )

box_plasmid <- box_plasmid %>%
  layout(
    yaxis = list(
      title = "Count",
      zeroline = F
    )
  )

box_plasmid <- box_plasmid %>% layout(title="Distribuiton of plasmid counts")

# histogram
hist_plasmids <- plasmids_count %>% 
  plot_ly(y = ~Count, type = "histogram") %>% 
  layout(title="Distribuiton of plasmid counts")

# combined
fig <- subplot(box_plasmid, hist_plasmids) %>% 

  layout(title = 'Plasmids counts distribution', showlegend=FALSE)

fig
```

## Number of complete and incomplete segments per strain

```{r, warning = FALSE, message = FALSE, fig.width=12}
complete_incomplete <- assemblies %>% group_by(Strain, Status2) %>% summarise(Count = n())

bar_complete <- plot_ly(data = complete_incomplete,
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Status2
)

bar_complete <- bar_complete %>% layout(yaxis = list(title='Count'), barmode='stack', legend = list(title=list(text='<b> Assembly type </b>')), title = "Number of assembly types per strain") 

bar_complete
```

Note:

-   "complete" - circular assembly (by Unicycler)

-   "incomplete" - linear assembly (by Unicycler)

-   "scaffold" - linear assembly (assembly made by SPAdes in a 'plasmid' mode)

### Strain DA68966 sticks out

```{r}
DA68966_summary <- assemblies %>% filter(Strain=="DA68966")
DA68966_summary
```

Very low coverage

## Summary table of plasmids assembled by SPAdes

```{r}
assemblies %>% filter(Status=="scaffold")
```

## Genome length distribution

Both chromosomes and plasmids

```{r, fig.width=10}
hist_chrom_plasm_len <- plot_ly(data = assemblies,
        alpha=0.9,
        x=~Length,
        color = ~Type,
        colors = c("#377EB8", "#FF7F00"),
        type = "histogram") %>% 
  layout(barmode = "overlay")

hist_chrom_plasm_len
```

These longest outliers among plasmids (250k, 400k, 700k and 900k) are parts of incomplete chromosomes

### "Plasmids" sorted by length

```{r}
assemblies %>% filter(Type=='Plasmid') %>% arrange(-Length)
```

#### Summary table for DA63676

```{r}
assemblies %>% filter(Strain=="DA63676")
```

Chromosome is incomplete and adds up to 5 Mbp together with the longest 'plasmid'

#### Summary table for DA63676

```{r}
assemblies %>% filter(Strain=="DA63914")
```

Same here...

# Benchmarking Universal Single-Copy Orthologues

[Link](https://busco.ezlab.org/busco_userguide.html#interpreting-the-results) to the tool description.

## Summary table of BUSCO-analysis results

```{r}

busco_files <- dir(path = busco_path, pattern = busco_filename, recursive = TRUE)

busco_list <- lapply(busco_files, function(x){
  strain <- strsplit(x, "/")[[1]][1]
  t <- read.delim(paste0(busco_path, x), skip = 9, header = FALSE, nrows = 6)
  t$Strain <- strain
  return(t)
})

busco_table <- bind_rows(busco_list) %>% select(-c(V1, V4, V5, V6))
names(busco_table) <- c("Count", "Category", "Strain")

busco_table <- busco_table %>% filter(!grepl("DA70*", Strain))

busco_table
```

### Barplot

```{r, fig.width=12}

bar_busco <- plot_ly(data = busco_table %>% filter(Category != "Total BUSCO groups searched"),
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Category
)

bar_busco <- bar_busco %>% 
  layout(yaxis = list(title='Count'), 
         barmode='group', 
         legend = list(title=list(text='<b> BUSCO categories count </b>')), 
         title = "Assembly completeness as assessed by BUSCO") 

bar_busco
```

## Summary by category

### Complete

> If found to be complete, whether single-copy or duplicated, the BUSCO matches have scored within the expected range of scores and within the expected range of length alignments to the BUSCO profile. If in fact an ortholog is not present in the input dataset, or the ortholog is only partially present (highly fragmented), and a high-identity full-length homolog is present, it is possible that this homolog could be mistakenly identified as the complete BUSCO. The score thresholds are optimised to minimise this possibility, but it can still occur.

Counts

```{r}
busco_table %>% filter(Category == "Complete BUSCOs (C)") %>% summary()
```

### Complete and single-copy

Counts

```{r}
busco_table %>% filter(Category == "Complete and single-copy BUSCOs (S)") %>% summary()
```

### Fragmented

> If found to be fragmented, the BUSCO matches have scored within the range of scores but not within the range of length alignments to the BUSCO profile. For genome assemblies this could indicate either that the gene is only partially present or that the sequence search and gene prediction steps failed to produce a full-length gene model even though the full gene could indeed be present in the assembly.

Counts

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)") %>% summary()
```

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)" & Count > 0)
```

### Missing

> If found to be missing, there were either no significant matches at all, or the BUSCO matches scored below the range of scores for the BUSCO profile. For genome assemblies this could indicate either that these orthologs are indeed missing, or that the sequence search step failed to identify any significant matches, or that the gene prediction step failed to produce even a partial gene model that might have been recognised as a fragmented BUSCO match.

Counts

```{r}
busco_table %>% filter(Category == "Missing BUSCOs (MFragmented)") %>% summary()
```


# Flye Medaka Polypolish (FMP)

I've made 131 assemblies all by both Unicycler and Flye-Medaka-Ployploish pipeline.
I should keep only the best of each pair.

```{r}
strains <- yaml::read_yaml("~/Data/HeteroR/configs/strains_incomplete_config.yaml")

strains <- names(strains$strains)

length(strains)
```

## Find and read assembly summaries

```{r}
summaries <- map_dfr(strains, 
        function(x){
          df <- read_delim(paste0("~/Data/HeteroR/results/assemblies_joined/", x, "/summary.tsv"))
          if (is_double(df$Component)) {df$Component <- as.character(df$Component)}
          return(df)
        } )


summaries
```

How many complete chromosomes?

```{r}
summaries %>% 
  filter(Type == "Chromosome") %>%  
  group_by(Status) %>%
  count() 
```

The word 'incomplete' comes from Unicycler's log **or** from 'N' in FMP assembly info ('N' is replaced by 'incomplete' later on)

```{r}
summaries %>% filter(Status == "complete")
```

```{r}
summaries %>% 
  filter(Status == "complete", Type == "Chromosome") %>% 
  pull(Strain)
```

15 strains have 'complete' chromosomes, therefore were assembled by Unicycler but not by FMP. They don't have linked assembly from FMp as their main assembly- which is OK.

## Still incomplete assemblies

```{r}
summaries %>% 
  filter(Type == "Chromosome", Status == "incomplete") %>% pull(Strain)
```

These are were assembled by FMP, still incomplete.

### Pairs plot

```{r}
incomplete_strains <- summaries %>% 
  filter(Type == "Chromosome", Status == "incomplete") %>% pull(Strain)

cov <- read_delim("~/Data/HeteroR/results/coverage/strains525.tsv") %>%
  mutate(strain = str_extract(file, "DA[0-9]*")) %>% 
  filter(strain %in% summaries$Strain) %>% 
  mutate(completeness = if_else(strain %in% incomplete_strains, "incomplete", "complete"),
         completeness.dummy = if_else(strain %in% incomplete_strains, 0, 1))

cov %>% 
  select(completeness, coverage, max_len, num_seqs, avg_len) %>% 
  GGally::ggpairs(aes(fill=completeness, color=completeness, alpha=0.3))
```


```{r}
cov.fit <- glm(completeness.dummy ~ coverage * max_len, data = cov, family = "binomial")

summary(cov.fit)
```

##  Strains that broke RACON

Eventually assembled by FMP (separate pipeline)

```{r}
strains <- yaml::read_yaml("~/Data/HeteroR/configs/strains_incomplete_broke.yaml")

strains <- names(strains$strains)

strains
```

Their assemblies are in `results/polypolish` and summary files in `results/flye`

```{r}
fpath <- "~/Data/HeteroR/results/flye/"
summary <- read_delim("~/Data/HeteroR/results/flye/DA62892/assembly_info.txt")

info_files <- dir(fpath, pattern = "*info.txt", recursive = T)

fmp_summaries <- map_dfr(info_files, function(x){
  df <- read_delim(paste0(fpath, x), col_types = "cddccdcc")
  df$strain <- str_extract(x, "DA[0-9]*")
  return(df)
  })

fmp_summaries %>% 
  group_by(strain) %>% 
  filter(length == max(length)) %>% 
  group_by(circ.) %>% 
  count()
```

All good, now them can add them to directory structure and ru the rest of the main pipeline

# Save workspace

```{r}
save.image(f="/home/andrei/Data/HeteroR/notebooks/assemblies_summary.RData")
```
