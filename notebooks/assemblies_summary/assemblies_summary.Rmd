---
title: "Genome assemblies summary"
author: "by AG"
date: "last update: `r format(Sys.time(), format = '%d %B %Y, %H:%M CET')`"
params:
  rmd: "assemblies_summary.Rmd"
output:
  html_document:
    fig_width: 8
    code_folding: hide
    df_print: paged
    toc: true
    toc_float: true
    rmdformats:
      theme: cerulean
      highlight: github
---

<a download="report.Rmd" href="`r base64enc::dataURI(file = params$rmd, mime = 'text/rmd', encoding = 'base64')`">R Markdown source file (to produce this document)</a>

```{r setup, include=F}
# output setup
knitr::opts_chunk$set(fig.width=10, fig.height=5, message = F, warning = F)

# libs
library(tidyverse)
library(plotly)
library(GGally)

# paths
ass_join <- "/home/andrei/Data/HeteroR/results/assemblies_joined/"
summary_table_output_file <- "/home/andrei/Data/HeteroR/results/genome_assembly_summary.csv"
coverage_table <- "~/Data/HeteroR/results/coverage/coverage_strain_in_data_filt.tsv"

busco_path <- "/home/andrei/Data/HeteroR/results/qualcheck_assembly/"
busco_filename <- "short_summary.specific.gammaproteobacteria_odb10.busco_results.txt"
```

# Assemblies summary table

```{r read, message = FALSE, warning = FALSE}

# get paths to assembly summary files
summary_files <- dir(path=ass_join,  pattern = "summary.tsv", recursive=TRUE)

# read and fix
summary_table <- lapply(summary_files, function(x){
  df <- read_delim(paste0(ass_join, x))
  df$Links <- as.integer(gsub(",", "", df$Links, fixed=TRUE))
  df$Length <- as.integer(gsub(",", "", df$Length, fixed=TRUE))
  df$N50 <- as.integer(gsub(",", "", df$N50, fixed=TRUE))
  df$Longest_component <- as.integer(gsub(",", "", df$Longest_component, fixed=TRUE))
  return(df)
  })

# merge into one table
summary_table <- bind_rows(summary_table)

# add wet-lab-biologist-readable Status
status_new <- sub("incomplete", "linear", summary_table$Status)
status_new <- sub("complete", "circular", status_new)
status_new <- sub("scaffold", "additional_plasmid", status_new)
status_new <- factor(status_new, levels = c("circular", "linear", "additional_plasmid"))

summary_table$Status2 <- status_new
```

Assembly summary information has been taken from Unicycler log files, total number of summary files `r length(summary_files)`


## Descriptive stat

```{r}
skimr::skim(summary_table)

```


## Incomplete assemblies total

```{r}
incomplete_assemblies <- summary_table %>% filter(Status=="incomplete")
incomplete_assemblies
```

## Incomplete chromosomes

```{r}
summary_table %>% filter(Type == "Chromosome", Status == "incomplete")
```

## Incomplete plasmids

```{r}
summary_table %>% filter(Type == "Plasmid", Status == "incomplete")
```

## Summarize

```{r}
summary_table_short <- summary_table %>% 
  select(Strain,Type, Length, Status) %>% 
  filter(Type == "Chromosome") %>% 
  select(-Type) %>% 
  rename("chrom.length" = Length) %>% 
  rename("chrom.status" = Status)

n.plasm.complete <- summary_table %>% 
  select(Strain, Type, Status) %>% 
  filter(Status == "complete", Type == "Plasmid") %>% 
  group_by(Strain) %>% 
  summarize(n.plasm.complete = n())

n.plasm.incomplete <- summary_table %>% 
  select(Strain, Type, Status) %>% 
  filter(Status == "incomplete", Type == "Plasmid") %>% 
  group_by(Strain) %>% 
  summarize(n.plasm.incomplete = n())

summary_table_short <- left_join(summary_table_short, n.plasm.complete, by="Strain") %>% left_join(n.plasm.incomplete, by="Strain")

summary_table_short$n.plasm.complete <- ifelse(is.na(summary_table_short$n.plasm.complete), 0, summary_table_short$n.plasm.complete)

summary_table_short$n.plasm.incomplete <- ifelse(is.na(summary_table_short$n.plasm.incomplete), 0, summary_table_short$n.plasm.incomplete)

summary_table_short
```


# Coverage

Is coverage affecting circularity?

## Make data set with coverage

To calculate coverage use script `coverage.py`

```{bash, eval=FALSE}
cd /home/andrei/Data/HeteroR

workflow/scripts/coverage.py ~/Data/HeteroR/resources/strain_lists/strains_in_data_raw.txt 5131220 ~/Data/HeteroR/results/coverage/coverage_strain_in_data_filt.tsv filtered

# Batch coverage:
# min = 0.871354
# avg = 15.222861
# max = 100.173186
# Coverage ~25x or less is sparse, good for Unicycler.
# Now you can create config and run the pipeline

```

## Data 

Read and process coverage data

```{r, message=F}
coverage <- read_delim(coverage_table)

coverage$Strain <- map_chr(coverage$file, function(x) strsplit(x, "/")[[1]][3])

coverage <- select(coverage, -c(file, type, format)) %>% filter(!is.na(Strain))

coverage
```

Join with summary and write results to a file

```{r}
summary_table <- left_join(summary_table, coverage, by="Strain")

write.csv(summary_table, summary_table_output_file, row.names = F)

```


## Circularity and coverage

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, coverage)) +
  geom_boxplot(aes(fill=Type), notch=T, varwidth = T) +
  facet_grid(cols = vars(Type))+
  scale_fill_brewer(palette = "Set2")+
  guides(fill = "none")+
  xlab("")

```

Coverage as well as Type may be good predictors for Circularity

## Circularity and reads sum length

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, sum_len)) +
  geom_boxplot(aes(fill=Type), notch=F, varwidth = T) +
  coord_trans(y="sqrt") +
  facet_grid(cols = vars(Type)) +
  scale_fill_brewer(palette = "Set2")+
  guides(fill="none")+
  xlab("")
```

## Circularity vs reads max length

Ryan Wick writes the following:

>... assuming that your reads are sufficiently long. Practically, this means longer than the longest repeat in the genome, as this will allow most assemblies to reach completion. For many bacterial genomes, the longest repeat will be the ribosomal RNA operon which is ~5.5 kbp, in which case a read N50 of 10 kbp is sufficient. However, some genomes have much longer repeats and will require longer reads. Overly-long reads rarely cause a problem, so you should aim for the longest reads you reasonably can.

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, max_len)) +
  geom_boxplot(aes(fill=Type), notch=T, varwidth = T) +
  facet_grid(cols = vars(Type))+
  scale_fill_brewer(palette = "Set2")+
  guides(fill="none")+
  xlab("")

```

## Circularity and reads avg length

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, avg_len)) +
  geom_boxplot(aes(fill=Type), notch=T, varwidth = T) +
  facet_grid(cols = vars(Type))+
  scale_fill_brewer(palette = "Set2")+
  guides(fill="none")+
  xlab("")

```

## Circularity and number of reads

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, num_seqs)) +
  geom_boxplot(aes(fill=Type), notch=F, varwidth = T) +
  facet_grid(cols = vars(Type))+
  coord_trans(y="sqrt")+
  scale_fill_brewer(palette = "Set2")+
  guides(fill="none")+
  xlab("")

```

## Strains with incomplete chromosomes arranged by coverage

```{r}
ggplot(summary_table %>% filter(Type=="Chromosome" & Status2 == "linear"), aes(coverage))+
  geom_histogram(fill="steelblue", bins = 100)
```


### Lowest coverage

Some of the strains were not re-sequenced yet

```{r}
summary_table %>% 
  filter(Type=="Chromosome" & Status2 == "linear") %>% 
  select(Strain, coverage) %>% 
  arrange(coverage)
```

### Highest coverage

To resequence or re-assemble with Flye-Medaka-Polypolish

```{r}
summary_table %>% 
  filter(Type=="Chromosome" & Status2 == "linear") %>% 
  select(Strain, coverage) %>% 
  arrange(-coverage)
```


# Number of plasmids per strain

```{r, message = FALSE}
plasmids_count <- summary_table %>% group_by(Strain, Type) %>% summarise(Count = n()) %>% filter(Type=="Plasmid")
plasmids_count
```

Total number of strains with plasmids identified `r length(plasmids_count$Strain)`

Could not find any plasmids in `r length(unique(summary_table$Strain)) - length(plasmids_count$Strain)` strains


## Plasmid counts per strain

**All following plots are interactive (zoomable, clickable and draggable), in case of problems reload the page**

```{r, message=FALSE, warning=FALSE, fig.width=12}
plasmids_count <- arrange(plasmids_count, -Count)

bar_plasmid <- plot_ly(
  x = plasmids_count$Strain,
  y = plasmids_count$Count,
  type = "bar" 
)

bar_plasmid %>% layout(title="Plasmids count per strain")
```


### Plasmid counts distribution


```{r, message=FALSE, warning=FALSE, fig.width=12}
# boxplot and violin plot
box_plasmid <- plasmids_count %>%
  plot_ly(
    y = ~Count,
    type = 'violin',
    box = list(
      visible = T
    ),
    meanline = list(
      visible = T
    ),
    x0 = 'Plasmid'
  )

box_plasmid <- box_plasmid %>%
  layout(
    yaxis = list(
      title = "Count",
      zeroline = F
    )
  )

box_plasmid <- box_plasmid %>% layout(title="Distribuiton of plasmid counts")

# histogram
hist_plasmids <- plasmids_count %>% 
  plot_ly(y = ~Count, type = "histogram") %>% 
  layout(title="Distribuiton of plasmid counts")

# combined
fig <- subplot(box_plasmid, hist_plasmids) %>% 

  layout(title = 'Plasmids counts distribution', showlegend=FALSE)

fig
```


## Number of complete and incomplete segments per strain

```{r, warning = FALSE, message = FALSE, fig.width=12}
complete_incomplete <- summary_table %>% group_by(Strain, Status2) %>% summarise(Count = n())

bar_complete <- plot_ly(data = complete_incomplete,
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Status2
)

bar_complete <- bar_complete %>% layout(yaxis = list(title='Count'), barmode='stack', legend = list(title=list(text='<b> Assembly type </b>')), title = "Number of assembly types per strain") 

bar_complete
```

Note:

- "complete" - circular assembly (by Unicycler)

- "incomplete" - linear assembly (by Unicycler)

- "scaffold" - linear assembly (assembly made by SPAdes in a 'plasmid' mode)


### Strain DA68966 sticks out

```{r}
DA68966_summary <- summary_table %>% filter(Strain=="DA68966")
DA68966_summary
```

Very low coverage

## Summary table of plasmids assembled by SPAdes 

```{r}
summary_table %>% filter(Status=="scaffold")
```

## Genome length distribution

Both chromosomes and plasmids

```{r, fig.width=10}
hist_chrom_plasm_len <- plot_ly(data = summary_table,
        alpha=0.9,
        x=~Length,
        color = ~Type,
        colors = c("#377EB8", "#FF7F00"),
        type = "histogram") %>% 
  layout(barmode = "overlay")

hist_chrom_plasm_len
```


These longest outliers among plasmids (250k, 400k, 700k and 900k) are parts of incomplete chromosomes

### "Plasmids" sorted by length

```{r}
summary_table %>% filter(Type=='Plasmid') %>% arrange(-Length)
```

#### Summary table for DA63676

```{r}
summary_table %>% filter(Strain=="DA63676")
```

Chromosome is incomplete and adds up to 5 Mbp together with the longest 'plasmid'

#### Summary table for DA63676

```{r}
summary_table %>% filter(Strain=="DA63914")
```

Same here...


# Benchmarking Universal Single-Copy Orthologues

[Link](https://busco.ezlab.org/busco_userguide.html#interpreting-the-results) to the tool description.

## Summary table of BUSCO-analysis results

```{r}

busco_files <- dir(path = busco_path, pattern = busco_filename, recursive = TRUE)

busco_list <- lapply(busco_files, function(x){
  strain <- strsplit(x, "/")[[1]][1]
  t <- read.delim(paste0(busco_path, x), skip = 9, header = FALSE, nrows = 6)
  t$Strain <- strain
  return(t)
})

busco_table <- bind_rows(busco_list) %>% select(-c(V1, V4, V5, V6))
names(busco_table) <- c("Count", "Category", "Strain")

busco_table <- busco_table %>% filter(!grepl("DA70*", Strain))

busco_table
```

### Barplot

```{r, fig.width=12}

bar_busco <- plot_ly(data = busco_table %>% filter(Category != "Total BUSCO groups searched"),
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Category
)

bar_busco <- bar_busco %>% 
  layout(yaxis = list(title='Count'), 
         barmode='group', 
         legend = list(title=list(text='<b> BUSCO categories count </b>')), 
         title = "Assembly completeness as assessed by BUSCO") 

bar_busco
```


## Summary by category

### Complete

>If found to be complete, whether single-copy or duplicated, the BUSCO matches have scored within the expected range of scores and within the expected range of length alignments to the BUSCO profile. If in fact an ortholog is not present in the input dataset, or the ortholog is only partially present (highly fragmented), and a high-identity full-length homolog is present, it is possible that this homolog could be mistakenly identified as the complete BUSCO. The score thresholds are optimised to minimise this possibility, but it can still occur.

Counts

```{r}
busco_table %>% filter(Category == "Complete BUSCOs (C)") %>% summary()
```

### Complete and single-copy

Counts

```{r}
busco_table %>% filter(Category == "Complete and single-copy BUSCOs (S)") %>% summary()
```

### Fragmented

>If found to be fragmented, the BUSCO matches have scored within the range of scores but not within the range of length alignments to the BUSCO profile. For genome assemblies this could indicate either that the gene is only partially present or that the sequence search and gene prediction steps failed to produce a full-length gene model even though the full gene could indeed be present in the assembly.

Counts

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)") %>% summary()
```

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)" & Count > 0)
```

### Missing

>If found to be missing, there were either no significant matches at all, or the BUSCO matches scored below the range of scores for the BUSCO profile. For genome assemblies this could indicate either that these orthologs are indeed missing, or that the sequence search step failed to identify any significant matches, or that the gene prediction step failed to produce even a partial gene model that might have been recognised as a fragmented BUSCO match.

Counts

```{r}
busco_table %>% filter(Category == "Missing BUSCOs (MFragmented)") %>% summary()
```

# Save workspace

```{r}
save.image(f="/home/andrei/Data/HeteroR/notebooks/genome_assembly_summary.RData")
```
