---
title: "Feature Engineering"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
output:
  html_document:
    toc: yes
    df_print: paged
    code_folding: hide
    fig_width: 10
    fig_height: 6
    theme: cerulean
    highlight: kate
    toc_float: yes
  html_notebook:
    df_print: paged
    toc: yes
    number_sections: yes
    toc_float: yes
    theme: cerulean
    highlight: kate
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include=F}
knitr::opts_chunk$set(fig.width=10, fig.height=5, message = F, warning = F)
library(dplyr)
library(tidyr)
library(plotly)
library(ggplot2)
library(purrr)
library(ggpubr)
```

This is a notebook for creating various features and their exploration

# Structure of the main table

Which will contain all features and will be suitable for EDA

It should contain the following variables:

-   repeat length,
-   repeat counts,
-   AR length,
-   center spanning,
-   within gene location (of a repeat),
-   distance to oriC,
-   density of matches,
-   density of RG (they often go together)
-   IS presence (?),
-   IS length (=activity)
-   number of plasmids,
-   number of plasmids carrying RGs with repeats,
-   is an RG located on a plasmid,
-   "the black box" of AR

Its tidy structure should look like this:

Each strain contains:

-   [x] 1 AB label

-   [x] 1 resistance label

-   [ ] 1 label for presence of an RG

-   [x] 1 value for plasmid count,

-   [x] 1 value for alternate plasmid count,

-   [ ] 1 value for a number plasmids carrying RGs,

-   [x] repeat count with min 100

-   [ ] repeat count with min 500

-   [ ] median repeat length with min 100

-   [ ] median repeat length with min 500

-   [ ] maximum repeat length

-   [ ] 1 value for repeat count adjusted by number of plasmids,

-   [x] tens of genes; each gene (e.g. region) contains:

    -   [ ] 1 distance to oriC,

    -   [ ] 1 density value,

    -   [ ] 'on a plasmid' label,

    -   [x] 1 value for repeat count,

    -   [ ] 1 value for IS count,

    -   [ ] value for max IS length,

    -   [x] RGI resistance mechanism,

    -   [x] RGI resistance SNP,

    -   [x] RGI other SNP,

    -   [x] RGI cut-off,

    -   [x] RGI best identities,

    -   [x] RGI AMR gene family,

    -   [x] RGI Model type,

    -   [x] RGI Drug class,

    -   [x] RGI ORF ID,

    -   [x] RGI Percentage Length of Reference Sequence,

    -   [x] a lot of repeat pairs; each repeat pair has:

        -   [x] 1 AR length,
        -   [ ] 1 AR black box vector/home/andrei/Data/HeteroR/results/repeats_summary_table.csv
        -   [x] 1 repeat length,
        -   [x] 1 center spanning label,
        -   [ ] 'inside the gene' label,

# Making a table with features

Start from a table with repeat.

```{r, eval=FALSE}
load("/home/andrei/Data/HeteroR/notebooks/features.RData")
```

## Read table with repeats - create Features

This one will a basic table for the rest of the analysis.

To build this table anew run the code chunk below (its evaluation is OFF
by default)

```{r, eval=TRUE}
# a new way of getting repeat data frame across all strains
strains <- dir("/home/andrei/Data/HeteroR/results/direct_repeats")
repeat_csv_paths <- sapply(strains, function(x){paste0("/home/andrei/Data/HeteroR/results/annotations/",x ,"/repeats/", x, "_repeats.csv")})

repeat_df <- bind_rows(lapply(repeat_csv_paths, function(x){read.csv(x)}))
# calculate AR length
repeat_df$AR_length <- repeat_df$start_2 - repeat_df$end_1 + 1

# read bed files to determine center spanning repeat pairs
bed_df <- bind_rows(lapply(strains, function (x){
  filename <- paste0("/home/andrei/Data/HeteroR/results/direct_repeats/", x, "/regions/regions_within.bed")
  df <- read.delim(filename, header=FALSE)
  df$strain <- x
  return(df)
}))

# find gene center
bed_df$gene_center <- round((bed_df$V3 - bed_df$V2 + 1)/2)
bed_df <- rename(bed_df, "record_id"=V4)
bed_df <- select(bed_df, strain, record_id, gene_center)

# bed_df contains slightly more genes than repeat_df (+624)
# BUT repeat_df is important, that's why I use left_join() below

# join the two tables
repeat_df <- left_join(repeat_df, bed_df, by="record_id")
repeat_df$spans_center <- if_else(repeat_df$end_1 <= repeat_df$gene_center & repeat_df$start_2 >= repeat_df$gene_center, "yes", "no")
repeat_df$record_id <- sub("_gene", "", repeat_df$record_id)
repeat_df <- repeat_df %>% 
  rename("repeat_length"=length) %>% 
  select(-strain.y) %>% 
  rename("strain"=strain.x) %>% 
  relocate(strain, .before=record_id)


# copy for features
# and filter strains you want to exclude
features <- as_tibble(repeat_df) %>% 
  select(-c(gene_center, start_1, end_1, start_2, end_2, X))

# look at this!
features
```

Or read it from the file *repeat_summary_table.csv* that was made during
analysis in `repeat_summary.Rmd`

It contains strains, gene names, repeat coordinates, repeat lengths, AR
lengths and 'spans center' label.

Each gene name (aka record_id) is unique.

```{r, eval=FALSE}
repeat_df <- as_tibble(read.csv("/home/andrei/Data/HeteroR/results/repeats_summary_table.csv")) %>% 
  select(-c(X.1, X)) %>% 
  relocate(strain, .before=record_id)

repeat_df$record_id <- sub("_gene", "", repeat_df$record_id)
repeat_df <- rename(repeat_df, "repeat_length"=length)

# copy for features
features <- as_tibble(repeat_df) %>% 
  select(-c(gene_center, start_1, end_1, start_2, end_2))

# look at this!
features
```


In this table we have `r length(unique(features$record_id))` resistance genes with detected repeats from `r length(unique(features$strain))` strains.

Number of repeat pairs detected `r nrow(features)`.

## Add RGI annotations$

They are required for filtering of resistance genes and much more...

### Read RGI annotations

'Loose' hits to be removed!

```{r}
strains <- unique(features$strain)[!is.na(unique(features$strain))]

rgi <- bind_rows(lapply(strains, function(x){
  df <- read.delim(paste0("/home/andrei/Data/HeteroR/results/resistance_genes/", x, "/rgi_table.txt"), na.strings = "n/a")
  df$strain <- x
  return(df)
}) )

ab_groups <- unique(rgi$Drug.Class)

# filter out Loose hits and some columns
rgi <- rgi %>% 
  filter( Cut_Off != "Loose" ) %>% 
  select(-c(Predicted_Protein, CARD_Protein_Sequence, Contig, Start, Stop, Orientation, Predicted_DNA, Note))

# turn into a tibble
rgi <- as_tibble(rgi)

# add record id and put it in front of the table
rgi$record_id <- map_chr(rgi$ORF_ID, function(x) strsplit(x, " ")[[1]][1])
rgi <- relocate(rgi, strain, record_id, .before=ORF_ID)

rgi
```

In this table `r length(unique(rgi$ORF_ID))` resistance genes have been detected from `r length(unique(rgi$strain))` strains

### How many RG don't have repeats?

It's the difference between record IDs from RGI and record IDs from Features (or repeat_df).

RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

`r length(setdiff(rgi$record_id, features$record_id))` resistant genes don't have repeats around them.

Since all record IDs in both tables are unique, difference between record IDs of both tables should equal the same number: `r length(unique(rgi$record_id)) - length(unique(features$record_id))`

### Filtering RGI results

**OBS!** Minimum number of RGs found should be much lower than 60 per
strain

Criteria:

1.  Identity percent

2.  Percentage length of reference sequence

3.  efflux pumps should go; target alteration should go; permeability
    should go; inactivation and modification should stay

4.  genes with SNPs should go

#### Number of RGs per strain: before filtering

```{r}
n_RG <- rgi %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG, aes(n_res_genes))+ geom_histogram(fill="steelblue")
```

```{r}
summary(n_RG$n_res_genes)
```

These numbers should be lower!

#### Identity percent

For *Strict* hits you may consider *Identity_percent* as another
filtering criterion, hits with too low identities should be discarded.

##### Distribution of Identity percentages before filtering

```{r, message=F}
hit.ident <-ggplot(rgi %>% select(Cut_Off, Best_Identities), aes(Best_Identities)) +
  geom_histogram(bins = 100, aes(fill=Cut_Off), alpha=0.8) +
  ggtitle("Distribution of identity percentages")

hit.ident
```

##### Leave only 90% and higher

```{r}
rgi_filt <- rgi %>% filter(Best_Identities >= 90)
summary(rgi_filt$Best_Identities)
```

### Percentage length of reference sequence

Before filtering (except for Best_Identities) it looks like this

```{r}
hist.len <-ggplot(rgi_filt %>% select(Cut_Off, Percentage.Length.of.Reference.Sequence), aes(Percentage.Length.of.Reference.Sequence)) +
  geom_histogram(bins = 100, aes(fill=Cut_Off), alpha=0.8) +
  geom_rug(aes(color=Cut_Off))+
  ggtitle("Distribution of percenatge length of reference sequence")

hist.len
```

```{r}
summary(rgi_filt$Percentage.Length.of.Reference.Sequence)
```

How short is too short? 90%

Filtering:

```{r}
rgi_filt <- filter(rgi_filt, Percentage.Length.of.Reference.Sequence >= 90)
summary(rgi_filt$Percentage.Length.of.Reference.Sequence)
```

### Number of RGs per strain : after the 1st filtering

```{r}
n_RG_filt <- rgi_filt %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG_filt, aes(n_res_genes))+ geom_histogram(fill="steelblue")
```

More filtering required!

### Filtering by Resistance.Mechanism

How many resistance mechanisms do we have?

```{r}
unique(rgi_filt$Resistance.Mechanism)
```

What have we decided to filter out?

-   efflux

-   target alteration

-   permeability

What should stay:

-   inactivation

-   modification

-   target replacement?

-   target protection?

**OBS!** Leave those records that *contain* what should stay

```{r}
stay <- c("antibiotic target replacement", "antibiotic target protection", "antibiotic inactivation")

rgi_filt <- rgi_filt %>% 
  filter(Resistance.Mechanism %in% stay)

rgi_filt
```

### Filtering SNPs

How many SNPs do we have now?

```{r}
filter(rgi_filt, !is.na(SNPs_in_Best_Hit_ARO))
```

No SNPs in the filtered RGI table.

### Number of RGs per strain: after the 2nd filtering

```{r}
n_RG_filt <- rgi_filt %>% group_by(strain) %>% summarize(n_res_genes=n())

ggplot(n_RG_filt, aes(n_res_genes))+ 
  geom_histogram(fill="steelblue")+
  xlab("Number of RGs per strain")
```

Summary

```{r}
summary(n_RG_filt$n_res_genes)
```

It's OK!

In total, I have `r length(unique(rgi_filt$record_id))` Resistance Genes in the filtered RGI

### How many genes from filtered RGI don't have repeats?

Same approach as above: it's the difference between filtered RGI's genes IDs and gene IDs from features (=repeat_df)

Filtered RGI - Features:

```{r}
length(setdiff(rgi_filt$record_id, features$record_id))
```

`r length(setdiff(rgi_filt$record_id, features$record_id))` resistance genes after filtering don't have repeats around them.

### Any NAs in features?

```{r}
apply(features, 2, function(x){sum(is.na(x))})
```

### Any NAs in filtered RGI?

```{r}
apply(rgi_filt, 2, function(x){sum(is.na(x))})
# nrow(rgi_filt) 1996
```

### Add filtered RGI annotations to Features

Use gene names as key since they are unique and make a full join with features.

**OBS!** N genes in RGI don't have repeats => N rows in Features won't have repeat_length (N = Filtered RGI - Features)

```{r}
features <- full_join(features, rgi_filt, by=c("strain", "record_id"))

features %>% filter(is.na(repeat_length)) %>% select(strain, record_id, ORF_ID, repeat_length)
```

Number of rows here should be equal to Filtered RGI - Features (see above)

Number of rows in Features: `r nrow(features)`

### Remove RGI columns that we don't need for prediction

Like ARO, Cut_Off etc.

```{r}
features <- features %>% 
  select(-c(ARO, Cut_Off, Pass_Bitscore, Best_Hit_Bitscore, Best_Hit_ARO, 
            Best_Identities, Model_ID, Model_type, Nudged, SNPs_in_Best_Hit_ARO,
            Other_SNPs, ID, Percentage.Length.of.Reference.Sequence))
features
```

**OBS!** Features still contain resistance genes without repeats!

### Remove rows with excluded genes

Since many genes were excluded from RGI results but their repeats,
counts and AR lengths stay in Features, let's make `features_filtered` without
these genes

#### Remove rows in Features without Resistance.Mechanism

How many rows don't have resistance mechanisms (i.e. have been filtered
out during RGI filtering?):
`r sum(is.na(features$Resistance.Mechanism))`

Filtering

```{r}
features_filtered <- filter(features, !is.na(Resistance.Mechanism))
features_filtered
```

#### Remove rows in features without repeat length

Those genes that don't have repeats

So far I decided to keep them but to replace NAs with 0 in gene repeat counts

```{r, eval=FALSE}
features_filtered <- filter(features, !is.na(repeat_length))
```


Number of rows in Features after filtering: `r nrow(features_filtered)`

## Add repeat counts

To each gene - repeats number in region around this gene

To each strain - total repeat count

### Based on all repeats

```{r}
repeat_counts_strain <- repeat_df %>% 
  group_by(strain) %>% 
  summarise("n_repeats_strain"=n())

repeat_counts_gene <- repeat_df %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene"=n())

# join 683482
features_filtered <- left_join(features_filtered, repeat_counts_strain, by="strain") 
features_filtered <- left_join(features_filtered, repeat_counts_gene, by="record_id")

# NAs to 0s
features_filtered$n_repeats_gene <- ifelse(is.na(features_filtered$n_repeats_gene), 0, features_filtered$n_repeats_gene)

# locate
features_filtered <- features_filtered %>% relocate(n_repeats_strain, n_repeats_gene, .before="ORF_ID")

head(features_filtered)
```

### Based on repeats \> 100 bp

```{r}
repeat_counts_strain_100 <- repeat_df %>% 
  filter(repeat_length >= 100) %>% 
  group_by(strain) %>% 
  summarise("n_repeats_strain_min100"=n())

repeat_counts_gene_100 <- repeat_df %>% 
  filter(repeat_length >= 100) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min100"=n())

# join 
features_filtered <- left_join(features_filtered, repeat_counts_strain_100, by="strain")
features_filtered <- left_join(features_filtered, repeat_counts_gene_100, by="record_id")

# NAs to 0s
features_filtered$n_repeats_gene_min100 <- ifelse(is.na(features_filtered$n_repeats_gene_min100), 0, features_filtered$n_repeats_gene_min100)

# locate
features_filtered <- features_filtered %>% relocate(n_repeats_strain_min100, n_repeats_gene_min100, .before="ORF_ID")

head(features_filtered)
```

### Based on repeats \> 500 bp

```{r}
repeat_counts_strain_500 <- repeat_df %>% 
  filter(repeat_length >= 500) %>% 
  group_by(strain) %>% 
  summarise("n_repeats_strain_min500"=n())

repeat_counts_gene_500 <- repeat_df %>% 
  filter(repeat_length >= 500) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min500"=n())

# join 
features_filtered <- left_join(features_filtered, repeat_counts_strain_500, by="strain")
features_filtered <- left_join(features_filtered, repeat_counts_gene_500, by="record_id")

# NAs to 0s
features_filtered$n_repeats_gene_min500 <- ifelse(is.na(features_filtered$n_repeats_gene_min500), 0, features_filtered$n_repeats_gene_min500)

# locate
features_filtered <- features_filtered %>% relocate(n_repeats_strain_min500, n_repeats_gene_min500, .before="ORF_ID")

head(features_filtered)
```

### Based on repeats \> 1000 bp

```{r}
repeat_counts_strain_1000 <- repeat_df %>% 
  filter(repeat_length >= 1000) %>% 
  group_by(strain) %>% 
  summarise("n_repeats_strain_min1000"=n())

repeat_counts_gene_1000 <- repeat_df %>% 
  filter(repeat_length >= 1000) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min1000"=n())

# join 
features_filtered <- left_join(features_filtered, repeat_counts_strain_1000, by="strain")
features_filtered <- left_join(features_filtered, repeat_counts_gene_1000, by="record_id")

# NAs to 0s
features_filtered$n_repeats_gene_min1000 <- ifelse(is.na(features_filtered$n_repeats_gene_min1000), 0, features_filtered$n_repeats_gene_min1000)

# locate
features_filtered <- features_filtered %>% relocate(n_repeats_strain_min1000, n_repeats_gene_min1000, .before="ORF_ID")

head(features_filtered)
```

## Add Repeat density

'repeat density' suggested by me and 'total length of repeats' proposed by Dan, are essentially the same metrics reflecting how many bases on each side of a resistance gene constitute repeats.

'repeat density' has meaning only if calculated using repeats spanning the gene's center

```{r}
# example
features_filtered_DA62886 <- features_filtered %>% filter(strain=="DA62886")
rep_len_sum <- features_filtered_DA62886 %>% filter(spans_center=="yes") %>% group_by(record_id) %>% summarise(rep_len_sum=sum(repeat_length))

features_filtered_DA62886 <- left_join(features_filtered_DA62886, rep_len_sum, by="record_id") %>% relocate(rep_len_sum, .before = "AR_length")
features_filtered_DA62886
```

```{r}

```


## Add AB testing data

### Read and process AB testing table

**OBS!** *resistance_testing.csv* may be updated

```{r}
resistance_df <- as_tibble(read.csv("/home/andrei/Data/HeteroR/resources/resistance_testing.csv", na.strings = ""))
resistance_df <- select(resistance_df, contains("SIR") | contains("strain"))
names(resistance_df) <- sub(".SIR", "", names(resistance_df))
resistance_df
```

### Make a tidy version

```{r}
resistance_df_td <- gather(resistance_df, key="AB", value="resistance", 1:8)
resistance_df_td$AB <- as.factor(resistance_df_td$AB)
resistance_df_td$resistance <- factor(resistance_df_td$resistance, ordered=T, levels = c("S", "I", "R"))
```

I'm not sure which version (regular or tidy) to add to `features`

To use AB and results of testing in plots I need a tidy version

### Add tidy version to features

```{r}
features_filtered <- left_join(features_filtered, resistance_df_td, by="strain")
features_filtered
```

**OBS!** Now filtered Features contain `r nrow(features_filtered)` rows.

## Number of plasmids

Per strain

Info on plasmids is in tables `summary.tsv` in
`results/assemblies_joined` and it has been collected in
`genome_assembly_summary.Rmd`

To build the table anew run the following chunk of code (by default its
evaluation is OFF)

```{r, eval=TRUE}
assembly_summary_files <- dir(path="/home/andrei/Data/HeteroR/results/assemblies_joined",  pattern = "summary.tsv", recursive=TRUE)
assembly_summary <- lapply(assembly_summary_files, function(x){
  df <- read.delim(paste0("/home/andrei/Data/HeteroR/results/assemblies_joined/", x), stringsAsFactors = TRUE)
  df$Links <- as.integer(gsub(",", "", df$Links, fixed=TRUE))
  df$Length <- as.integer(gsub(",", "", df$Length, fixed=TRUE))
  df$N50 <- as.integer(gsub(",", "", df$N50, fixed=TRUE))
  df$Longest_component <- as.integer(gsub(",", "", df$Longest_component, fixed=TRUE))
  return(df)
  })

assembly_summary <- as_tibble(bind_rows(assembly_summary))
assembly_summary
```

Or read the table from a file:

```{r, eval=FALSE}
assembly_summary <- as_tibble(read.csv("/home/andrei/Data/HeteroR/results/genome_assembly_summary.csv")) %>% 
  select(-X)

assembly_summary
```

### Calculate plasmid counts from summary files

```{r}
plasmid_counts <- assembly_summary %>% group_by(Strain, Type) %>% 
  summarise(n_plasmids=n()) %>% 
  filter(Type=="Plasmid") %>% 
  select(-Type) %>% 
  rename("strain"=Strain)
```

and add it to `features`

```{r}
features_filtered <- left_join(features_filtered, plasmid_counts, by="strain")
# NA in n_plasmids means 0
features_filtered$n_plasmids <- ifelse(is.na(features_filtered$n_plasmids), 0, features_filtered$n_plasmids)
head(features_filtered)
```

### Calculate number of plasmids from fasta headers + their relative coverage

We should take into account relative coverage of plasmids (i.e. number
of copies), which can be found in an assembly header, but not very
plasmid has this measure, since it is calculated y Unicycler but not by
SPAdes.

```{r, eval=TRUE}
require(data.table)
assemblies_path <- "/home/andrei/Data/HeteroR/results/assemblies_joined/"
assembly_files <- dir(path=assemblies_path, pattern="assembly.fasta$", recursive=T)

headers <- lapply(assembly_files, function(x){
  df <- fread(cmd=paste0("grep '>' ", assemblies_path, x), fill=TRUE, header = F, sep = " ", drop = 1, na.strings = "")
  df$strain <- strsplit(x, "/")[[1]][1]
  return(df)
})

headers <- bind_rows(headers)

headers$depth.rounded <- sapply(headers$V3, function(y){round(as.numeric(substr(y, 7, 10)))})
headers$length <- sapply(headers$V2, function(y){round(as.numeric(strsplit(y, "=")[[1]][2]))})
headers$circular <- sapply(headers$V4, function(y){strsplit(y, "=")[[1]][2]})

# headers_df <- fread(cmd='grep ">" /home/andrei/Data/HeteroR/results/assemblies_joined/DA68966/assembly.fasta', fill=TRUE)

# sapply(headers_df$V3, function(x){round(as.numeric(substr(x, 7, 10)))})
# sapply(headers_df$V2, function(x){round(as.numeric(strsplit(x, "=")[[1]][2]))})

headers <- headers %>% select(-c(V2, V3, V4))
headers
```

From this table I can calculate number of plasmids as sum of depths

First, remove DA68966 until it is resequenced.

```{r}
headers <- headers %>% 
  filter(strain != "DA68966")
```

Let's look at the lengths distribution because length is the key to
"smart" filtering of plasmids

```{r, fig.width=12, fig.height=4}
require(ggpubr)

h1 <- ggplot(headers, aes(length)) + 
  geom_histogram(fill="steelblue", bins = 200)+
  geom_rug() + 
  ggtitle("assembly segments lengths")

h2 <- ggplot(headers %>% filter(length >= 1000), aes(length)) + 
  geom_histogram(fill="steelblue", bins = 200)+
  geom_rug() + 
  ggtitle("assembly segments lengths, min length = 1000")

ggarrange(h1, h2, ncol=2, nrow=1)
```

Let's remove all segments shorter than 1000 bp

```{r}
headers <- headers %>% 
  filter(length >= 1000)
```

Distribution of longest segments in each strain

```{r}
headers.longest <- headers %>% group_by(strain) %>% summarise(max.length=max(length))

ggplot(headers.longest, aes(max.length))+
  geom_histogram(fill="steelblue")+
  ggtitle("Longest segments in each strain")
```

So...

How to distinguish between segmented chromosomes and real plasmids?

I can try to count a segment as "plasmid" if this segment goes after
other segments that sum up to 4.5 Mpb

Pseudo code looks like this:

For each strain:

set N=0

for each segment: if N \> 4.5 Mbp N =+ segment length mark segment as
chromosome

if unmarked segments left: mark them as plasmids

Let's try

```{r}
df.tmp <- headers %>% filter(strain=="DA62886")
sum.len <- 0
marks <- c()
for (L in df.tmp$length){
  if (sum.len < 4500000){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
  } else {
    marks <- c(marks, "plasmid")
  }
}

df.tmp$type <- marks

df.tmp
```

Apply it to full headers table

```{r}
# Naive algorithm will look like this

get.labels <- function(lengths.vec, max.sum.len){
  sum.len <- 0
  marks <- c()
  
  for (L in lengths.vec){
    if (sum.len < max.sum.len){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
    } else {
    marks <- c(marks, "plasmid")
    }
  }
  
  return(marks)
}

# apply this function to each strain's subset of the headers table
labels.total <- c()
for (S in unique(headers$strain)){
  sub.df <- filter(headers, strain==S)
  labels.sub.df <- get.labels(sub.df$length, 4500000)
  labels.total <- c(labels.total, labels.sub.df)
}

headers$label <- labels.total

headers
```

Now, I can calculate "real" plasmid count per strain and add it to the
features table

```{r}
plasmid_counts_alt <- headers %>% 
  filter(label=="plasmid") %>% 
  group_by(strain) %>% 
  summarise(n_plasmids_alt=sum(depth.rounded))

plasmid_counts_alt
```

Add this data set to filtered features

```{r}
features_filtered <- left_join(features_filtered, plasmid_counts_alt, by="strain")
```

# Beta-lactamases

A special beta-lactamases section

## Number of genes conferring resistance to Beta-lactams

How many AMR gene families do we have?

```{r}
unique(features_filtered$AMR.Gene.Family)
```

Let's collect the beta-lactamases and analyze them

```{r}
beta_lac <- c("ampC-type beta-lactamase", "CTX-M beta-lactamase", "TEM beta-lactamase", "SHV beta-lactamase", "OXA beta-lactamase", "DHA beta-lactamase")
# or you can just collect everything that contains 'beta-lactamase'
features_betalac <- features_filtered %>% filter(grepl("beta-lactamase", AMR.Gene.Family))
features_betalac
```

Make a separate table for Sofia

```{r, eval=FALSE}
strains_sofia <- read.csv("/home/andrei/Data/BSI_Ecoli/strains_uniq.txt", header = F)
sofia_betalac <- filter(features_betalac, strain %in% strains_sofia$V1) %>% select(strain, Cut_Off, Best_Hit_ARO, Model_type, Drug.Class, Percentage.Length.of.Reference.Sequence, Best_Identities, SNPs_in_Best_Hit_ARO, Resistance.Mechanism, ORF_ID, AMR.Gene.Family, AB, resistance)
write.csv(sofia_betalac, "/home/andrei/Data/BSI_Ecoli/resistance_genes_betalac.csv", row.names = F, na = "")
```

The table should look like this:

| Strain | RG  | Repeat | Length | AR  |
|--------|-----|--------|--------|-----|

That's basically what we have

```{r}
features_betalac_amp <- features_betalac %>% filter(AB=="AMP")
features_betalac_amp
```

## Plots

```{r, fig.width=10, fig.height=5}
# prepare df
# filter(resistance != "I") %>% 
feat_selected <- features_betalac_amp %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, n_repeats_strain_min100, spans_center) %>% 
                   distinct()

ggbox.rc.betalac.100 <- ggplot(feat_selected, aes(resistance, n_repeats_strain_min100)) +
        geom_boxplot(notch=T, outlier.alpha = 0.5, outlier.size = 0.5, varwidth = T) +
        geom_violin(alpha=0.1) +
        coord_trans(y="sqrt") +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat count Beta-lactamases", subtitle="Repeats > 100 bp")+
        xlab("")+
        ylab("")


ggbox.rc.betalac.100
```

# Plotting features

## Number of plasmids

### From summaries

```{r, fig.width=10, fig.height=4}
ggplot(features_filtered %>% 
         filter(!is.na(resistance)) %>% 
         filter(resistance !="I"), aes(AB, n_plasmids)) + 
  geom_boxplot(aes(fill=resistance), notch=T, outlier.alpha = 0.5, outlier.size = 0.5) +
  scale_fill_brewer(palette = "Set2") +
  coord_trans(y="sqrt") +
  xlab("")+
  ylab("n") +
  ggtitle("Plasmids count")
```

### From headers

Here plasmid numbers are calculated using relative depth of coverage
taken from assembly's fasta headers

```{r, fig.width=10, fig.height=4}
ggplot(features_filtered %>% 
         filter(!is.na(resistance)) %>% 
         filter(resistance !="I"), aes(AB, n_plasmids_alt)) + 
  geom_boxplot(aes(fill=resistance), notch=T, outlier.alpha = 0.5, outlier.size = 0.5) +
  scale_fill_brewer(palette = "Set2") +
  coord_trans(y="sqrt") +
  xlab("")+
  ylab("n") +
  ggtitle("Plasmids count (alternative count)")
```

## Repeat count

We already know that repeats shorter than 100 mainly make noise

### Repeats longer than 100 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, n_repeats_strain_min100, spans_center) %>% 
                   distinct()

ggbox.rc.ab.100 <- ggplot(feat_selected, aes(AB, n_repeats_strain_min100)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        coord_trans(y="sqrt") +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat count", subtitle="Repeats > 100 bp")+
        xlab("")+
        ylab("")


ggbox.rc.ab.100
```

### Repeats longer than 500 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, n_repeats_strain_min500, spans_center) %>% 
                   distinct()


ggbox.rc.ab.500 <- ggplot(feat_selected, aes(AB, n_repeats_strain_min500)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        facet_grid(spans_center ~ .) +
        coord_trans(y="sqrt") +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat count", subtitle="Repeats > 500 bp")+
        xlab("")+
        ylab("")


ggbox.rc.ab.500
```

### Repeats longer than 1000 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, n_repeats_strain_min1000, spans_center) %>% 
                   distinct()


ggbox.rc.ab.1000 <- ggplot(feat_selected, aes(AB, n_repeats_strain_min1000)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        facet_grid(spans_center ~ .) +
        coord_trans(y="sqrt") +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat count", subtitle="Repeats > 1000 bp")+
        xlab("")+
        ylab("")


ggbox.rc.ab.1000
```

## Repeat length

### Repeats longer than 100 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 100) %>% 
                   distinct()

ggbox.rl.ab.100 <- ggplot(feat_selected, aes(AB, repeat_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        coord_trans(y="sqrt") +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat length", subtitle="Repeats > 100 bp")+
        xlab("")+
        ylab("")


ggbox.rl.ab.100
```

### Repeats longer than 500 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 500) %>% 
                   distinct()

ggbox.rl.ab.500 <- ggplot(feat_selected, aes(AB, repeat_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        coord_trans(y="log") +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat length", subtitle="Repeats > 500 bp")+
        xlab("")+
        ylab("")


ggbox.rl.ab.500
```

### Repeats longer than 1000 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 1000) %>% 
                   distinct()

ggbox.rl.ab.1000 <- ggplot(feat_selected, aes(AB, repeat_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        coord_trans(y="log") +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Repeat length", subtitle="Repeats > 1000 bp")+
        xlab("")+
        ylab("")


ggbox.rl.ab.1000
```

## Amplifiable region size

### For repeats longer than 100 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, AR_length, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 100) %>% 
                   distinct()

ggbox.arl.ab.100 <- ggplot(feat_selected, aes(AB, AR_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Amplifiable region size", subtitle="Repeats > 100 bp")+
        xlab("")+
        ylab("")


ggbox.arl.ab.100

```

### For repeats longer than 500 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, AR_length, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 500) %>% 
                   distinct()

ggbox.arl.ab.500 <- ggplot(feat_selected, aes(AB, AR_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Amplifiable region size", subtitle="Repeats > 500 bp")+
        xlab("")+
        ylab("")


ggbox.arl.ab.500

```

### For repeats longer than 1000 bp

```{r, fig.width=10, fig.height=5}
# prepare df
feat_selected <- features_filtered %>%
                   filter(!is.na(resistance)) %>%
                   filter(resistance != "I") %>% 
                   select(strain, AB, resistance, AR_length, repeat_length, spans_center) %>% 
                   filter(repeat_length >= 1000) %>% 
                   distinct()

ggbox.arl.ab.1000 <- ggplot(feat_selected, aes(AB, AR_length)) +
        geom_boxplot(aes(fill = resistance), notch=F, outlier.alpha = 0.5, outlier.size = 0.5) +
        facet_grid(spans_center ~ .) +
        scale_fill_brewer(palette = "Set2") +
        ggtitle(label="Amplifiable region size", subtitle="Repeats > 1000 bp")+
        xlab("")+
        ylab("")

ggbox.arl.ab.1000

```

------------------------------------------------------------------------

# Save the workspace

```{r, eval=FALSE}
save.image(f="/home/andrei/Data/HeteroR/notebooks/features.RData")
```
