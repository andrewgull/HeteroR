---
title: "Feature Engineering"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
format: 
  html:
    theme: "sandstone"
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    df-print: paged
    standalone: true
    code-fold: true
editor: source
---

```{r, include=F}
knitr::opts_chunk$set(message = F, warning = F)
library(tidyverse)
library(furrr)

plan(multisession, workers = 10)

```

This is a notebook for creating various features and their exploration

# Structure of the main table

Which will contain all features and will be suitable for EDA

It should contain the following variables:

-   repeat length,
-   repeat counts,
-   AR length,
-   center spanning,
-   within gene location (of a repeat),
-   distance to oriC,
-   density of matches,
-   density of RG (they often go together)
-   IS presence (?),
-   IS length (=activity)
-   number of plasmids,
-   number of plasmids carrying RGs with repeats,
-   is an RG located on a plasmid,
-   "the black box" of AR

Its tidy structure should look like this:

Each strain contains:

-   [x] 1 AB label

-   [x] 1 resistance label

-   [x] 1 label for presence of an RG

-   [x] 1 value for plasmid count,

-   [x] 1 value for alternate plasmid count,

-   [ ] 1 value for a number plasmids carrying RGs,

-   [x] repeat count with min 100

-   [x] repeat count with min 500

-   [x] median repeat length

-   [x] median repeat length with min 100

-   [x] median repeat length with min 500

-   [x] maximum repeat length

-   [x] median AR length

-   [x] median AR length with min 100

-   [x] median AR length with min 500

-   [ ] 1 value for repeat count adjusted by number of plasmids,

-   [x] tens of genes; each gene (e.g. region) contains:

    -   [x] 1 distance to oriC,

    -   [ ] 1 density value,

    -   [x] 'on a plasmid' label,

    -   [x] 1 value for repeat count,

    -   [ ] 1 value for IS count,

    -   [ ] value for max IS length,

    -   [x] RGI resistance mechanism,

    -   [x] RGI resistance SNP,

    -   [x] RGI other SNP,

    -   [x] RGI cut-off,

    -   [x] RGI best identities,

    -   [x] RGI AMR gene family,

    -   [x] RGI Model type,

    -   [x] RGI Drug class,

    -   [x] RGI ORF ID,

    -   [x] RGI Percentage Length of Reference Sequence,

    -   [x] a lot of repeat pairs; each repeat pair has:

        -   [x] 1 AR length,
        -   \[-\] 1 AR black box matrix,
        -   [x] 1 repeat length,
        -   [x] 1 center spanning label,
        -   [ ] 'inside the gene' label,

# Making a table with features

Start from a table with repeat.

```{r, eval=FALSE}
load("/mnt/data/andrei/Data/HeteroR/notebooks/features.RData")
```

## Read table with repeats: way no. 1

This one will a basic features table for the rest of the analysis.

To build this table anew run the code chunk below (its evaluation is OFF by default)

How many strains with annotated repeats we have?

```{r}
# a new way of getting repeat data frame across all strains
strains <- dir("/mnt/data/andrei/Data/HeteroR/results/direct_repeats")
# read lab testing data and filter out not tested strains 
lab_testing <- read_csv("data/heteroresistance_testing.csv") %>% 
  filter(resistance != "R")

strains <- intersect(strains, lab_testing$strain)

length(strains)
```

### Read repeats tables

Some tables are empty!

```{r, message=FALSE}
repeat_df <- future_map_dfr(strains, function(x){
  path <- paste0("/mnt/data/andrei/Data/HeteroR/results/annotations/", x, "/repeats/", x, "_repeats.csv")
  df <- read_csv(path, col_types = "ccdddddc")
  return(df)
  }) %>% 
  mutate(AR_length = start_2 - end_1 + 1) %>% 
  select(-...1)
  
head(repeat_df)
```

Dimensions:

```{r}
dim(repeat_df)
```

In this table there are

```{r}
length(unique(repeat_df$strain))
```

strains

0 strains don't have repeats!

```{r}
setdiff(strains, unique(repeat_df$strain))
```

| **Outdated block**                                                 |
|--------------------------------------------------------------------|
| checked some of these strain, their `repeats.csv` tables are empty |

I checked `grf_perfect.log` files - this file is empty in DA62900, but have info on repeats in DA62906.

Then I checked `results/direct_repeats/DA62*/repeats_no_mismatch` directories. In DA62900 all files are empty, in DA62906 only `perfect.id` is empty, `imperfect.id` has some data inside.

I think, this is the explanation.

Conclusion: the strains above do not have (perfect) repeats longer than 20 bp indeed.

I should add them to the `repeat_df` with NAs in every column except `strain` (`skip_empty_rows=FALSE` in `read_csv` doesn't fix the problem)

```{r, eval=FALSE}
strains_no_repeats <- setdiff(strains, unique(repeat_df$strain))

no_repeats_df <- tibble(record_id = rep(NA, length(strains_no_repeats)),
                        start_1 = rep(NA, length(strains_no_repeats)),
                        end_gene.length1 = rep(NA, length(strains_no_repeats)),
                        start_2 = rep(NA, length(strains_no_repeats)),
                        end_2 = rep(NA, length(strains_no_repeats)),
                        length = rep(NA, length(strains_no_repeats)),
                        strain = strains_no_repeats,
                        AR_length = rep(NA, length(strains_no_repeats)))

no_repeats_df
```

```{r, eval=FALSE}
repeat_df <- bind_rows(repeat_df, no_repeats_df)

length(unique(repeat_df$strain))
```

------------------------------------------------------------------------

### Read BED files to determine center spanning repeat pairs

```{r, message=FALSE}
bed_df <- future_map_dfr(strains, function(x){
    path <- paste0("/mnt/data/andrei/Data/HeteroR/results/direct_repeats/", x, "/regions/regions_within.bed")
    df <- read_delim(path, col_names = FALSE, col_types = "cddcdd") %>% mutate(strain = x)
    return(df)
  }) %>% 
  mutate(gene_center = round((X3 - X2 + 1)/2)) %>% 
  rename("record_id" = X4) %>% 
  select(strain, record_id, gene_center)

head(bed_df)
```

We have bed files for

```{r}
length(unique(bed_df$strain))
```

strains.

### Features table: join bed files and repeats table

`bed_df` contains more strains and genes than `repeat_df`, but if there is no repeats AR length and gene center - `repeat_df` is important, that's why I use `left_join()` below.

```{r}
# join the two tables
features <- left_join(repeat_df, bed_df, by = "record_id") %>% 
  mutate(spans_center = if_else(end_1 <= gene_center & start_2 >= gene_center, "yes", "no"),
         record_id = sub("_gene", "", record_id)) %>% 
  rename("repeat_length" = length) %>% 
  select(-strain.y) %>% 
  rename("strain" = strain.x) %>% 
  relocate(strain, .before = record_id) %>% 
  select(strain, record_id, repeat_length, AR_length, spans_center, gene_center)

# look at this!
head(features)
```

## RGI annotations

They are required for filtering of resistance genes and much more...

### Read output tables

'Loose' hits must be removed!

```{r, message=FALSE}
# in RGI tables I don't need the last two columns (Nudged and Note) 
# because they cause problems during table reading

rgi <- future_map_dfr(strains, function(x){
        read_delim(file = paste0("/mnt/data/andrei/Data/HeteroR/results/resistance_genes/", x, "/rgi_table.txt"), na = c("n/a", ""), 
                   name_repair = "universal",
                   col_select = -c(Predicted_Protein, CARD_Protein_Sequence, Contig, Start, Stop, Orientation, Predicted_DNA, Note, Nudged),
                   show_col_types = FALSE) %>% 
          mutate(strain = x)}) %>% 
  filter(Cut_Off != "Loose") %>% 
  mutate(record_id = map_chr(ORF_ID, function(x) strsplit(x, " ")[[1]][1])) %>% 
  relocate(strain, record_id, .before=ORF_ID)

ab_groups <- unique(rgi$Drug.Class)

head(rgi)
```

In this table `r length(unique(rgi$ORF_ID))` resistance genes have been detected in `r length(unique(rgi$strain))` strains

### How many RG don't have repeats?

It's the difference between record IDs from RGI and record IDs from Features (or repeat_df).

RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

That many RGs don't have repeats around them.

Since all record IDs in both tables are unique, difference between record IDs of both tables should equal the same number: `r length(unique(rgi$record_id)) - length(unique(features$record_id))`

### Filtering RGI results

**OBS!** Minimum number of RGs found should be much lower than **60** per strain

Criteria:

1.  Identity percent

2.  Percentage length of reference sequence

3.  efflux pumps should go; target alteration should go; permeability should go; inactivation and modification should stay

4.  genes with SNPs should go

#### Number of RGs per strain: before filtering

```{r, warning=FALSE}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n)) +
    geom_histogram(fill = "steelblue")
```

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  summary()
```

These numbers should be lower!

#### Identity percent

For *Strict* hits you may consider *Identity_percent* as another filtering criterion, hits with too low identities should be discarded.

##### Distribution of Identity percentages before filtering

```{r, message=F}
rgi %>% 
  select(Cut_Off, Best_Identities) %>% 
  ggplot(aes(Best_Identities)) +
    geom_histogram(bins = 100, aes(fill = Cut_Off), alpha = 0.8) +
    facet_grid(rows=vars(Cut_Off)) +
    ggtitle("Distribution of identity percentages")
```

##### Leave only 90% and higher

```{r}
rgi <- rgi %>% 
  filter(Best_Identities >= 90)

summary(rgi$Best_Identities)
```

### Percentage length of reference sequence

Before filtering (except for Best_Identities) it looks like this

```{r}
rgi %>% 
  select(Cut_Off, Percentage.Length.of.Reference.Sequence) %>% 
  ggplot(aes(Percentage.Length.of.Reference.Sequence)) +
    geom_histogram(bins = 100, aes(fill = Cut_Off), alpha = 0.8) +
    geom_rug(aes(color = Cut_Off))+
    ggtitle("Distribution of percenatge length of reference sequence")
```

```{r}
summary(rgi$Percentage.Length.of.Reference.Sequence)
```

How short is too short? 90%

Filtering:

```{r}
rgi <- rgi %>% 
  filter(Percentage.Length.of.Reference.Sequence >= 90)

summary(rgi$Percentage.Length.of.Reference.Sequence)
```

### Number of RGs per strain : after the 1st filtering

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n)) + 
    geom_histogram(fill = "steelblue")
```

More filtering required!

### Filtering by Resistance.Mechanism (try to not use)

How many resistance mechanisms do we have?

```{r}
unique(rgi$Resistance.Mechanism)
```

What have we decided to filter out?

-   efflux

-   target alteration

-   permeability

What should stay:

-   inactivation

-   modification

-   target replacement?

-   target protection?

**OBS!** Leave those records that *contain* what should stay

```{r}
#| eval: true
stay <- c("antibiotic target replacement", "antibiotic target protection", "antibiotic inactivation")

rgi <- rgi %>% 
  filter(Resistance.Mechanism %in% stay)

dim(rgi)
```

This is the dimensions of the rgi table after filtering.

### Filtering SNPs

How many SNPs do we have now?

```{r}
rgi %>% 
  filter(!is.na(SNPs_in_Best_Hit_ARO))
```

No SNPs in the filtered RGI table - if filtering by resistance mechanism is applied

### Number of RGs per strain: after the 2nd filtering

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n))+ 
    geom_histogram(fill = "steelblue")+
    xlab("Number of RGs per strain")
```

Summary

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>%
  summary()
```

It's OK! (if filtering by Resistance mechanism is applied)

In total, I have `r length(unique(rgi$record_id))` RGs in the filtered RGI

### How many genes from filtered RGI don't have repeats?

Same approach as above: it's the difference between filtered RGI's genes IDs and gene IDs from features (=repeat_df)

Filtered RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

`r length(setdiff(rgi$record_id, features$record_id))` resistance genes after filtering don't have repeats around them.

### Number of RGs per strain per Cut_Off type

```{r}
rgi %>% 
  group_by(Cut_Off, strain) %>% 
  count() %>% 
  ggplot(aes(n))+ 
    geom_histogram(fill = "steelblue")+
    facet_grid(rows = vars(Cut_Off)) +
    xlab("Number of RGs per strain")
```

### Any NAs in features?

```{r}
features %>% 
  map(is.na) %>% 
  map_int(sum)
```

### Any NAs in filtered RGI?

```{r}
rgi %>% 
  map(is.na) %>% 
  map_int(sum)
```

### Add filtered RGI annotations to Features

Use gene names as key since they are unique and make a full join with features.

**OBS!** N genes in RGI don't have repeats =\> N rows in Features won't have repeat_length (N = Filtered RGI - Features)

```{r}
features <- full_join(features, rgi, by = c("strain", "record_id"))

features %>% 
  filter(is.na(repeat_length)) %>% 
  select(strain, record_id, ORF_ID, repeat_length)
```

Number of rows here should be equal to filtered RGI - Features (see above)

Number of rows in Features: `r nrow(features)`

### Remove RGI columns that we don't need for prediction

Like ARO, Cut_Off, Model_ID etc.

Leave Best_Hit_ARO because it contains information on types of beta-lactamases.

```{r}
#| eval: true
features <- features %>% 
  select(-c(ARO, Cut_Off, Pass_Bitscore, Best_Hit_Bitscore,
            Best_Identities, Model_ID, Model_type, SNPs_in_Best_Hit_ARO,
            Other_SNPs, ID, Percentage.Length.of.Reference.Sequence))

head(features)
```

**OBS!** Features still contain resistance genes without repeats and strains without repeats at all!

### Remove rows with excluded genes

Since many genes were excluded from RGI results but their repeats, counts and AR lengths stay in Features, let's remove them

#### Remove rows in Features without Resistance.Mechanism

How many rows don't have resistance mechanisms (i.e. have been filtered out during RGI filtering?): `r sum(is.na(features$Resistance.Mechanism))`

And no record_id?

Filtering

```{r}
features <- features %>% 
  filter(!is.na(Resistance.Mechanism), !is.na(record_id))

dim(features)
```

This is the dimensions of new `features`

How many strains in features?

```{r}
length(unique(features$strain))
```

One strain has been removed because it doesn't have any RGs or repeats

I should add it back and assign NAs everywhere

```{r, eval=FALSE}
strains_no_rg <- setdiff(strains, features$strain)

na_col <- function(){
  rep(NA, length(strains_no_rg))
}

l.rg <- length(strains_no_rg)

no_rg_df <- tibble(strain = strains_no_rg, 
                   record_id = na_col(),
                   repeat_length = na_col(),
                   AR_length = na_col(),
                   spans_center = na_col(),
                   ORF_ID = na_col(),
                   Drug.Class = na_col(),
                   Resistance.Mechanism = na_col(),
                   AMR.Gene.Family = na_col())

no_rg_df
```

This strain also doesn't have ampC beta-lactamase, which cannot be.

Should I remove it whatsoever?

Also, it has been tested as nonHR

```{r, eval=FALSE}
features <- bind_rows(features, no_rg_df)
```

# Per-strain dataset

Here will be 'per strain' features kept, that will be used for predictions

## Coverage and max read length

I've decided to add Nanopore's `coverage` and `max_len` to features. This data comes from coverage statistics.

Check on the pairs plot from assemblies summary and coverage analysis to find out why.

```{bash, eval=FALSE}
# run from within ~/Data/HeteroR
workflow/scripts/coverage_cli.py resources/strain_lists/strains525.txt 5131220 results/coverage/strains525.tsv filtered
```

Read the coverage table

```{r, message=FALSE}
coverage <- read_delim("/mnt/data/andrei/Data/HeteroR/results/coverage/strains525.tsv", na = c("", "NaN")) %>% 
  mutate(strain = str_extract(file, "DA[0-9]*")) %>% 
  select(strain, coverage, max_len)

head(coverage)
```

## Completeness and N50

`completeness` and `N50` come from assemblies summary files

```{r, message=FALSE}
summaries <- dir(path = "/mnt/data/andrei/Data/HeteroR/results/assemblies_joined",  pattern = "summary.tsv", recursive=TRUE)

assemblies <- future_map_dfr(summaries, function(x){
  read_delim(paste0("/mnt/data/andrei/Data/HeteroR/results/assemblies_joined/", x), col_types = "cccccccccccc")
  }) %>% mutate(Links = as.integer(gsub(",", "", Links, fixed = TRUE)),
                Length = as.integer(gsub(",", "", Length, fixed = TRUE)),
                N50 = as.integer(gsub(",", "", N50, fixed = TRUE)),
                Longest_component = as.integer(gsub(",", "", Longest_component, fixed = TRUE)),
                Status2 = case_when(Status == "incomplete" ~ "linear",
                             Status == "complete" | Status == "Y" ~ "circular",
                             Status == "scaffold" ~ "add.plasmid"))

head(assemblies)
```

Join these two tables to make per strain features

```{r}
features_strain <- assemblies %>% 
  filter(Type == "Chromosome") %>% 
  select(Strain, Status2, N50) %>% 
  rename("strain" = Strain, "chrom.status" = Status2) %>% 
  left_join(coverage, by = "strain") %>% 
  rename("read.max.len" = max_len)
  
head(features_strain)
```

How many strains here?

```{r}
length(unique(features_strain$strain))
```

OK

## Number of plasmids

**OBS** It's a per strain feature!

Info on plasmids is in tables `summary.tsv` in `results/assemblies_joined` and it has been collected in `genome_assembly_summary.Rmd`

### Plasmid counts from assemblies summary files

Thousands of shorter fragments (less than 1000) should be filtered out

```{r, eval=FALSE}
# we've decided to turn this off
plasmid_counts <- assemblies %>% 
  filter(Type == "Plasmid",
         Length >= 1000) %>% 
  group_by(Strain) %>% 
  count() %>% 
  rename("strain" = Strain, "n.plasmids" = n)

features_strain <- left_join(features_strain, plasmid_counts, by = "strain")
```

All NAs in `features` from now on should be 0s in the end.

### Plasmid counts from fasta headers and depth files

*the following sections of code are written by Michele*

Strains assembled with Unicycler (UC) and assembled with FMP are treated differently

```{r}
# strains assembled by Flye-Medaka-Polypolish
FMP_strains <-
  assemblies %>% 
  filter(!is.na(Repeat)) %>% 
  pull(Strain) %>% 
  unique()

# strains assembled by Unicycler
UC_strains <-
  assemblies %>% 
  filter(is.na(Repeat)) %>% 
  pull(Strain) %>% 
  unique() %>% 
  setdiff(FMP_strains)
```

#### UC read depth + plasmid count

At first I tried using the cov from spades headers and join to assemblies but got strange outputs - very high plasmid counts- code for that is in FMP_coverage_backup_code

Read depth files generated by samtools - if the biggest segment is shorter than 4 500 000 bp a warning is produced, the "raw" information about the Strain segments is stored in df_UC_short_raw. For Strains with a chromosome-like size we store average_depth, length and plasmid count for each fragment in df_UC_all

Fragments under the 1k length are removed - For Strains with a chromosome-like size fragments because the size would be inappropriate to become a plasmid - For short ones to simplify the upcoming computations

```{r}
read_depth <- function(strain_name, max_gen_size=4500000) {
  # a function to read and process genome coverage files
  # to get plasmid copy number
  path <- paste0("/mnt/data/andrei/Data/HeteroR/results/genome_coverage/",
                strain_name,
                "/depth.txt")
  
  df <- read.delim(path) %>%
    set_names(c("chr", "position", "n")) %>% 
    mutate(n = as.numeric(n), chr = as.factor(chr)) %>%
    group_by(chr) %>%
    summarize(avg_depth = mean(n), size = length(position)) %>%
    filter(size > 1000) %>%
    add_column(strain = strain_name, .before = 1) %>% arrange(desc(size)) %>%
    mutate(plasmids = round(avg_depth / avg_depth[1], 0))
  
  if (df[1, "size"] < max_gen_size) {
    warning(paste0(
      "Size of the biggest fragment of the strain ",
      strain_name,
      " is ",
      df[1, "size"],
      " bp\n\n"
    ))
    return(list(df, strain_name))
  } else {
    return(list(df, NA))
  }
}

# get list of lists: df and strain name if size of the biggest fragment is smaller than max_gen_size
list_UC <- future_map(UC_strains, ~ read_depth(.))
# rbind the first elements: data frames
df_UC <- future_map_dfr(list_UC, function(x) x[[1]])
# get the names of the strains with the size of the biggest fragment is smaller than max_gen_size
short_UC <- unique(future_map_chr(list_UC, function(x) x[[2]]))
short_UC <- short_UC[!is.na(short_UC)]

df_UC_all <- df_UC %>% 
  filter(!strain %in% short_UC)

df_UC_short_raw <- df_UC %>% 
  filter(strain %in% short_UC) %>% 
  select(-plasmids) %>% 
  dplyr::rename(Strain = strain , Length = size)

# df_UC <- df_UC_all %>% 
#   select(strain,plasmids) %>% 
#   group_by(strain) %>% 
#   summarize(tot_plasmids = sum(plasmids)-1 )

df_UC <-
  df_UC_all %>% 
  select(strain, plasmids) %>% 
  group_by(strain) %>% 
  summarize(
    plasmid.copy.number = sum(plasmids) - 1,
    n.plasmids = sum(plasmids >= 1) - 1
  )
```

#### FMP read depth + plasmid count

same as with UC

```{r}
list_FMP <- future_map(FMP_strains, ~ read_depth(.))
df_FMP <- future_map_dfr(list_FMP, function(x) x[[1]])
short_FMP <-unique(map_chr(list_FMP, function(x) x[[2]]))

df_FMP_all <- df_FMP %>% 
  filter(!strain %in% short_FMP) 

df_FMP_short_raw <-
  df_FMP %>% 
  select(-plasmids) %>% 
  filter(strain %in% short_FMP) %>% 
  dplyr::rename(Strain = strain, Length =  size)

# df_FMP <-df_FMP_all %>% 
#   select(strain,plasmids) %>% 
#   group_by(strain) %>% 
#   summarize(tot_plasmids = sum(plasmids) - 1)

df_FMP <-
  df_FMP_all %>% 
  select(strain, plasmids) %>% 
  group_by(strain) %>% 
  summarize(
    plasmid.copy.number = sum(plasmids) - 1,
    n.plasmids = sum(plasmids >= 1) - 1
  )
```

#### SHORT UC

```{r, eval =FALSE}
# short_UC

read_depth_short <- function(x) {
   path <- paste0("/mnt/data/andrei/Data/HeteroR/results/genome_coverage/", x, "/depth.txt")
   
   df <- read.delim(path) %>% 
     set_names(c("chr", "position", "n")) %>% 
     mutate(n = as.numeric(n), chr = as.factor(chr)) %>% 
     group_by(chr) %>% 
     summarize(avg_depth = mean(n), size = length(position))%>%
     filter(size > 1000) %>% 
     add_column(strain = x, .before = 1) %>% arrange(desc(size))  %>% 
     dplyr::rename(Strain = strain,Length = size)
     
   return(df)
 }
 
df_UC_short_raw <- future_map_dfr(short_UC, ~ read_depth_short(.))
df_UC_short_raw
```

I divide between those with scaffold segments and without

```{r}
UC_short_scaffold <- assemblies %>%
  filter(Strain %in% short_UC, 
         Status == "scaffold") %>%
  select(Strain) %>% 
  unique() %>%  
  unlist() %>%
  unname()

UC_short_no_scaffold <- short_UC[!short_UC %in% UC_short_scaffold] 
```

##### f(x) all_combinations & find_closest_number

all_combinations is a combinatorial algorithm that returns all possible combinations of a given set of words. it will be used to return all possible combinations of lenghts in order to find the right combination of fragments to build a chromosome with the most similar size as the average of fully assembled chromosomes.

the function find_closest_number returns, given a list of numbers and a target. it is used after all_combinations: the sums of the all_combinations output is computed and find_closest_number is used to find the combination that is closer to the median of the fully assembled chromosomes

```{r}
all_combinations <- function(x) {
  
  if(length(x) == 2) {
    return(list(x))
  }
  
  results <- list()
  
  for (i in seq_along(x)) {
    comb <- combn(x[-1], i-1)
    comb <- rbind(x[1], comb)
    for (j in seq(ncol(comb))) {
      results <- append(results, list(comb[,j]))
    }
  }
  return(results)
}




find_closest_number <- function(numbers, target) {
  closest_number <- NULL
  closest_distance <- Inf

  
  for (number in numbers) {
    distance_from_target <- abs(number - target)
    
    if (distance_from_target < closest_distance) {
      closest_number <- number

      closest_distance <- distance_from_target
    }
  }
  

  
  comb_index <- which(numbers== closest_number)
  return(comb_index)

  
} 
```

#### UC_short_no_scaffold

##### sequential building of plasmids

useful for Strains with a lot of fragments

tested on all_combinations(): \[1\] "Length 17" Time difference of 18.28518 secs \[1\] "" \[1\] "Length 18" Time difference of 1.349774 mins \[1\] "" \[1\] "Length 19" Time difference of 7.579437 mins

so I just do a cutoff. if n of fragments smaller than 19 -\> do all_combinations if \>18 -\> to it sequetially

sequential_building - just adds fragments in decreasing order until the sum arrives to 4 500 000 and merges the fragments up to that point into a chromosome. the average depth is taken into account - the biggest fragment is used as coverage reference and only fragments with a comparable coverage are used.

```{r}
get.labels <- function(lengths.vec, max.sum.len) {
  marks <- c()
  cumsum.len <- cumsum(lengths.vec)
  cumsum.len <- head(c(0, cumsum.len), n = -1)
  marks <-
    ifelse(cumsum.len < max.sum.len, "chromosome", "plasmid")
  return(marks)
}

sequential_building <- function(x, df) {
  rel_pl_count <-
    df %>% filter(Strain ==  x) %>% mutate(plasmids = round(avg_depth / avg_depth[1], 0))
  rel_pl_count_1 <- rel_pl_count %>% filter(plasmids == 1)
  
  labels.total <- c()
  labels.total <-
    unlist(tapply(
      rel_pl_count_1$Length,
      as.factor(rel_pl_count_1$Strain),
      get.labels,
      max.sum.len = 4500000
    ))
  
  rel_pl_count_1$Status <- labels.total
  # select(Component,Status) , by=c("Component"))
  
  df_all <-
    left_join(rel_pl_count,
              rel_pl_count_1 %>% select(Strain, chr, Status) ,
              by = c("Strain", "chr")) %>%
    replace_na(list(Status = "plasmid"))
  
  # rows where element is "chromosome"
  chromosome_rows <- df_all %>% filter(Status == "chromosome")
  
  # Create a new row for chromosome
  new_row <- tibble(
    Strain = x,
    Component = "merged",
    avg_depth = mean(chromosome_rows$avg_depth),
    Length = sum(chromosome_rows$Length),
    plasmids = 1,
    Status = "completed_by_hand"
    
  )
  
  # Remove the chromosome rows from the original tibble and add the new row
  df_final <- df_all %>%
    filter(Status != "chromosome") %>%
    bind_rows(new_row) %>% select(Strain, avg_depth, Length, Status, plasmids)
  
  
  return(df_final)
}
```

median size of chromosomes in fully assembled strains

```{r}
UC_size_median <- df_UC_all %>% group_by(strain)  %>%
  summarize(max_size = max(size)) %>% select(max_size) %>%  unlist %>% unname() %>%  median()
```

for UC strains without scaffold all the infos i need are in the headers of the assemblies. depth and length are extracted by the headers of the assemblies. if the number of fragments is higher than 18 are built sequentially to avoid very long computation times

```{r}
get_cov_uc_header <- function(x) {
  path <-
    paste0(
      "/mnt/data/andrei/Data/HeteroR/results/assemblies_joined/",
      x,
      "/assembly.fasta"
    )
  headers <- as_tibble(read_lines(path)) %>%
    filter(str_detect(value, ">")) %>%
    mutate(
      Length = as.numeric(str_extract(value, "(?<=length=)\\d+\\.?\\d*")),
      avg_depth = as.numeric(str_extract(value, "(?<=depth=)\\d+\\.?\\d*")),
      Strain = x
    ) %>% filter(Length > 1000) # %>%group_by(Strain) %>%  summarize(tot_plasmids = sum(plasmids)-1)
  
  if (nrow(headers) > 18) {
    sequential_building(x, df_UC_short_raw)
  } else {
    seq_lengths_chr <-
      all_combinations((headers  %>% filter(Strain == x) %>% select(Length))$Length)[find_closest_number(lapply(all_combinations((headers  %>% filter(Strain == x) %>% select(Length))$Length
      ), sum), UC_size_median)]
    
    chromosome_fragments <-
      headers %>%  filter(Length %in% unlist(seq_lengths_chr)) %>% mutate(depth_times_length = avg_depth *
                                                                            Length, Status = "NA")
    other_fragments <-
      headers %>%  mutate(Status = "NA") %>%  filter(!Length %in% unlist(seq_lengths_chr)) %>% select(Strain, avg_depth, Length, Status)
    
    
    # to build the chromosome sum lengths, and average depths normalizing by lengths
    df <-
      other_fragments %>% add_row(
        Strain = x,
        Status = "completed_by_hand",
        Length = sum(chromosome_fragments$Length),
        avg_depth = (
          sum(chromosome_fragments$depth_times_length) / sum(chromosome_fragments$Length)
        )
      )   %>%
      mutate(plasmids = round(avg_depth / avg_depth[1], 0))
    
    return(df)
  }
}

df_UC_short_no_scaffold_all <-
  future_map_dfr(UC_short_no_scaffold, ~ get_cov_uc_header(.))

df_UC_short_no_scaffold_all
```

```{r}
# df_UC_short_no_scaffold <-
#   df_UC_short_no_scaffold_all %>% 
#   select(Strain, plasmids) %>% 
#   dplyr::rename(strain = Strain) %>% 
#   group_by(strain) %>% 
#   summarize(tot_plasmids = sum(plasmids) - 1)

df_UC_short_no_scaffold <-
  df_UC_short_no_scaffold_all %>% 
  select(Strain, plasmids) %>% 
  dplyr::rename(strain = Strain) %>% 
  group_by(strain) %>% 
  summarize(
    plasmid.copy.number = sum(plasmids) - 1,
    n.plasmids = sum(plasmids >= 1) - 1
  )
```

#### UC_short_scaffold

If a scaffold is present data are taken from the depth files. if the number of fragments is higher than 18 are built sequentially to avoid very long computation times

```{r}
short_UC_scaffold_plasmids_count <- function(x) {
  headers <-
    df_UC_short_raw %>% filter(Strain == x)  %>% filter(Length > 1000)
  print(paste0(x, " with ", headers %>% nrow(), " fragments"))
  
  if (nrow(headers) > 18) {
    sequential_building(x, df_UC_short_raw)
  } else {
    seq_lengths_chr <-
      all_combinations((headers  %>% filter(Strain == x) %>% select(Length))$Length)[find_closest_number(lapply(all_combinations((headers  %>% filter(Strain == x) %>% select(Length))$Length
      ), sum), UC_size_median)]
    #return(unlist(seq_lengths_chr))
    
    chromosome_fragments <-
      headers %>%  filter(Length %in% unlist(seq_lengths_chr)) %>% mutate(depth_times_length = avg_depth *
                                                                            Length, Status = "plasmid")
    other_fragments <-
      headers %>%  mutate(Status = "plasmid") %>%  filter(!Length %in% unlist(seq_lengths_chr)) %>% select(Strain, avg_depth, Length, Status)
    
    # to build the chromosome sum lengths, and average depths normalizing by lengths
    df <-
      other_fragments %>% add_row(
        Strain = x,
        Status = "completed_by_hand",
        Length = sum(chromosome_fragments$Length),
        avg_depth = (
          sum(chromosome_fragments$depth_times_length) / sum(chromosome_fragments$Length)
        )
      )   %>%
      mutate(plasmids = round(avg_depth / avg_depth[1], 0))
    return(df)
  }
}

#short_UC_scaffold_plasmids_count(UC_short_scaffold[1])
df_UC_short_scaffold_all <-
  future_map_dfr(UC_short_scaffold, ~ short_UC_scaffold_plasmids_count(.))

df_UC_short_scaffold_all
```

```{r}
# df_UC_short_scaffold <- df_UC_short_scaffold_all %>% 
#   select(Strain,plasmids) %>% 
#   dplyr::rename(strain = Strain) %>% 
#   group_by(strain) %>% 
#   summarize(tot_plasmids = sum(plasmids) -1)

df_UC_short_scaffold <-
  df_UC_short_scaffold_all %>% 
  select(Strain, plasmids) %>% 
  dplyr::rename(strain = Strain) %>% 
  group_by(strain) %>% 
  summarize(
    plasmid.copy.number = sum(plasmids) - 1 ,
    n.plasmids = sum(plasmids >= 1) - 1
  )
```

#### Short FMP

short FMPs data are taken from depth files

there is no unique key to join the two dataframes (assemblies and dpeth)- I can use strain name and length lengths are messed up so I: order them by size merge them and check if the percentage differnce between the the length of the of the merged fragments is lower than the fragment and his neighbors. Only framgments marked as Incomplete are considered to build the chromosome.

```{r}
FMP_size_median <- df_FMP_all %>% 
  group_by(strain)  %>%
  summarize(max_size = max(size)) %>% 
  select(max_size) %>%  
  unlist() %>% 
  unname() %>%  
  median()
```

```{r}
build_short_FMP <- function(x) {
  # selecting cols of interest
  df1 <-
    df_FMP_short_raw  %>% filter(Strain == x) %>% select(Strain, avg_depth, Length) %>% arrange(desc(Length)) %>% dplyr::rename(length_ass = Length)
  df2 <-
    assemblies %>% filter(Strain == x) %>% select(Length, Status) %>% arrange(desc(Length)) %>% dplyr::rename(length_cov = Length)  %>%  filter(length_cov > 1000)
  
  
  total_df <- cbind(df1, df2) %>%
    mutate(
      diff = abs(length_ass - length_cov),
      max_length = pmax(length_ass, length_cov),
      percent_diff = 100 * diff / max_length,
      next_max_length = lead(max_length),
      prev_max_length = lag(max_length),
      max_diff_next = ifelse(
        is.na(next_max_length),
        NA,
        100 * abs(max_length - next_max_length) / next_max_length
      ),
      max_diff_prev = ifelse(
        is.na(prev_max_length),
        NA,
        100 * abs(max_length - prev_max_length) / prev_max_length
      ),
      is_lower_than_next = ifelse(
        is.na(next_max_length),
        NA,
        diff < (max_diff_next / 100) * max_length
      ),
      is_lower_than_prev = ifelse(
        is.na(prev_max_length),
        NA,
        diff < (max_diff_prev / 100) * max_length
      )
    ) %>% mutate(
      is_lower_than_neighbours = if_else(
        is.na(is_lower_than_next) |
          is.na(is_lower_than_prev),
        TRUE,
        is_lower_than_next &
          is_lower_than_prev
      )
    ) %>% select(
      -percent_diff,
      -next_max_length,
      -prev_max_length,
      -max_diff_next,
      -max_diff_prev,
      -is_lower_than_next,
      -is_lower_than_prev
    )
  
  if (!all(total_df$is_lower_than_neighbours)) {
    warning(paste0("Union by size of the strain ", x, " is not unique\n\n"))
  }

  df_out <-
    total_df %>% mutate(depth_norm = round(avg_depth / avg_depth[1], 0)) %>% filter(depth_norm ==
                                                                                      1, Status == "incomplete")
  # return all possible combinations of the segments
  seq_lengths_chr <-
    all_combinations((df_out  %>% filter(Strain == x) %>% select(max_length))$max_length)[find_closest_number(lapply(all_combinations((df_out  %>% filter(Strain == x) %>% select(max_length))$max_length
    ), sum), FMP_size_median)]
  #return(unlist(seq_lengths_chr))
  
  chromosome_fragments <-
    total_df %>%  filter(max_length %in% unlist(seq_lengths_chr)) %>% mutate(depth_times_length = avg_depth *
                                                                               max_length)
  other_fragments <-
    total_df %>%  filter(!max_length %in% unlist(seq_lengths_chr)) %>% select(Strain, avg_depth, max_length, Status)
  
  # to build the chromosome sum lengths, and average depths normalizing by lengths
  df <-
    other_fragments %>% add_row(
      Strain = x,
      Status = "completed_by_hand",
      max_length = sum(chromosome_fragments$max_length),
      avg_depth = (
        sum(chromosome_fragments$depth_times_length) / sum(chromosome_fragments$max_length)
      )
    )   %>%
    mutate(plasmids = round(avg_depth / avg_depth[1], 0))
  
  return(df)
}


df_FMP_short_all <- future_map_dfr(short_FMP, ~ build_short_FMP(.))
```

```{r}
# df_FMP_short <- df_FMP_short_all %>%
#   select(Strain,plasmids) %>% 
#   dplyr::rename(strain = Strain) %>% 
#   group_by(strain) %>% 
#   summarize(tot_plasmids = sum(plasmids) - 1)

df_FMP_short <-
  df_FMP_short_all %>% select(Strain, plasmids) %>% 
  dplyr::rename(strain = Strain) %>% 
  group_by(strain) %>% 
  summarize(
    plasmid.copy.number = sum(plasmids) - 1 ,
    n.plasmids = sum(plasmids >= 1) - 1
  )
```

### Merge all Plasmid counts

```{r}
plasmid_copy_number <- rbind(df_UC,
                             df_UC_short_no_scaffold,
                             df_UC_short_scaffold,
                             df_FMP,
                             df_FMP_short) %>% 
  rename(n.c.plasmids = plasmid.copy.number)
```

### Add to features strain

```{r}
# this part of code is of no need now
# features_strain <- features_strain
#   left_join(plasmid_copy_number, by="strain") %>% 
#     mutate(n.plasmids = ifelse(is.na(n.plasmids), 0, n.plasmids), # replace NAs w 0 
#            n.plasmids = ifelse(n.plasmids > plasmid.copy.number, plasmid.copy.number, n.plasmids)) # swap copy number and number

features_strain <- features_strain %>%
  left_join(plasmid_copy_number, by="strain")

features_strain
```

## Adjusting gene counts by plasmid copy number

this code like the one used to count plasmids from short FMP strains merges columns ordered by lengths.

```{r}
# a function to read GFF files using STANDARD read.delim
read_gff <- function(gff_filename) {
  # read and process
  df <-
    as_tibble(read.delim(gff_filename, header = F, comment.char = "#")) %>%
    select(V1, V3, V4, V5, V7, V9) %>%
    filter(V3 == "gene")
  return(df)
}

df_UC_FMP_all <-
  rbind(
    df_UC_all,
    df_FMP_all,
    df_UC_short_raw %>% dplyr::rename(strain = Strain, size = Length) %>% arrange(desc(size)) %>%
      mutate(plasmids = round(avg_depth / avg_depth[1], 0)),
    df_FMP_short_raw %>% dplyr::rename(strain = Strain, size = Length) %>% arrange(desc(size)) %>%
      mutate(plasmids = round(avg_depth / avg_depth[1], 0))
  )

count_genes <- function(x) {
  path = paste0(
    "/mnt/data/andrei/Data/HeteroR/results/annotations/",
    x,
    "/prokka/",
    x,
    "_genomic.gff"
  )
  
  strain_rgi <-
    rgi %>% filter(strain == x) %>% select(record_id) %>% unlist %>% unname
  
  df1 <-
    readLines(path) %>%
    as_tibble() %>%   filter(str_detect(value, "^##sequence")) %>%
    separate(value,
             sep = " ",
             into = c("x", "chr", "xx", "length_h")) %>% mutate(length_h = as.numeric(length_h)) %>% filter(length_h > 1000) %>%   separate(chr, sep = "_", into = c("xx", "chr")) %>% select(chr, length_h) %>% arrange(desc(length_h))
  
  
  
  df2 <-
    df_UC_FMP_all %>% filter(strain == x) %>%  select(strain, plasmids, size) %>% dplyr::rename(nc.plasmids = plasmids, length_d = size) %>% arrange(desc(length_d))
  
  
  total_df <- cbind(df1, df2) %>%
    mutate(
      diff = abs(length_h - length_d),
      max_length = pmax(length_h, length_d),
      percent_diff = 100 * diff / max_length,
      next_max_length = lead(max_length),
      prev_max_length = lag(max_length),
      max_diff_next = ifelse(
        is.na(next_max_length),
        NA,
        100 * abs(max_length - next_max_length) / next_max_length
      ),
      max_diff_prev = ifelse(
        is.na(prev_max_length),
        NA,
        100 * abs(max_length - prev_max_length) / prev_max_length
      ),
      is_lower_than_next = ifelse(
        is.na(next_max_length),
        NA,
        diff < (max_diff_next / 100) * max_length
      ),
      is_lower_than_prev = ifelse(
        is.na(prev_max_length),
        NA,
        diff < (max_diff_prev / 100) * max_length
      )
    ) %>% mutate(
      is_lower_than_neighbours = if_else(
        is.na(is_lower_than_next) |
          is.na(is_lower_than_prev),
        TRUE,
        is_lower_than_next &
          is_lower_than_prev
      )
    ) %>% select(chr, strain, nc.plasmids)
  
  if (!all(total_df$is_lower_than_neighbours)) {
    warning(paste0("Union by size of the strain ", x, " is not unique\n\n"))
  }
  
  
  read_gff(path) %>%
    separate(col = V9,
             sep = "locus_tag=",
             into = c("V10", "V11")) %>% mutate(V10 = str_extract(V10, "(?<=gene=)[^;]+")) %>% separate(V1, c("V0", "V1"), sep = "_") %>%  select(V1, V10, V11) %>% dplyr::rename(chr = V1,
                                                                                                                                                                                  gene = V10,
                                                                                                                                                                                  record_id = V11) %>% filter(!is.na(gene)) %>% merge(total_df, by = "chr") %>% return()
  
}

gene_counts_rgi <- future_map_dfr(strains, ~ count_genes(.))
```

adding gene counts to features

```{r}
features <-
  gene_counts_rgi %>% 
  select(record_id, strain, nc.plasmids) %>% 
  right_join(features, by = c("strain", "record_id"), multiple = "all") %>% 
  as_tibble()
```

## Number of beta-lactamases

We need a column with number of beta-lactamase genes per strain (instead of absence/presence)

Those genes or strains that don't have b-l genes should have zeros in repeat counts, length etc.

Here I will need this big `features` table!

```{r}
n.beta.lac <- features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  group_by(strain) %>% 
  summarise(n.beta.lac = sum(is.beta.lac))

features_strain <- left_join(features_strain, n.beta.lac, by = "strain")
```

**N.B.** strain DA63310 doesn't have any beta-lactamases!

## Location on plasmid, distance to oriC and plus strand

1)  `features` contains gene names, so I can find if it's located on a plasmid.

**OBS!** This feature should be "averaged" by strain!

t.ex.: number of genes located on plasmids (can be 0, 1, 2, 3, 4...)

"Location on plasmid" can be used later to separate all features into two groups: on plasmid and not (repeat counts, distance to oriC etc.)

2)  `features` contains gene names, I can find this in annotation files (gff, gbk etc) and assembly summary tables (completeness)

**OBS!** This feature should be "averaged" by strain!

t.ex.: *closest distance to oriC* or *median/mean distance to oriC*

If I assume that *oriC* is available only in circularized genomes then I might get NAs in some strains

3)  information on strandedness (gene orientation) is also in the gff files

```{python}
#| eval: FALSE

# This chunk is only for DA62886 gff file that was copied from Argos and
# therefore has different record_id's than any other DA62886-related file

from BCBio import GFF
from Bio import SeqIO

in_file = "/mnt/data/andrei/Data/HeteroR/results/annotations/DA62886/prokka/DA62886_genomic.gbk"
out_file = "/mnt/data/andrei/Data/HeteroR/results/annotations/DA62886/prokka/DA62886_genomic.gff"
in_handle = open(in_file)
out_handle = open(out_file, "w")

GFF.write(SeqIO.parse(in_handle, "genbank"), out_handle)

in_handle.close()
out_handle.close()

```

Here I read gff files using a custom function based on standard `read.delim()`

It's the only working way to read gff files in R

`genbankr::read.GenBank()` didn't work

`ape::read.gff()` and `ape::read.GenBank()` didn't work

`read_delim()` didn't work

`biomartr` couldn't be installed

```{r}
# a function to read GFF files using STANDARD read.delim
read_gff <- function(gff_filename) {
  # read and process
  df <-
    as_tibble(read.delim(gff_filename, header = F, comment.char = "#")) %>%
    select(V1, V3, V4, V5, V7, V9) %>%
    filter(V3 == "gene")
  return(df)
}

# get gff full paths using strain names vector
gff_files <- map_chr(strains, ~ str_c("/mnt/data/andrei/Data/HeteroR/results/annotations/", ., "/prokka/", ., "_genomic.gff"))

# read gff files right in a tibble
# it works quite long time
gff <- future_map_dfr(gff_files, ~ read_gff(.)) %>%
  separate(col = V9,
           sep = "locus_tag=",
           into = c("V10", "V11")) %>%
  select(-V10) %>%
  set_names(c("seq.region", "type", "start", "stop", "strand", "record_id")) %>%
  filter(record_id %in% unique(features$record_id)) %>%
  mutate(
    located.on.plasmid = str_detect(seq.region, "_1$", negate = T),
    on.plasmid = if_else(located.on.plasmid, "yes", "no"),
    pos.strand = if_else(strand == "+", "yes", "no"),
    gene.length = stop - start + 1 
  ) %>%
  rename("dist.to.oriC" = start) %>%
  select(record_id, dist.to.oriC, pos.strand, on.plasmid, gene.length)

```

## Remove non-beta-lactamase AMR genes from GFF

```{r}
#| eval: true
gff <- features %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  select(record_id, is.beta.lac) %>% 
  distinct() %>% 
  right_join(gff, by = "record_id") %>% 
  filter(is.beta.lac) %>% 
  select(-is.beta.lac)

gff
```

Alternative (if filtering by Resistance mechanism is not applied):

```{r, eval=FALSE}
#| eval: false
gff <- features %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  select(record_id, is.beta.lac) %>% 
  distinct() %>% 
  right_join(gff, by = "record_id")

gff
```

## Add 'on.plasmid', 'strand' and 'dist.to.oriC' to `features`

```{r}
features <- features %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  left_join(gff, by = "record_id")

head(features)
```

## Add 'strain' and 'record_id' to `gff` (GFF with BL genes)

```{r}
gff <- features %>% 
  select(strain, record_id) %>% 
  distinct() %>% 
  right_join(gff, by = "record_id")
```

### Summarize some BL-related features per strain

(from GFF)

-   minimum distance to oriC

-   average (median) distance to oriC

-   number of genes on a positive strand

-   number of genes on plasmids

All in three variants: on chromosome, on plasmids, both

```{r}
#| eval: true
min_dist_oriC <- gff %>% 
  group_by(strain, on.plasmid) %>% 
  summarise(min.dist.oriC = min(dist.to.oriC)) %>% 
  spread(key = "on.plasmid", value = "min.dist.oriC", fill = 0) %>% # FILL SHOULD BE NA BUT YOU CAN NOT ADD NA TO NUMBER
  rename("min.dist.oriC.chrom" = no, "min.dist.oriC.plasmid" = yes) %>% 
  mutate(min.dist.oriC = min.dist.oriC.chrom + min.dist.oriC.plasmid)

med_dist_oriC <- gff %>% 
group_by(strain, on.plasmid) %>% 
  summarise(med.dist.oriC = median(dist.to.oriC)) %>% 
  spread(key = "on.plasmid", value = "med.dist.oriC", fill = 0) %>% # FILL SHOULD BE NA BUT YOU CAN NOT ADD NA TO NUMBER
  rename("med.dist.oriC.chrom" = no, "med.dist.oriC.plasmid" = yes) %>% 
  mutate(med.dist.oriC = med.dist.oriC.chrom + med.dist.oriC.plasmid)

# n_genes_plus_strand <- gff %>% 
#   group_by(strain, on.plasmid) %>% 
#   summarise(n.beta.lac.plus = sum(pos.strand == "yes")) %>% 
#   spread(key = "on.plasmid", value = "n.beta.lac.plus", fill = 0) %>% 
#   rename("n.beta.lac.plus.chrom" = no, "n.beta.lac.plus.plasmid" = yes) %>% 
#   mutate(n.beta.lac.plus = n.beta.lac.plus.chrom + n.beta.lac.plus.plasmid)

# genes on plasmids are always on plasmids
# n_genes_plasmids <- gff %>% 
#   group_by(strain) %>% 
#   summarise(n.beta.lac.plasmid = sum(on.plasmid == "yes"))

# features_strain <- list(features_strain, min_dist_oriC, med_dist_oriC, n_genes_plus_strand, n_genes_plasmids) %>% 
#   reduce(left_join, by = "strain") %>% 
#   mutate(n.beta.lac.chrom = n.beta.lac - n.beta.lac.plasmid) %>% 
#   relocate(n.beta.lac.plasmid, n.beta.lac.chrom, .before = min.dist.oriC.chrom)

head(features_strain)
```

Counting the resistance genes, let's take into account plasmids copy-number

```{r}
# ERROR here: some nc.plasmids = 0 
gff_with_counts <- gene_counts_rgi %>% 
  select(record_id, strain, nc.plasmids) %>% 
  right_join(gff, by = c("record_id", "strain"))

n_genes_plus_strand <- gff_with_counts %>%
  filter(pos.strand == "yes") %>% 
  mutate(nc.plasmids.dummy = ifelse(on.plasmid == "yes", nc.plasmids, 0)) %>% 
  group_by(strain, on.plasmid) %>%
  summarise(
    n.beta.lac.plus = sum(pos.strand == "yes"),
    nc.beta.lac.plus.plasmid = sum(nc.plasmids.dummy)
  ) %>%
  spread(key = "on.plasmid", value = "n.beta.lac.plus", fill = 0) %>%
  dplyr::rename(n.beta.lac.plus.chrom = no ,
                n.beta.lac.plus.plasmid = yes) %>%
  group_by(strain) %>% 
  summarise(n.beta.lac.plus.chrom = sum(n.beta.lac.plus.chrom),
            n.beta.lac.plus.plasmid = sum(n.beta.lac.plus.plasmid),
            nc.beta.lac.plus.plasmid = sum(nc.beta.lac.plus.plasmid)) %>% 
  mutate(
    n.beta.lac.plus = n.beta.lac.plus.chrom + n.beta.lac.plus.plasmid,
    nc.beta.lac.plus = n.beta.lac.plus.chrom + nc.beta.lac.plus.plasmid
  ) 

n_genes_plasmids <-
  gff_with_counts %>%
  mutate(
    n_genes_on_plasmid = ifelse(on.plasmid == "yes", 1, 0),
    nc_genes_on_plasmid = ifelse(on.plasmid == "yes", nc.plasmids, 0)
  ) %>%
  group_by(strain) %>%
  summarise(
    n.beta.lac.plasmid = sum(n_genes_on_plasmid),
    nc.beta.lac.plasmid = sum(nc_genes_on_plasmid)
  )

features_strain <-
  list(
    features_strain,
    min_dist_oriC,
    med_dist_oriC,
    n_genes_plus_strand,
    n_genes_plasmids
  ) %>%
  purrr::reduce(left_join, by = "strain") %>%
  mutate(n.beta.lac.chrom = n.beta.lac - n.beta.lac.plasmid) %>%
  relocate(n.beta.lac.plasmid, n.beta.lac.chrom, .before = min.dist.oriC.chrom)

head(features_strain)
```

## Repeat count

**OBS!** Repeat in the current context is *a pair of identical regions of a certain length*.

### Add total repeat count

Repeats from around **non-beta-lactamase** genes should not be counted!

Also, repeat counts should be calculated separately for plasmid and chromosomal genes

```{r}
# in features_filtered every row is a repeat, to find number of repeats per strain,
# count number of rows per strains and on.plasmid
# exclude non-beta-lac genes
# according to the current repeat definition distinct() should not be used
repeat_counts <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>%
  summarise("n.rep" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep", fill = 0) %>% 
  rename("n.rep.chrom" = no, "n.rep.plasmid" = yes) %>% 
  mutate(n.rep.total = n.rep.chrom + n.rep.plasmid) %>% 
  select(strain, n.rep.chrom, n.rep.plasmid, n.rep.total)


# count number of repeats spanning center
rep_counts_center <- features %>% 
  filter(is.beta.lac, spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>%
  summarise("n.rep.cen" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.cen", fill = 0) %>% 
  rename("n.rep.cen.chrom" = no, "n.rep.cen.plasmid" = yes) %>% 
  mutate(n.rep.tot.cen = n.rep.cen.chrom + n.rep.cen.plasmid) %>% 
  select(strain, n.rep.tot.cen, n.rep.cen.chrom, n.rep.cen.plasmid)

# repeats per gene = number of rows per record_id
# exclude non-beta-lac genes
repeat_counts_gene <- features %>%
  filter(is.beta.lac) %>% 
  group_by(record_id, on.plasmid) %>%
  summarise("n.repeats.gene" = n())

# join only those counts that are in filtered features
features <- left_join(features, repeat_counts_gene, by = c("record_id", "on.plasmid") )%>% 
  relocate(n.repeats.gene, .before="ORF_ID")

# add the rest
features_strain <- list(features_strain, repeat_counts, rep_counts_center) %>% 
  reduce(left_join, by = "strain")

```

### Add repeat count, min length 100 bp

```{r}
# n reads longer than 100
repeat_counts_strain_100 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 100) %>%
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.100" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.100", fill = 0) %>% 
  rename("strain" = strain, "n.rep.100.chrom" = no, "n.rep.100.plasmid" = yes) %>% 
  mutate(n.rep.100.total = n.rep.100.chrom + n.rep.100.plasmid) %>% 
  select(strain, n.rep.100.chrom, n.rep.100.plasmid, n.rep.100.total)


# n repeats longer than 100 and spanning center
repeat_counts_strain_100_center <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes", 
         repeat_length >= 100) %>%
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.100.cen" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.100.cen", fill = 0) %>% 
  rename("strain" = strain, "n.rep.100.cen.chrom" = no, "n.rep.100.cen.plasmid" = yes) %>% 
  mutate(n.rep.100.cen.tot = n.rep.100.cen.chrom + n.rep.100.cen.plasmid) %>% 
  select(strain, n.rep.100.cen.chrom, n.rep.100.cen.plasmid, n.rep.100.cen.tot)

# join both with features_strain
features_strain <- list(features_strain, repeat_counts_strain_100, repeat_counts_strain_100_center) %>% 
  reduce(left_join, by = "strain")

#############################
## PER GENE
#############################

repeat_counts_gene_100 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 100) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min100" = n())

# join 
features <- left_join(features, repeat_counts_gene_100, by="record_id")

# not all beta-lac genes/strains have repeats longer than 100
# they are NA
# turn these NAs to 0s
features$n_repeats_gene_min100 <- ifelse(is.na(features$n_repeats_gene_min100), 0, features$n_repeats_gene_min100)

# locate
features <- features %>% relocate(n_repeats_gene_min100, .before="ORF_ID")

##################################
## SHOW FEATURES STRAIN
##################################

head(features_strain)
```

### Add repeat count, min length 500 bp

```{r}
# n reads longer than 500
repeat_counts_strain_500 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 500) %>% 
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.500" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.500", fill = 0) %>% 
  rename(n.rep.500.chrom = no,  n.rep.500.plasmid = yes) %>% 
  mutate(n.rep.500.total = n.rep.500.chrom + n.rep.500.plasmid) %>% 
  select(strain, n.rep.500.chrom, n.rep.500.plasmid, n.rep.500.total)

# n repeats longer than 500 and spanning center
repeat_counts_strain_500_center <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes", 
         repeat_length >= 500) %>%
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.500.cen" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.500.cen", fill = 0) %>% 
  rename(n.rep.500.cen.chrom = no , n.rep.500.cen.plasmid = yes ) %>% 
  mutate(n.rep.500.cen.tot = n.rep.500.cen.chrom + n.rep.500.cen.plasmid)%>%
  select(strain, n.rep.500.cen.chrom, n.rep.500.cen.plasmid, n.rep.500.cen.tot)



# join both with features_strain
features_strain <- list(features_strain, repeat_counts_strain_500, repeat_counts_strain_500_center) %>% 
  purrr::reduce(left_join, by = "strain")

features_strain
```

### Repeats inside the genes

bed_df contains the gene center

```{r}
# get csv full paths using strain names vector
repeats_centered_files <- map_chr(strains, ~ str_c("/mnt/data/andrei/Data/HeteroR/results/annotations/", ., "/repeats/", ., "_repeats_centered.csv"))

# I have to create an empty tibble to give the same names of the csv files 
empty_tibble <-  tibble(
  record_id = NA,
  gene_center = NA,
  X = NA,
  start_1 = NA,
  end_1 = NA,
  start_2 = NA,
  end_2 = NA,
  length = NA,
  strain = NA,
  spans_center = NA
)
names(empty_tibble) <- c("record_id", "gene_center","X", "start_1", "end_1", "start_2", "end_2", "length", "strain", "spans_center")

# not all strains have the _repeats_centered.csv file.
# create a new read function that skips those adding an empty tibble
read_csv_file <- possibly(read_csv, otherwise = empty_tibble)

repeats_centered <- future_map_dfr(repeats_centered_files, ~ read_csv_file(., show_col_types = FALSE)) %>% 
  mutate(record_id = sub("_gene", "", record_id))

repeats_centered <-
  right_join(repeats_centered, gff_with_counts, by = c("record_id", "strain")) %>%
  mutate(
    start_1 = if_else(start_1 > (gene_center - (gene.length / 2)), start_1, NA),
    end_1 = if_else(start_1 > (gene_center - (gene.length / 2)), end_1, NA),
    start_2 = if_else(end_2 < (gene_center + (gene.length / 2)), start_2, NA),
    end_2 = if_else(end_2 < (gene_center + (gene.length / 2)), end_2, NA)
  ) %>% filter(!is.na(start_1) |
                 !is.na(start_2)) %>% group_by(strain) %>% 
  summarise("n" =sum(n())) %>%
   dplyr::rename(strain = strain, rep.in = n)

# add to features_strain 
features_strain <- left_join(features_strain, repeats_centered, by =  "strain")
```

## Repeat length

### Median sum of repeat length

I sum up repeat lengths in each gene and divide it by number of genes -\> strain characteristic

Sum of repeat length is sum of all repeats on *one side* of a gene from center-spanning repeat pairs

```{r}
# calculate summarized repeat sum
rep_len_sum_strain_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, record_id, on.plasmid) %>%
  summarise(total_repeat_length = sum(repeat_length)) %>% 
  group_by(strain, on.plasmid) %>% 
  summarise(med.tot.rep.len = median(total_repeat_length)) %>% 
  spread(key = "on.plasmid", value = "med.tot.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.tot.rep.len.chrom" = no, 
         "med.tot.rep.len.plasmid" = yes) %>% 
  select(strain, med.tot.rep.len.chrom, med.tot.rep.len.plasmid)

rep_len_sum_strain <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, record_id) %>%
  summarise(total_repeat_length = sum(repeat_length)) %>% 
  group_by(strain) %>% 
  summarise(med.tot.rep.len = median(total_repeat_length))

# join both with features_bl_strain
features_strain <- list(features_strain, rep_len_sum_strain_split, rep_len_sum_strain) %>% 
  reduce(left_join, by = "strain")

# per gene
rep_len_sum <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(record_id) %>%
  summarise(total_repeat_length = sum(repeat_length))

features <- left_join(features, rep_len_sum, by = "record_id") %>%
  relocate(total_repeat_length, .before = "AR_length")

head(features_strain)
```

### Repeat density

Under construction.

This metric reflects maximum number of repeats per sliding window.

### Median repeat length

Only repeats found around beta-lactamase genes should be taken into account.

According to the current definition of *repeat*, `distinct()` should not be used.

```{r}
# I have removed distinct() and added filter(spans_center=="yes")
# it significantly changes everything
med_rep_len_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.rep.len = median(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.rep.len.chrom" = no, 
         "med.rep.len.plasmid" = yes) %>% 
  select(strain, med.rep.len.chrom, med.rep.len.plasmid)

med_rep_len <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len = median(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, med_rep_len_split, med_rep_len) %>% 
  reduce(left_join, by="strain")


head(features_strain)
```

### Maximum repeat length

```{r}
max_rep_len_all_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "max.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "max.rep.len.chrom" = no, 
         "max.rep.len.plasmid" = yes) %>% 
  select(strain, max.rep.len.chrom, max.rep.len.plasmid)

max_rep_len_all <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, max_rep_len_all_split, max_rep_len_all) %>% 
  reduce(left_join, by = "strain")

# center spanning
max_rep_len_cen_split <- features %>%
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "max.rep.len", fill = 0) %>% 
  rename("strain" = strain,
         "max.rep.len.cen.chrom" = no, 
         "max.rep.len.cen.plasmid" = yes) %>% 
  select(strain, max.rep.len.cen.chrom, max.rep.len.cen.plasmid)

max_rep_len_cen <- features %>%
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(max.rep.len.cen = max(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, max_rep_len_cen_split, max_rep_len_cen) %>% 
  reduce(left_join, by="strain")

head(features_strain)
```

## Amplifiable region length

### Median AR length

#### All repeat on chromosomes, plamids and both

```{r}
med_ar_len_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.AR.len.chrom" = no, 
         "med.AR.len.plasmid" = yes) %>% 
  select(strain, med.AR.len.chrom, med.AR.len.plasmid)


med_ar_len <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len = median(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, med_ar_len_split, med_ar_len) %>% 
  reduce(left_join, by = "strain")

head(features_strain)
```

#### Repeat pairs spanning center

```{r}
med_ar_len_cen_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len.cen = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len.cen", fill = 0) %>% 
  rename("strain" = strain, 
         "med.AR.len.cen.chrom" = no, 
         "med.AR.len.cen.plasmid" = yes) %>% 
  select(strain, med.AR.len.cen.chrom, med.AR.len.cen.plasmid)


med_ar_len_cen <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.cen = median(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, med_ar_len_cen_split, med_ar_len_cen) %>% 
  reduce(left_join, by = "strain")


head(features_strain)
```

### Minimum AR length

#### Only pairs spanning center

Because it doesn't have much sense otherwise

```{r}
min_ar_len_cen_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(min.AR.len.cen = min(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "min.AR.len.cen", fill = 0) %>% 
  rename("strain" = strain, 
         "min.AR.len.cen.chrom" = no, 
         "min.AR.len.cen.plasmid" = yes) %>% 
  select(strain, min.AR.len.cen.chrom, min.AR.len.cen.plasmid)

min_ar_len_cen <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(min.AR.len.cen = min(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, min_ar_len_cen_split, min_ar_len_cen) %>% 
  reduce(left_join, by = "strain")

head(features_strain)
```

## Repeats around ampC-type beta-lactamases only

All the features above were calculated for **all beta-lactamase genes**. But some of them belong specifically to **ampC-type**.

Each strain has at least one *ampC* gene. Let's add the same variables but calculated only on *ampC-type* beta-lactamases.

```{r}
features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  group_by(strain, record_id) %>% 
  summarise(n.ampC = sum(str_detect(AMR.Gene.Family, "ampC"))) %>% 
  group_by(strain) %>% 
  summarize(n.ampC = sum(n.ampC)) %>% 
  filter(n.ampC == 0)
```

In real life, every E.coli has at least 1 ampC gene on chromosome - the table above should be empty, unless `AMR.Gene.Family` is `NA`! (DA63310)

### Filter features with ampC genes only

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_ampC <- features %>% 
  filter(str_detect(AMR.Gene.Family, "ampC"))
```

### Repeat counts

On chromosome, on plasmid, both

```{r}
repeat_counts <- function(features_selected, ar) {
  # features_selected: features filtered for the beta-lactamase of interest, tibble
  # ar: beta-lactamase of interest, string
  
  ar_colnames <-
    c(
      "strain",
      paste0("n.rep.chrom.", ar),
      paste0("n.rep.plasmid.", ar)
    )
  
  features_ar <- features_selected %>%
    filter(is.beta.lac) %>%
    group_by(strain, on.plasmid) %>%
    summarise(n.rep = n()) %>%
    spread(key = "on.plasmid",
           value = n.rep,
           fill = 0) %>%
    dplyr::rename(strain = strain,
                  n.rep.chrom = no,
                  n.rep.plasmid = yes) %>%
    select(strain, n.rep.chrom, n.rep.plasmid) %>% set_names(nm = ar_colnames)
  
  return(features_ar)
}

repeat_counts_ampC <- repeat_counts(features_ampC, "ampC")
features_strain <- left_join(features_strain, repeat_counts_ampC, by = "strain")

head(features_strain)
```

### AR length

On chromosome, on plasmid, both

```{r}
# universal function again
med_ar_len_split <- function(features_selected, ar) {
  ar_colnames <-
    c("strain",
      paste0("med.AR.len.chrom.", ar),
      paste0("med.AR.len.plasmid.", ar))
  
  features_ar <- features_selected %>%
    filter(is.beta.lac) %>%
    group_by(strain, on.plasmid) %>%
    summarize(med.AR.len = median(AR_length, na.rm = T)) %>%
    spread(key = "on.plasmid",
           value = "med.AR.len",
           fill = 0) %>%
    dplyr::rename(
      strain = strain,
      med.AR.len.chrom = no ,
      med.AR.len.plasmid = yes
    ) %>%
    select(strain, med.AR.len.chrom, med.AR.len.plasmid) %>% set_names(nm = ar_colnames)
  
  return(features_ar)
}

med_ar_len <- function(features_selected, ar){
  ar_colnames <- c("strain", paste0("med.AR.len.", ar))
  
  features_ar <- features_selected %>%
    filter(is.beta.lac) %>%
    group_by(strain) %>%
    summarize(med.AR.len = median(AR_length, na.rm = T)) %>%
    set_names(nm = ar_colnames)
  
  return(features_ar)
}

# apply them
med_ar_len_split_ampC <- med_ar_len_split(features_ampC,"ampC")

med_ar_len_ampC <- med_ar_len(features_ampC,"ampC")

# add
features_strain <-
  list(features_strain, med_ar_len_split_ampC, med_ar_len_ampC) %>%
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

### Repeat length

On chromosome, on plasmid, both

```{r}
# universal functions again
med_rep_len_split <- function(features_selected, ar) {
  
  ar_colnames <-
    c("strain",
      paste0("med.rep.len.chrom.", ar),
      paste0("med.rep.len.plasmid.", ar))
  
  features_ar <- features_selected %>%
    filter(is.beta.lac) %>%
    group_by(strain, on.plasmid) %>%
    summarize(med.rep.len = median(repeat_length, na.rm = T)) %>%
    spread(key = "on.plasmid",
           value = "med.rep.len",
           fill = 0) %>%
    dplyr::rename(
      strain = strain ,
      med.rep.len.chrom = no ,
      med.rep.len.plasmid = yes
    ) %>%
    select(strain, med.rep.len.chrom, med.rep.len.plasmid) %>% set_names(nm = ar_colnames)
  return(features_ar)
}

med_rep_len <- function(features_selected, ar) {
  
  ar_colnames <- c("strain", paste0("med.rep.len.", ar))
  
  features_ar <- features_selected %>%
    filter(is.beta.lac) %>%
    group_by(strain) %>%
    summarize(med.rep.len.ampC = median(repeat_length, na.rm = T)) %>% 
    set_names(nm = ar_colnames)
  return(features_ar)
}

# apply them
med_rep_len_split_ampC <- med_rep_len_split(features_ampC, "ampC")
med_rep_len_ampC <- med_rep_len(features_ampC, "ampC")

# add both
features_strain <- list(features_strain, med_rep_len_split_ampC, med_rep_len_ampC) %>% 
  purrr::reduce(left_join, by = "strain")


head(features_strain)
```

## AMR genes counts per strain for the heatmap

**OBS** Not every gene here is a beta-lactamase!

```{r}
# get clean and unique AMR types
# NA comes from DA63310, and should be removed

sub_names <- function(names_vec){
  sub_vec <- names_vec %>% 
  sub(pattern = "(", replacement="", fixed = T) %>% 
  sub(pattern = ")", replacement="", fixed = T) %>% 
  sub(pattern = "'", replacement="", fixed = T) %>% 
  sub(pattern = "'", replacement="", fixed = T)
  return(sub_vec)
}

amr_types <- unique(features$AMR.Gene.Family)[!is.na(unique(features$AMR.Gene.Family))] %>% 
  sub_names() %>% 
  unique()

# get unique gene rows with AMR.Gene.Family
# Remove NA from DA63310
# do name cleaning as above
amr_gene_types <- features %>%
  mutate(AMR.Gene.Family = sub_names(features$AMR.Gene.Family)) %>% 
  select(strain, record_id, AMR.Gene.Family) %>%
  distinct() %>%
  filter(!is.na(AMR.Gene.Family)) 

# make a DF of each AMR type counts in each gene
amr_gene_presence <- as_tibble(
  as.data.frame(
    future_map(amr_types, function(x) ifelse(str_detect(amr_gene_types$AMR.Gene.Family, x), 1, 0)),
    col.names = amr_types))

# add strain and summarize counts
amr_gene_presence$strain <- amr_gene_types$strain
amr_gene_presence <- relocate(amr_gene_presence, strain, .before = "ampC.type.beta.lactamase")

# here sum is applied to all variables
amr_types_strain <- amr_gene_presence %>% 
  group_by(strain) %>% 
  summarise(across(.cols = everything(), .fns = sum))

# we need shorter names
#names(amr_types_strain) <- c("strain", "ampC", "DFR", "APH6", "APH3.1", "SUL", "TEM", "SAT", "ANT3", "MPH", "APH3.2", "CTX.M", "CAT", "AAC3", "OXA", "AAC6", "ANT2", "FTT", "SHV", "TR.RPP", "APH4", "QNR")

# this table will be written to a file for EDA + shiny
```

## Add AMR-type counts to features_bl_strain

```{r}
features_strain <- left_join(features_strain, amr_types_strain, by = "strain") 

head(features_strain)
```

## TEM and SHV types

These beta-lactamases are targets for tazobactam which inhibits their activity. It makes sense to add types of TEM and SHV as separate features to `features_strain`

```{r}
features %>% 
  filter(str_detect(Best_Hit_ARO, "TEM-1")) %>% 
  distinct(strain, record_id) %>% 
  group_by(strain) %>% 
  count() %>% 
  arrange(-n)
```

```{r}
sum(features_strain$SHV.beta.lactamase, na.rm = T)
```

Just two SHV beta-lacs...

and the most of TEMs, are TEM-1

So, there is no information in this.

## TEM families analysis

select TEM strains

```{r}
TEM_rgi <- rgi %>% 
  filter(str_detect(Best_Hit_ARO, "TEM")) 

TEM_rgi

TEM_strains <- TEM_rgi %>%  select(strain) %>%  unlist %>%  unname %>% unique
```

extract sequences

```{r, eval=FALSE}
library(Biostrings)
tem_select <- function(x) {
  path <-
    paste0(
      "/mnt/data/andrei/Data/HeteroR/results/annotations/",
      x,
      "/prokka/",
      x,
      "_genomic.ffn"
    )
  
  
  header <-
    TEM_rgi %>%  filter(strain == x) %>%  select(ORF_ID) %>%  unlist %>% unname
  
  fasta_seq <- readDNAStringSet(path)
  
  out <-   fasta_seq[names(fasta_seq) %in% header]
  metadata(out) <- list(strain = x)
  
  return(out)
}


tem_selected_seqs <- future_map(TEM_strains, ~ tem_select(.))

# Merge the DNAStringSets into a single DNAStringSet
merged_dna_set <- Reduce(c, tem_selected_seqs)
merged_dna_set
```

Check if all sequences in dna_set are the same

```{r, eval=FALSE}
unique(merged_dna_set)
```

we have 8 differnet sequences, how many different families do we have?

```{r}
TEM_rgi %>%  select(Best_Hit_ARO) %>%  unique()
```

We have 4 families, how many different AA sequences do we have?

```{r, eval=FALSE}
unique(translate(merged_dna_set))
```

one per family?

lets check how many different sequences there are per family

```{r, eval=FALSE}
merged_dna_set_tb <- tibble(
  width = width(merged_dna_set),
  sequence = as.character(merged_dna_set),
  name = names(merged_dna_set)
) %>% dplyr::rename(ORF_ID = name) %>% merge(TEM_rgi %>% select(ORF_ID,Best_Hit_ARO ), by= "ORF_ID") 

merged_dna_set_tb %>% select(Best_Hit_ARO,sequence) %>%
  count(Best_Hit_ARO,sequence, name = "count") %>%
  group_by(Best_Hit_ARO) %>%
  summarise(unique_count = n()) %>%  arrange(desc(unique_count))
```

ok, I have 5 different sequences for TEM-1, how many different AA seq for TEM-1?

```{r, eval=FALSE}
merged_dna_set_tb %>% 
  filter(Best_Hit_ARO == "TEM-1") %>%  
  select(sequence) %>% 
  unlist() %>% 
  unname() %>%  
  DNAStringSet() %>% 
  unique() %>% 
  translate() %>%  
  unique()
```

ok, one sequence. no needs to fix anything

Biostrings creates a lot of conflicts, better to detach it.

```{r, eval=FALSE}
detach("package:Biostrings", unload = TRUE)
```

## Number of TEM per seqence

```{r}
tem_pivot <- TEM_rgi %>%
  group_by(strain, Best_Hit_ARO) %>%
  summarise(n = n()) %>%
  pivot_wider(names_from = Best_Hit_ARO, values_from = n, values_fill = 0) %>% dplyr::rename(n.TEM.1= `TEM-1`,n.TEM.210= `TEM-210`,n.TEM.148= `TEM-148`,n.TEM.37= `TEM-37` )

features_strain <- left_join(features_strain, tem_pivot, by = "strain")
head(features_strain)
```

## Repeats around CTX-type beta-lactamases only

```{r}
features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  group_by(strain, record_id) %>% 
  summarise(n.CTX = sum(str_detect(AMR.Gene.Family, "CTX"))) %>% 
  group_by(strain) %>% 
  summarize(n.CTX = sum(n.CTX)) %>% 
  filter(n.CTX != 0)
```

43 strains with CTX

### Filter features with CTX genes only

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_CTX <- features %>% 
  filter(str_detect(AMR.Gene.Family, "CTX"))
```

### Repeat counts

On chromosome, on plasmid, both

```{r}
# using that universal function
repeat_counts_CTX <- repeat_counts(features_CTX, "CTX")

# add to features_strain
features_strain <- left_join(features_strain, repeat_counts_CTX, by = "strain")

head(features_strain)
```

### AR length

On chromosome, on plasmid, both

```{r}
# using those universal functions
med_ar_len_split_CTX <- med_ar_len_split(features_CTX, "CTX")
med_ar_len_CTX <- med_ar_len(features_CTX, "CTX")

# add
features_strain <- list(features_strain, med_ar_len_split_CTX, med_ar_len_CTX) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

### Repeat length

On chromosome, on plasmid, both

```{r}
# universal functions
med_rep_len_split_CTX <- med_rep_len_split(features_CTX, "CTX")
med_rep_len_CTX <- med_rep_len(features_CTX, "CTX")

# add both
features_strain <- list(features_strain, med_rep_len_split_CTX, med_rep_len_CTX) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

## Repeats around TEM-type beta-lactamases only

```{r}
features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  group_by(strain, record_id) %>% 
  summarise(TEM = sum(str_detect(AMR.Gene.Family, "TEM"))) %>% 
  group_by(strain) %>% 
  summarize(TEM = sum(TEM)) %>% 
  filter(TEM != 0)
```

184 strains with TEM

### Filter features with TEM genes only

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_TEM <- features %>% 
  filter(str_detect(AMR.Gene.Family, "TEM"))
```

### Repeat counts

On chromosome, on plasmid, both

```{r}
# universal function
repeat_counts_TEM <- repeat_counts(features_TEM, "TEM")

# add
features_strain <-left_join(features_strain, repeat_counts_TEM, by = "strain")

head(features_strain)
```

### AR length

On chromosome, on plasmid, both

```{r}
# universal functions
med_ar_len_split_TEM <- med_ar_len_split(features_TEM,"TEM")

med_ar_len_TEM <- med_ar_len(features_TEM,"TEM")

# add
features_strain <- list(features_strain, med_ar_len_split_TEM, med_ar_len_TEM) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

### Repeat length

On chromosome, on plasmid, both

```{r}
# universal functions
med_rep_len_split_TEM <- med_rep_len_split(features_TEM, "TEM")

med_rep_len_TEM <- med_rep_len(features_TEM, "TEM")

# add both
features_strain <- list(features_strain, med_rep_len_split_TEM, med_rep_len_TEM) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

## Repeats around SHV-type beta-lactamases only

```{r}
features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  group_by(strain, record_id) %>% 
  summarise(n.SHV = sum(str_detect(AMR.Gene.Family, "SHV"))) %>% 
  group_by(strain) %>% 
  summarize(n.SHV = sum(n.SHV)) %>% 
  filter(n.SHV != 0)
```

2 strains with SHV

### Filter features with SHV genes only

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_SHV <- features %>% 
  filter(str_detect(AMR.Gene.Family, "SHV"))
```

### Repeat counts

On chromosome, on plasmid, both

```{r}
# all of the SHV resistance genes are on plasmids, can't use the function

repeat_counts_SHV <- features_SHV %>%
  filter(is.beta.lac) %>%
  group_by(strain, on.plasmid) %>%
  summarise(n.rep = n()) %>%
  spread(key = "on.plasmid", value = n.rep, fill = 0) %>%
  dplyr::rename(strain = strain, n.rep.plasmid.SHV = yes)

features_strain <- left_join(features_strain, repeat_counts_SHV, by = "strain")

head(features_strain)
```

### AR length

On chromosome, on plasmid, both

```{r}
med_ar_len_split_SHV <- features_SHV %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len", fill = 0) %>% 
  dplyr::rename(strain = strain, 
         med.AR.len.plasmid.SHV =yes ) %>% 
  select(strain, med.AR.len.plasmid.SHV)

med_ar_len_SHV <- med_ar_len(features_SHV, "SHV")

# add
features_strain <- list(features_strain, med_ar_len_split_SHV, med_ar_len_SHV) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

### Repeat length

On chromosome, on plasmid, both

```{r}
# same problem as before, no genes on chromosomes, I have to rewrite the function.
med_rep_len_split_SHV <- features_SHV %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.rep.len = median(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.rep.len", fill = 0) %>% 
  dplyr::rename(strain = strain ,
         med.rep.len.plasmid.SHV= yes )
  
med_rep_len_SHV <- med_rep_len(features_SHV, "SHV")

# add both
features_strain <- list(features_strain, med_rep_len_split_SHV, med_rep_len_SHV) %>% 
  purrr::reduce(left_join, by = "strain")

head(features_strain)
```

## IS elements

```{r}
is_strains <- dir("/mnt/data/andrei/Data/HeteroR/results/isescan")
```

```{r message=FALSE}
read_isescan_csv <- function(strain_name) {
  path <-
    paste0(
      "/mnt/data/andrei/Data/HeteroR/results/isescan/",
      strain_name,
      "/regions/regions_joined_final.fasta.csv"
    )
  
  df <- read_csv(path) %>% 
    add_column(strain = strain_name, .before = 1)
  
  return(df)
}

isescan_df <- future_map_dfr(is_strains, ~ read_isescan_csv(.))

isescan_df$seqID <- str_remove_all(isescan_df$seqID, "_gene")

isescan_df
```

### per strain features

```{r}
#families per strain
is_types <- isescan_df  %>%
  dplyr::count(family, strain, name = "count") %>%
  group_by(strain) %>%
  summarise(unique_count = n()) %>% 
  dplyr::rename(n.is.fam = unique_count)

#total amount of IS per strain
is_all <- isescan_df  %>%
  group_by(strain) %>%
  summarise(count = n()) %>%
  dplyr::rename(n.is.tot = count)

# per strain max length 
max_len <- isescan_df %>% 
  filter(family != "new" ) %>% 
  group_by(strain)%>%
  summarise(max.is.len = max(isLen)) 

# families wide 
families_pivot <- isescan_df %>%
  group_by(strain, family) %>%
  summarise(n = n()) %>%
  pivot_wider(names_from = family, values_from = n, values_fill = 0)

# min distance gene IS 
# just considering useful distances, no IS inside of the gene
min_distance_is_gene <-
  features %>% select(strain, record_id, gene.length, gene_center) %>%  
  distinct %>%  left_join((
    isescan_df %>% dplyr::rename(record_id = seqID) %>% mutate(isCenter = (isBegin + isEnd) / 2)
  ),
  by = c("record_id", "strain")) %>%
  mutate(
    is_gene_distance = abs(isCenter - gene_center),
    is_inside_gene = ifelse(is_gene_distance < (gene.length / 2), TRUE, FALSE)
  ) %>%  
  filter(!is_inside_gene) %>% 
  group_by(strain) %>% 
  summarise(min_distance_is_gene = min(is_gene_distance)) 

# number of genes with IS inside
interrupted_genes <-
  features %>% 
  select(strain, record_id, gene.length, gene_center) %>% 
  distinct %>%
  left_join((
    isescan_df %>% dplyr::rename(record_id = seqID) %>% mutate(isCenter = (isBegin + isEnd) / 2)
  ), by = c("record_id", "strain")) %>%
  mutate(
    is_gene_distance = abs(isCenter - gene_center),
    is_inside_gene = ifelse(is_gene_distance < (gene.length / 2), TRUE, FALSE)
  ) %>% 
  group_by(strain) %>%
  summarise(n.interrupted.genes = sum(as.numeric(is_inside_gene)))


# add to feature_strain 
features_strain <- 
  list(features_strain, is_types, max_len, families_pivot, is_all, min_distance_is_gene, interrupted_genes) %>% 
  reduce(left_join, by = "strain") %>% 
  as_tibble() #??
```

Are there any genes that have the same insertion sequence family on both sides?

```{r}
features %>% 
  select(strain, record_id, gene.length, gene_center) %>% 
  distinct %>% 
  left_join((isescan_df %>% 
               dplyr::rename(record_id=seqID)), by= c("record_id","strain")) %>%
  mutate(isCenter = (isBegin + isEnd)/2, is_gene_distance = abs(isCenter - gene_center), is_inside_gene = ifelse(is_gene_distance < (gene.length/2), TRUE, FALSE)) %>% 
  filter(is_inside_gene) %>%
  group_by(strain, record_id, family) %>%
  filter(any(gene_center < lag(isCenter) & family == lag(family)) & 
           any(gene_center > lead(isCenter) & family == lead(family))) %>%
  distinct(strain,record_id, family) 
```

nope

------------------------------------------------------------------------

### How many families found?

```{r}
length(unique(isescan_df$family))
```

### How many genes per strain have IS elements?

```{r}
isescan_df %>% 
  select(strain, seqID) %>%
  distinct() %>%
  group_by(strain) %>%
  count() %>%
  arrange(-n)
```

```{r}
isescan_df %>% 
  select(strain, seqID) %>%
  distinct() %>%
  group_by(strain) %>%
  count() %>%
  arrange(-n) %>% 
  ggplot(aes(n)) +
  geom_histogram() +
  xlab("n genes with IS")
```

### How many families per strain?

```{r}
isescan_df %>% 
  select(strain, family) %>%
  distinct() %>%
  group_by(strain) %>%
  count() %>%
  arrange(-n)
```

```{r}
isescan_df %>% 
  select(strain, family) %>%
  distinct() %>%
  group_by(strain) %>%
  count() %>%
  arrange(-n) %>% 
  ggplot(aes(n)) +
  geom_histogram() +
  xlab("IS families")
```

### IS length distribution

```{r}
isescan_df %>% 
  ggplot(aes(isLen)) +
  geom_histogram() +
  geom_rug()
```

```{r}
isescan_df %>% filter(isLen > 10000)
```

Which strains have 'new'?

```{r}
isescan_df %>% filter(family == "new") %>% pull(strain) %>% unique()
```

### Copy number within each family

```{r}
isescan_df %>% group_by(family) %>% count() %>%
  ggplot(aes(family, n)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

### Families and lengths

```{r}
isescan_df %>% 
  ggplot(aes(family, isLen)) +
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

### ncopy4is ??

```{r}
isescan_df %>% 
  ggplot(aes(ncopy4is)) +
  geom_histogram()
```

### ncopy4is per family

```{r}
isescan_df %>% 
  ggplot(aes(family, ncopy4is)) +
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

```{r}
isescan_df %>% 
  ggplot(aes(isLen, ncopy4is)) +
  geom_point()
```

`isLen` and `ncopy4is` are not related

## Write AMP tables required for EDA to files

Resistance testing will be added later in the EDA section

```{r}
write.csv(n.beta.lac, "/mnt/data/andrei/Data/HeteroR/results/tables/n_beta_lac.csv", row.names = F)

write.csv(features_strain, "/mnt/data/andrei/Data/HeteroR/results/tables/features_strain.csv", row.names = F)

write.csv(features, "/mnt/data/andrei/Data/HeteroR/results/tables/features.csv", row.names = F)

# write amp amr types to a file
write.csv(amr_types_strain, "/mnt/data/andrei/Data/HeteroR/results/tables/amr_types_strain.csv", row.names = FALSE)
```

# Save the workspace

```{r, eval=TRUE}
save.image(f = "/mnt/data/andrei/Data/HeteroR/notebooks/features.RData")
```
