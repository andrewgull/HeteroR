---
title: "Feature Engineering"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
format: 
  html:
    theme: "sandstone"
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    df-print: paged
    standalone: true
    code-fold: true
editor: visual
---

```{r, include=F}
knitr::opts_chunk$set(message = F, warning = F)
library(tidyverse)
```

This is a notebook for creating various features and their exploration

# Structure of the main table

Which will contain all features and will be suitable for EDA

It should contain the following variables:

-   repeat length,
-   repeat counts,
-   AR length,
-   center spanning,
-   within gene location (of a repeat),
-   distance to oriC,
-   density of matches,
-   density of RG (they often go together)
-   IS presence (?),
-   IS length (=activity)
-   number of plasmids,
-   number of plasmids carrying RGs with repeats,
-   is an RG located on a plasmid,
-   "the black box" of AR

Its tidy structure should look like this:

Each strain contains:

-   [x] 1 AB label

-   [x] 1 resistance label

-   [x] 1 label for presence of an RG

-   [x] 1 value for plasmid count,

-   [x] 1 value for alternate plasmid count,

-   [ ] 1 value for a number plasmids carrying RGs,

-   [x] repeat count with min 100

-   [x] repeat count with min 500

-   [x] median repeat length

-   [x] median repeat length with min 100

-   [x] median repeat length with min 500

-   [x] maximum repeat length

-   [x] median AR length

-   [x] median AR length with min 100

-   [x] median AR length with min 500

-   [ ] 1 value for repeat count adjusted by number of plasmids,

-   [x] tens of genes; each gene (e.g. region) contains:

    -   [x] 1 distance to oriC,

    -   [ ] 1 density value,

    -   [x] 'on a plasmid' label,

    -   [x] 1 value for repeat count,

    -   [ ] 1 value for IS count,

    -   [ ] value for max IS length,

    -   [x] RGI resistance mechanism,

    -   [x] RGI resistance SNP,

    -   [x] RGI other SNP,

    -   [x] RGI cut-off,

    -   [x] RGI best identities,

    -   [x] RGI AMR gene family,

    -   [x] RGI Model type,

    -   [x] RGI Drug class,

    -   [x] RGI ORF ID,

    -   [x] RGI Percentage Length of Reference Sequence,

    -   [x] a lot of repeat pairs; each repeat pair has:

        -   [x] 1 AR length,
        -   \[-\] 1 AR black box matrix,
        -   [x] 1 repeat length,
        -   [x] 1 center spanning label,
        -   [ ] 'inside the gene' label,

# Making a table with features

Start from a table with repeat.

```{r, eval=FALSE}
load("/home/andrei/Data/HeteroR/notebooks/features.RData")
```

## Read table with repeats: way no. 1

This one will a basic features table for the rest of the analysis.

To build this table anew run the code chunk below (its evaluation is OFF by default)

How many strains with annotated repeats we have?

```{r}
# a new way of getting repeat data frame across all strains
strains <- dir("/home/andrei/Data/HeteroR/results/direct_repeats")
length(strains)
```

### Read repeats tables

Some tables are empty!

```{r, message=FALSE}
repeat_df <- map_dfr(strains, function(x){
  path <- paste0("/home/andrei/Data/HeteroR/results/annotations/", x, "/repeats/", x, "_repeats.csv")
  df <- read_csv(path, col_types = "ccdddddc")
  return(df)
  }) %>% 
  mutate(AR_length = start_2 - end_1 + 1) %>% 
  select(-...1)
  
head(repeat_df)
```

Dimensions:

```{r}
dim(repeat_df)
```


In this table there are 

```{r}
length(unique(repeat_df$strain))
```

strains

More than 100 strains don't have repeats?

```{r}
setdiff(strains, unique(repeat_df$strain))
```

I checked some of these strain, their `repeats.csv` tables are empty

I checked `grf_perfect.log` files - this file is empty in DA62900, but have info on repeats in DA62906.

Then I checked `results/direct_repeats/DA62*/repeats_no_mismatch` directories. In DA62900 all files are empty, in DA62906 only `perfect.id` is empty, `imperfect.id` has some data inside.

I think, this is the explanation.

Conclusion: the strains above do not have (perfect) repeats longer than 20 bp indeed.

I should add them to the `repeat_df` with NAs in every column except `strain` (`skip_empty_rows=FALSE` in `read_csv` doesn't fix the problem)

```{r}
strains_no_repeats <- setdiff(strains, unique(repeat_df$strain))

no_repeats_df <- tibble(record_id = rep(NA, length(strains_no_repeats)),
                        start_1 = rep(NA, length(strains_no_repeats)),
                        end_1 = rep(NA, length(strains_no_repeats)),
                        start_2 = rep(NA, length(strains_no_repeats)),
                        end_2 = rep(NA, length(strains_no_repeats)),
                        length = rep(NA, length(strains_no_repeats)),
                        strain = strains_no_repeats,
                        AR_length = rep(NA, length(strains_no_repeats)))

head(no_repeats_df)
```


```{r}
repeat_df <- bind_rows(repeat_df, no_repeats_df)

length(unique(repeat_df$strain))
```


### Read BED files to determine center spanning repeat pairs

```{r, message=FALSE}
bed_df <- map_dfr(strains, function(x){
    path <- paste0("/home/andrei/Data/HeteroR/results/direct_repeats/", x, "/regions/regions_within.bed")
    df <- read_delim(path, col_names = FALSE) %>% mutate(strain = x)
    return(df)
  }) %>% 
  mutate(gene_center = round((X3 - X2 + 1)/2)) %>% 
  rename("record_id" = X4) %>% 
  select(strain, record_id, gene_center)

head(bed_df)
```

We have bed files for 

```{r}
length(unique(bed_df$strain))
```

strains.

### Join bed files and repeats table to one features table.

`bed_df` contains more strains and genes than `repeat_df`, but if there is no repeats AR length and gene center - `repeat_df` is important, that's why I use `left_join()` below.

```{r}
# join the two tables
features <- left_join(repeat_df, bed_df, by = "record_id") %>% 
  mutate(spans_center = if_else(end_1 <= gene_center & start_2 >= gene_center, "yes", "no"),
         record_id = sub("_gene", "", record_id)) %>% 
  rename("repeat_length" = length) %>% 
  select(-strain.y) %>% 
  rename("strain" = strain.x) %>% 
  relocate(strain, .before = record_id) %>% 
  select(strain, record_id, repeat_length, AR_length, spans_center)

# look at this!
head(features)
```

## Read repeat table: way no. 2

Read it from the file *repeat_summary.csv* that was made during the pipeline run.

It contains strains, gene names, repeat coordinates, repeat lengths, AR lengths and 'spans center' label.

Each gene name (aka record_id) is unique.

```{r, eval=FALSE}
features <- read_csv("/home/andrei/Data/HeteroR/results/tables/repeats_summary.csv") %>% 
  relocate(strain, .before=record_id) %>% 
  mutate(record_id = sub("_gene", "", record_id)) %>% 
  rename("repeat_length" = length) %>% 
  select(strain, record_id, repeat_length, AR_length, spans_center)

# look at this!
head(features)
```

In this table we have `r length(unique(features$record_id))` resistance genes with detected repeats from `r length(unique(features$strain))` strains.

Number of repeat pairs detected `r nrow(features)`.

## RGI annotations

They are required for filtering of resistance genes and much more...

### Read ouput tables

'Loose' hits must be removed!

```{r, message=FALSE}
# in RGI tables I don't need the last two columns (Nudged and Note) 
# because they cause problems during table reading

rgi <- map_dfr(strains, function(x){
        read_delim(file = paste0("/home/andrei/Data/HeteroR/results/resistance_genes/", x, "/rgi_table.txt"), na = c("n/a", ""), 
                   name_repair = "universal",
                   col_select = -c(Predicted_Protein, CARD_Protein_Sequence, Contig, Start, Stop, Orientation, Predicted_DNA, Note, Nudged),
                   show_col_types = FALSE) %>% 
          mutate(strain = x)}) %>% 
  filter(Cut_Off != "Loose") %>% 
  mutate(record_id = map_chr(ORF_ID, function(x) strsplit(x, " ")[[1]][1])) %>% 
  relocate(strain, record_id, .before=ORF_ID)

ab_groups <- unique(rgi$Drug.Class)

head(rgi)
```

In this table `r length(unique(rgi$ORF_ID))` resistance genes have been detected in `r length(unique(rgi$strain))` strains

### How many RG don't have repeats?

It's the difference between record IDs from RGI and record IDs from Features (or repeat_df).

RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

That many RGs don't have repeats around them.

Since all record IDs in both tables are unique, difference between record IDs of both tables should equal the same number: `r length(unique(rgi$record_id)) - length(unique(features$record_id))`

### Filtering RGI results

**OBS!** Minimum number of RGs found should be much lower than **60** per strain

Criteria:

1.  Identity percent

2.  Percentage length of reference sequence

3.  efflux pumps should go; target alteration should go; permeability should go; inactivation and modification should stay

4.  genes with SNPs should go

#### Number of RGs per strain: before filtering

```{r, warning=FALSE}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n)) +
    geom_histogram(fill = "steelblue")
```

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  summary()
```

These numbers should be lower!

#### Identity percent

For *Strict* hits you may consider *Identity_percent* as another filtering criterion, hits with too low identities should be discarded.

##### Distribution of Identity percentages before filtering

```{r, message=F}
rgi %>% 
  select(Cut_Off, Best_Identities) %>% 
  ggplot(aes(Best_Identities)) +
    geom_histogram(bins = 100, aes(fill = Cut_Off), alpha = 0.8) +
    ggtitle("Distribution of identity percentages")
```

##### Leave only 90% and higher

```{r}
rgi <- rgi %>% 
  filter(Best_Identities >= 90)

summary(rgi$Best_Identities)
```

### Percentage length of reference sequence

Before filtering (except for Best_Identities) it looks like this

```{r}
rgi %>% 
  select(Cut_Off, Percentage.Length.of.Reference.Sequence) %>% 
  ggplot(aes(Percentage.Length.of.Reference.Sequence)) +
    geom_histogram(bins = 100, aes(fill = Cut_Off), alpha = 0.8) +
    geom_rug(aes(color = Cut_Off))+
    ggtitle("Distribution of percenatge length of reference sequence")
```

```{r}
summary(rgi$Percentage.Length.of.Reference.Sequence)
```

How short is too short? 90%

Filtering:

```{r}
rgi <- rgi %>% 
  filter(Percentage.Length.of.Reference.Sequence >= 90)

summary(rgi$Percentage.Length.of.Reference.Sequence)
```

### Number of RGs per strain : after the 1st filtering

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n)) + 
    geom_histogram(fill = "steelblue")
```

More filtering required!

### Filtering by Resistance.Mechanism

How many resistance mechanisms do we have?

```{r}
unique(rgi$Resistance.Mechanism)
```

What have we decided to filter out?

-   efflux

-   target alteration

-   permeability

What should stay:

-   inactivation

-   modification

-   target replacement?

-   target protection?

**OBS!** Leave those records that *contain* what should stay

```{r}
stay <- c("antibiotic target replacement", "antibiotic target protection", "antibiotic inactivation")

rgi <- rgi %>% 
  filter(Resistance.Mechanism %in% stay)

dim(rgi)
```

This is the dimensions of the rgi table after filtering.

### Filtering SNPs

How many SNPs do we have now?

```{r}
rgi %>% 
  filter(!is.na(SNPs_in_Best_Hit_ARO))
```

No SNPs in the filtered RGI table.

### Number of RGs per strain: after the 2nd filtering

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>% 
  ggplot(aes(n))+ 
    geom_histogram(fill = "steelblue")+
    xlab("Number of RGs per strain")
```

Summary

```{r}
rgi %>% 
  group_by(strain) %>% 
  count() %>%
  summary()
```

It's OK!

In total, I have `r length(unique(rgi$record_id))` RGs in the filtered RGI

### How many genes from filtered RGI don't have repeats?

Same approach as above: it's the difference between filtered RGI's genes IDs and gene IDs from features (=repeat_df)

Filtered RGI - Features:

```{r}
length(setdiff(rgi$record_id, features$record_id))
```

`r length(setdiff(rgi_filt$record_id, features$record_id))` resistance genes after filtering don't have repeats around them.

### Any NAs in features?

```{r}
features %>% 
  map(is.na) %>% 
  map_int(sum)
```

What is this?

```{r}
features %>% filter(is.na(spans_center))
```

???

### Any NAs in filtered RGI?

```{r}
rgi %>% 
  map(is.na) %>% 
  map_int(sum)
```

### Add filtered RGI annotations to Features

Use gene names as key since they are unique and make a full join with features.

**OBS!** N genes in RGI don't have repeats =\> N rows in Features won't have repeat_length (N = Filtered RGI - Features)

```{r}
features <- full_join(features, rgi, by = c("strain", "record_id"))

features %>% filter(is.na(repeat_length)) %>% select(strain, record_id, ORF_ID, repeat_length)
```

Number of rows here should be equal to filtered RGI - Features (see above)

Number of rows in Features: `r nrow(features)`

### Remove RGI columns that we don't need for prediction

Like ARO, Cut_Off etc.

```{r}
features <- features %>% 
  select(-c(ARO, Cut_Off, Pass_Bitscore, Best_Hit_Bitscore, Best_Hit_ARO, 
            Best_Identities, Model_ID, Model_type, SNPs_in_Best_Hit_ARO,
            Other_SNPs, ID, Percentage.Length.of.Reference.Sequence))

head(features)
```

**OBS!** Features still contain resistance genes without repeats and strains without repeats at all!

### Remove rows with excluded genes

Since many genes were excluded from RGI results but their repeats, counts and AR lengths stay in Features, let's remove them

#### Remove rows in Features without Resistance.Mechanism

How many rows don't have resistance mechanisms (i.e. have been filtered out during RGI filtering?): `r sum(is.na(features$Resistance.Mechanism))`

Filtering

```{r}
features <- features %>% 
  filter(!is.na(Resistance.Mechanism))

dim(features)
```

This is the dimensions of new `features`

How many strains in features?

```{r}
length(unique(features$strain))
```

One strain has been removed because it doesn't have any RGs or repeats

I should add it back and assign NAs everywhere

```{r}
strains_no_rg <- setdiff(strains, features$strain)

na_col <- function(){
  rep(NA, length(strains_no_rg))
}

l.rg <- length(strains_no_rg)

no_rg_df <- tibble(strain = strains_no_rg, 
                   record_id = na_col(),
                   repeat_length = na_col(),
                   AR_length = na_col(),
                   spans_center = na_col(),
                   ORF_ID = na_col(),
                   Drug.Class = na_col(),
                   Resistance.Mechanism = na_col(),
                   AMR.Gene.Family = na_col())

no_rg_df
```

```{r}
features <- bind_rows(features, no_rg_df)
```


# Per-strain dataset

Here will be 'per strain' features kept, that will be used for predictions

## Coverage and max read length

I've decided to add Nanopore's `coverage` and `max_len` to features. This data comes from coverage statistics.

Check on the pairs plot from assemblies summary and coverage analysis to find out why.

```{bash, eval=FALSE}
# from ~/Data/HeteroR
workflow/scripts/coverage_cli.py resources/strain_lists/strains525.txt 5131220 results/coverage/strains525.tsv filtered
```

Read the coverage table

```{r, message=FALSE}
coverage <- read_delim("/home/andrei/Data/HeteroR/results/coverage/strains525.tsv", na = c("", "NaN")) %>% 
  mutate(strain = str_extract(file, "DA[0-9]*")) %>% 
  select(strain, coverage, max_len)

head(coverage)
```

## Completeness and N50

`completeness` and `N50` come from assemblies summary files

```{r, message=FALSE}
summaries <- dir(path = "/home/andrei/Data/HeteroR/results/assemblies_joined",  pattern = "summary.tsv", recursive=TRUE)

assemblies <- map_dfr(summaries, function(x){
  read_delim(paste0("/home/andrei/Data/HeteroR/results/assemblies_joined/", x), col_types = "cccccccccccc")
  }) %>% mutate(Links = as.integer(gsub(",", "", Links, fixed = TRUE)),
                Length = as.integer(gsub(",", "", Length, fixed = TRUE)),
                N50 = as.integer(gsub(",", "", N50, fixed = TRUE)),
                Longest_component = as.integer(gsub(",", "", Longest_component, fixed = TRUE)),
                Status2 = case_when(Status == "incomplete" ~ "linear",
                             Status == "complete" | Status == "Y" ~ "circular",
                             Status == "scaffold" ~ "add.plasmid"))

head(assemblies)
```

Join these two tables to make per strain features

```{r}
features_strain <- assemblies %>% 
  filter(Type == "Chromosome") %>% 
  select(Strain, Status2, N50) %>% 
  rename("strain" = Strain, "chrom.status" = Status2) %>% 
  left_join(coverage, by = "strain") %>% 
  rename("read.max.len" = max_len)
  
head(features_strain)
```

How many strains here?

```{r}
length(unique(features_strain$strain))
```

OK

## Number of plasmids

**OBS** It's a per strain feature!

Info on plasmids is in tables `summary.tsv` in `results/assemblies_joined` and it has been collected in `genome_assembly_summary.Rmd`

### Plasmid counts from assemblies summary files

```{r}
plasmid_counts <- assemblies %>% 
  filter(Type == "Plasmid") %>% 
  group_by(Strain) %>% 
  count() %>% 
  rename("strain" = Strain, "n.plasmids" = n)

features_strain <- left_join(features_strain, plasmid_counts, by = "strain")
```

All NAs in `features` from now on should be 0s in the end.

### Plasmid counts from fasta headers + their relative coverage

We should take into account relative coverage of plasmids (i.e. number of copies), which can be found in an assembly header, but not every plasmid has this measure, since it is calculated only by Unicycler but not SPAdes or FMP.

```{r, eval=FALSE}
# use fread from data.table
assemblies_path <- "/home/andrei/Data/HeteroR/results/assemblies_joined/"
assembly_files <- dir(path=assemblies_path, pattern="assembly.fasta$", recursive=T)

headers <- lapply(assembly_files, function(x){
  df <- data.table::fread(cmd=paste0("grep '>' ", assemblies_path, x), fill=TRUE, header = F, sep = " ", drop = 1, na.strings = "")
  df$strain <- strsplit(x, "/")[[1]][1]
  return(df)
})

headers <- bind_rows(headers)

headers$depth.rounded <- sapply(headers$V3, function(y){round(as.numeric(substr(y, 7, 10)))})
headers$length <- sapply(headers$V2, function(y){round(as.numeric(strsplit(y, "=")[[1]][2]))})
headers$circular <- sapply(headers$V4, function(y){strsplit(y, "=")[[1]][2]})

# headers_df <- fread(cmd='grep ">" /home/andrei/Data/HeteroR/results/assemblies_joined/DA68966/assembly.fasta', fill=TRUE)

# sapply(headers_df$V3, function(x){round(as.numeric(substr(x, 7, 10)))})
# sapply(headers_df$V2, function(x){round(as.numeric(strsplit(x, "=")[[1]][2]))})

headers <- headers %>% select(-c(V2, V3, V4))
```

From this table I can calculate number of plasmids as sum of depths

Let's look at the lengths distribution because length is the key to "smart" filtering of plasmids

```{r, fig.width=12, fig.height=4, eval=FALSE}
library(patchwork)

h1 <- headers %>% 
  ggplot(aes(length)) + 
    geom_histogram(fill = "steelblue", bins = 200)+
    geom_rug() + 
    ggtitle("assembly segments lengths")

h2 <- headers %>% 
  filter(length >= 1000) %>% 
  ggplot(aes(length)) + 
    geom_histogram(fill = "steelblue", bins = 200)+
    geom_rug() + 
    ggtitle("assembly segments lengths, min length = 1000")

h1 / h2
```

Let's remove all segments shorter than 1000 bp

```{r, eval=FALSE}
headers <- headers %>% 
  filter(length >= 1000)
```

Distribution of longest segments in each strain

```{r, eval=FALSE}
headers %>% 
  group_by(strain) %>% 
  summarise(max.length = max(length)) %>% 
  ggplot(aes(max.length))+
    geom_histogram(fill = "steelblue")+
    ggtitle("Longest segments in each strain")
```

So...

How to distinguish between segmented chromosomes and real plasmids?

I can try to count a segment as "plasmid" if this segment goes after other segments that sum up to 4.5 Mpb

Pseudo code looks like this:

For each strain:

set N=0

for each segment: if N \> 4.5 Mbp N =+ segment length mark segment as chromosome

if unmarked segments left: mark them as plasmids

Let's try

```{r, eval=FALSE}
df.tmp <- headers %>% filter(strain == "DA62886")
sum.len <- 0
marks <- c()
for (L in df.tmp$length){
  if (sum.len < 4500000){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
  } else {
    marks <- c(marks, "plasmid")
  }
}

df.tmp$type <- marks

df.tmp
```

Apply it to full headers table

```{r, eval=FALSE}
# Naive algorithm will look like this

get.labels <- function(lengths.vec, max.sum.len){
  sum.len <- 0
  marks <- c()
  
  for (L in lengths.vec){
    if (sum.len < max.sum.len){
    sum.len <- sum.len + L
    marks <- c(marks, "chromosome")
    } else {
    marks <- c(marks, "plasmid")
    }
  }
  
  return(marks)
}

# apply this function to each strain's subset of the headers table
labels.total <- c()
for (S in unique(headers$strain)){
  sub.df <- filter(headers, strain==S)
  labels.sub.df <- get.labels(sub.df$length, 4500000)
  labels.total <- c(labels.total, labels.sub.df)
}

headers$label <- labels.total

headers
```

Now, I can calculate "real" plasmid count per strain and add it to the features table

```{r, eval=FALSE}
plasmid_counts_alt <- headers %>% 
  filter(label=="plasmid") %>% 
  group_by(strain) %>% 
  summarise(n.plasmids_alt=sum(depth.rounded))

plasmid_counts_alt
```

Add this data set to filtered features

```{r, eval=FALSE}
features_filtered <- left_join(features_filtered, plasmid_counts_alt, by="strain")
```

## Number of beta-lactamases

We need a column with number of beta-lactamase genes per strain (instead of absence/presence)

Those genes or strains that don't have b-l genes should have zeros in repeat counts, length etc.

Here I will need this big `features` table!

```{r}
n.beta.lac <- features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  group_by(strain) %>% 
  summarise(n.beta.lac = sum(is.beta.lac))

features_strain <- left_join(features_strain, n.beta.lac, by = "strain")
```

## Location on plasmid, distance to oriC and plus strand

1)  `features` contains gene names, so I can find if it's located on a plasmid.

**OBS!** This feature should be "averaged" by strain!

t.ex.: number of genes located on plasmids (can be 0, 1, 2, 3, 4...)

"Location on plasmid" can be used later to separate all features into two groups: on plasmid and not (repeat counts, distance to oriC etc.)

2)  `features` contains gene names, I can find this in annotation files (gff, gbk etc) and assembly summary tables (completeness)

**OBS!** This feature should be "averaged" by strain!

t.ex.: *closest distance to oriC* or *median/mean distance to oriC*

If I assume that *oriC* is available only in circularized genomes then I might get NAs in some strains

3)  information on strandedness (gene orientation) is also in the gff files


```{python}
#| eval: FALSE

# This chunk is only for DA62886 gff file that was copied from Argos and
# therefore has different record_id's than any other DA62886-related file

from BCBio import GFF
from Bio import SeqIO

in_file = "/home/andrei/Data/HeteroR/results/annotations/DA62886/prokka/DA62886_genomic.gbk"
out_file = "/home/andrei/Data/HeteroR/results/annotations/DA62886/prokka/DA62886_genomic.gff"
in_handle = open(in_file)
out_handle = open(out_file, "w")

GFF.write(SeqIO.parse(in_handle, "genbank"), out_handle)

in_handle.close()
out_handle.close()

```


Here I read gff files using a custom function based on standard `read.delim()`

It's the only working way to read gff files in R

`genbankr::read.GenBank()` didn't work

`ape::read.gff()` and `ape::read.GenBank()` didn't work

`read_delim()` didn't work

`biomartr` couldn't be installed

```{r}
# a function to read GFF files using STANDARD read.delim
read_gff <- function(gff_filename) {
  # read and process
  df <- as_tibble(read.delim(gff_filename, header = F, comment.char = "#")) %>%
  select(V1, V3, V4, V5, V7, V9) %>% 
  filter(V3 == "gene")
  return(df)
  }

# get gff full paths using strain names vector
gff_files <- map_chr(strains, ~ str_c("/home/andrei/Data/HeteroR/results/annotations/", ., "/prokka/", ., "_genomic.gff"))

# read gff files right in a tibble
# it works quite long time
gff <- map_dfr(gff_files, ~ read_gff(.)) %>% 
  separate(col=V9, sep = ";locus_tag=", into=c("V10", "V11")) %>%
  select(-V10) %>% 
  set_names(c("seq.region", "type", "start", "stop", "strand", "record_id")) %>% 
  filter(record_id %in% unique(features$record_id)) %>% 
  mutate(located.on.plasmid = str_detect(seq.region, "1", negate = T),
         on.plasmid = if_else(located.on.plasmid, "yes", "no"),
         pos.strand = if_else(strand == "+", "yes", "no")) %>% 
  rename("dist.to.oriC" = start) %>% 
  select(record_id, dist.to.oriC, pos.strand, on.plasmid)

```

## Remove non-beta-lactamase AMR genes from GFF

```{r}
# add is beta lac
gff <- features %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  select(record_id, is.beta.lac) %>% 
  distinct() %>% 
  right_join(gff, by = "record_id") %>% 
  filter(is.beta.lac) %>% 
  select(-is.beta.lac)

gff
```

## Add 'on.plasmid', 'strand' and 'dit.to.oriC' to `features_filtered`

```{r}
features <- features %>% 
  mutate(is.beta.lac = grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  left_join(gff, by = "record_id")

head(features)
```

## Add 'strain' and 'record_id' to `gff` (GFF with BL genes)

```{r}
gff <- features %>% 
  select(strain, record_id) %>% 
  distinct() %>% 
  right_join(gff, by = "record_id")
```

### Summarize some BL-related features per strain

(from GFF)

-   minimum distance to oriC

-   average (median) distance to oriC

-   number of genes on a positive strand

-   number of genes on plasmids

All in three variants: on chromosome, on plasmids, both

```{r}
min_dist_oriC <- gff %>% 
  group_by(strain, on.plasmid) %>% 
  summarise(min.dist.oriC = min(dist.to.oriC)) %>% 
  spread(key = "on.plasmid", value = "min.dist.oriC", fill = 0) %>% # FILL SHOULD BE NA BUT YOU CAN NOT ADD NA TO NUMBER
  rename("min.dist.oriC.chrom" = no, "min.dist.oriC.plasmid" = yes) %>% 
  mutate(min.dist.oriC = min.dist.oriC.chrom + min.dist.oriC.plasmid)

med_dist_oriC <- gff %>% 
group_by(strain, on.plasmid) %>% 
  summarise(med.dist.oriC = median(dist.to.oriC)) %>% 
  spread(key = "on.plasmid", value = "med.dist.oriC", fill = 0) %>% # FILL SHOULD BE NA BUT YOU CAN NOT ADD NA TO NUMBER
  rename("med.dist.oriC.chrom" = no, "med.dist.oriC.plasmid" = yes) %>% 
  mutate(med.dist.oriC = med.dist.oriC.chrom + med.dist.oriC.plasmid)

n_genes_plus_strand <- gff %>% 
  group_by(strain, on.plasmid) %>% 
  summarise(n.beta.lac.plus = sum(pos.strand == "yes")) %>% 
  spread(key = "on.plasmid", value = "n.beta.lac.plus", fill = 0) %>% 
  rename("n.beta.lac.plus.chrom" = no, "n.beta.lac.plus.plasmid" = yes) %>% 
  mutate(n.beta.lac.plus = n.beta.lac.plus.chrom + n.beta.lac.plus.plasmid)

# genes on plasmids are always on plasmids
n_genes_plasmids <- gff %>% 
  group_by(strain) %>% 
  summarise(n.beta.lac.plasmid = sum(on.plasmid == "yes"))

features_strain <- list(features_strain, min_dist_oriC, med_dist_oriC, n_genes_plus_strand, n_genes_plasmids) %>% 
  reduce(left_join, by = "strain") %>% 
  mutate(n.beta.lac.chrom = n.beta.lac - n.beta.lac.plasmid) %>% 
  relocate(n.beta.lac.plasmid, n.beta.lac.chrom, .before = min.dist.oriC.chrom)

head(features_strain)
```

## Repeat count

**OBS!** Repeat in the current context is *a pair of identical regions of a certain length*.

### Add total repeat count

Repeats from around **non-beta-lactamase** genes should not be counted!

Also, repeat counts should be calculated separately for plasmid and chromosomal genes

```{r}
# in features_filtered every row is a repeat, to find number of repeats per strain,
# count number of rows per strains and on.plasmid
# exclude non-beta-lac genes
# according to the current repeat definition distinct() should not be used
repeat_counts <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>%
  summarise("n.rep" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep", fill = 0) %>% 
  rename("n.rep.chrom" = no, "n.rep.plasmid" = yes) %>% 
  mutate(n.rep.total = n.rep.chrom + n.rep.plasmid) %>% 
  select(strain, n.rep.chrom, n.rep.plasmid, n.rep.total)


# count number of repeats spanning center
rep_counts_center <- features %>% 
  filter(is.beta.lac, spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>%
  summarise("n.rep.cen" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.cen", fill = 0) %>% 
  rename("n.rep.cen.chrom" = no, "n.rep.cen.plasmid" = yes) %>% 
  mutate(n.rep.tot.cen = n.rep.cen.chrom + n.rep.cen.plasmid) %>% 
  select(strain, n.rep.tot.cen, n.rep.cen.chrom, n.rep.cen.plasmid)

# repeats per gene = number of rows per record_id
# exclude non-beta-lac genes
repeat_counts_gene <- features %>%
  filter(is.beta.lac) %>% 
  group_by(record_id, on.plasmid) %>%
  summarise("n.repeats.gene" = n())

# join only those counts that are in features_filtered
features <- left_join(features, repeat_counts_gene, by = c("record_id", "on.plasmid") )%>% 
  relocate(n.repeats.gene, .before="ORF_ID")

# add the rest
features_strain <- list(features_strain, repeat_counts, rep_counts_center) %>% 
  reduce(left_join, by = "strain")

```

### Add repeat count, min length 100 bp

```{r}
# n reads longer than 100
repeat_counts_strain_100 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 100) %>%
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.100" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.100", fill = 0) %>% 
  rename("strain" = strain, "n.rep.100.chrom" = no, "n.rep.100.plasmid" = yes) %>% 
  mutate(n.rep.100.total = n.rep.100.chrom + n.rep.100.plasmid) %>% 
  select(strain, n.rep.100.chrom, n.rep.100.plasmid, n.rep.100.total)


# n repeats longer than 100 and spanning center
repeat_counts_strain_100_center <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes", 
         repeat_length >= 100) %>%
  group_by(strain, on.plasmid) %>% 
  summarise("n.rep.100.cen" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.100.cen", fill = 0) %>% 
  rename("strain" = strain, "n.rep.100.cen.chrom" = no, "n.rep.100.cen.plasmid" = yes) %>% 
  mutate(n.rep.100.cen.tot = n.rep.100.cen.chrom + n.rep.100.cen.plasmid) %>% 
  select(strain, n.rep.100.cen.chrom, n.rep.100.cen.plasmid, n.rep.100.cen.tot)

# join both with features_strain
features_strain <- list(features_strain, repeat_counts_strain_100, repeat_counts_strain_100_center) %>% 
  reduce(left_join, by = "strain")

#############################
## PER GENE
#############################

repeat_counts_gene_100 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 100) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min100" = n())

# join 
features <- left_join(features, repeat_counts_gene_100, by="record_id")

# not all beta-lac genes/strains have repeats longer than 100
# they are NA
# turn these NAs to 0s
features$n_repeats_gene_min100 <- ifelse(is.na(features$n_repeats_gene_min100), 0, features$n_repeats_gene_min100)

# locate
features <- features %>% relocate(n_repeats_gene_min100, .before="ORF_ID")

##################################
## SHOW FEATURES STRAIN
##################################

head(features_strain)
```

### Add repeat count, min length 500 bp

I leave only per gene statistic

```{r}

#############################
## PER GENE
#############################

repeat_counts_gene_500 <- features %>% 
  filter(is.beta.lac, 
         repeat_length >= 500) %>% 
  group_by(record_id) %>% 
  summarise("n_repeats_gene_min500" = n())

# join 
features <- left_join(features, repeat_counts_gene_500, by = "record_id")

# not all beta-lac genes/strains have repeats longer than 500
# they are NA
# turn these NAs to 0s
features$n_repeats_gene_min500 <- ifelse(is.na(features$n_repeats_gene_min500), 0, features$n_repeats_gene_min500)

# locate
features <- features %>% relocate(n_repeats_gene_min500, .before="ORF_ID")

##################
## SHOW FEATURES 
##################

head(features)
```

## Repeat length

### Median sum of repeat length

I sum up repeat lengths in each gene and divide it by number of genes -\> strain characteristic

Sum of repeat length is sum of all repeats on *one side* of a gene from center-spanning repeat pairs

```{r}
# calculate summarized repeat sum
rep_len_sum_strain_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, record_id, on.plasmid) %>%
  summarise(total_repeat_length = sum(repeat_length)) %>% 
  group_by(strain, on.plasmid) %>% 
  summarise(med.tot.rep.len = median(total_repeat_length)) %>% 
  spread(key = "on.plasmid", value = "med.tot.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.tot.rep.len.chrom" = no, 
         "med.tot.rep.len.plasmid" = yes) %>% 
  select(strain, med.tot.rep.len.chrom, med.tot.rep.len.plasmid)

rep_len_sum_strain <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, record_id) %>%
  summarise(total_repeat_length = sum(repeat_length)) %>% 
  group_by(strain) %>% 
  summarise(med.tot.rep.len = median(total_repeat_length))

# join both with features_bl_strain
features_strain <- list(features_strain, rep_len_sum_strain_split, rep_len_sum_strain) %>% 
  reduce(left_join, by = "strain")

# per gene
rep_len_sum <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(record_id) %>%
  summarise(total_repeat_length = sum(repeat_length))

features <- left_join(features, rep_len_sum, by = "record_id") %>%
  relocate(total_repeat_length, .before = "AR_length")

head(features_strain)
```

### Repeat density

Under construction.

This metric reflects maximum number of repeats per sliding window.

### Median repeat length

Only repeats found around beta-lactamase genes should be taken into account.

According to the current definition of *repeat*, `distinct()` should not be used.

```{r}
# I have removed distinct() and added filter(spans_center=="yes")
# it significantly changes everything
med_rep_len_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.rep.len = median(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.rep.len.chrom" = no, 
         "med.rep.len.plasmid" = yes) %>% 
  select(strain, med.rep.len.chrom, med.rep.len.plasmid)

med_rep_len <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len = median(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, med_rep_len_split, med_rep_len) %>% 
  reduce(left_join, by="strain")


head(features_strain)
```

### Maximum repeat length

```{r}
max_rep_len_all_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "max.rep.len", fill = 0) %>% 
  rename("strain" = strain, 
         "max.rep.len.chrom" = no, 
         "max.rep.len.plasmid" = yes) %>% 
  select(strain, max.rep.len.chrom, max.rep.len.plasmid)

max_rep_len_all <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, max_rep_len_all_split, max_rep_len_all) %>% 
  reduce(left_join, by = "strain")

# center spanning
max_rep_len_cen_split <- features %>%
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(max.rep.len = max(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "max.rep.len", fill = 0) %>% 
  rename("strain" = strain,
         "max.rep.len.cen.chrom" = no, 
         "max.rep.len.cen.plasmid" = yes) %>% 
  select(strain, max.rep.len.cen.chrom, max.rep.len.cen.plasmid)

max_rep_len_cen <- features %>%
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(max.rep.len.cen = max(repeat_length, na.rm = T))

# add both
features_strain <- list(features_strain, max_rep_len_cen_split, max_rep_len_cen) %>% 
  reduce(left_join, by="strain")

head(features_strain)
```

## Amplifiable region length

### Median AR length

#### All repeat on chromosomes, plamids and both

```{r}
med_ar_len_split <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len", fill = 0) %>% 
  rename("strain" = strain, 
         "med.AR.len.chrom" = no, 
         "med.AR.len.plasmid" = yes) %>% 
  select(strain, med.AR.len.chrom, med.AR.len.plasmid)


med_ar_len <- features %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len = median(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, med_ar_len_split, med_ar_len) %>% 
  reduce(left_join, by = "strain")

head(features_strain)
```

#### Repeat pairs spanning center

```{r}
med_ar_len_cen_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len.cen = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len.cen", fill = 0) %>% 
  rename("strain" = strain, 
         "med.AR.len.cen.chrom" = no, 
         "med.AR.len.cen.plasmid" = yes) %>% 
  select(strain, med.AR.len.cen.chrom, med.AR.len.cen.plasmid)


med_ar_len_cen <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.cen = median(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, med_ar_len_cen_split, med_ar_len_cen) %>% 
  reduce(left_join, by = "strain")


head(features_strain)
```

### Minimum AR length

#### Only pairs spanning center

Because it doesn't have much sense otherwise

```{r}
min_ar_len_cen_split <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(min.AR.len.cen = min(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "min.AR.len.cen", fill = 0) %>% 
  rename("strain" = strain, 
         "min.AR.len.cen.chrom" = no, 
         "min.AR.len.cen.plasmid" = yes) %>% 
  select(strain, min.AR.len.cen.chrom, min.AR.len.cen.plasmid)

min_ar_len_cen <- features %>% 
  filter(is.beta.lac, 
         spans_center == "yes") %>% 
  group_by(strain) %>% 
  summarize(min.AR.len.cen = min(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, min_ar_len_cen_split, min_ar_len_cen) %>% 
  reduce(left_join, by = "strain")

head(features_strain)
```

## Repeats around ampC-type beta-lactamases only

All the features above were calculated for **all beta-lactamase genes**. But some of them belong specifically to **ampC-type**.

Each strain has at least one *ampC* gene. Let's add the same variables but calculated only on *ampC-type* beta-lactamases.

```{r}
features %>% 
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct() %>% 
  group_by(strain, record_id) %>% 
  summarise(n.ampC = sum(str_detect(AMR.Gene.Family, "ampC"))) %>% 
  group_by(strain) %>% 
  summarize(n.ampC = sum(n.ampC)) %>% 
  filter(n.ampC == 0)
```

In real life, every E.coli has at least I ampC gene on chromosome - the table above should be empty.

### Filter features with ampC genes only

```{r}
# there are 21 types of AMR gene families, only one type's name contain ampC
features_ampC <- features %>% 
  filter(str_detect(AMR.Gene.Family, "ampC"))
```

### Repeat counts

On chromosome, on plasmid, both

```{r}
repeat_counts_ampC <- features_ampC %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>%
  summarise("n.rep.ampC" = n()) %>% 
  spread(key = "on.plasmid", value = "n.rep.ampC", fill = 0) %>% 
  rename("strain" = strain, 
         "n.rep.chrom.ampC" = no, "n.rep.plasmid.ampC" = yes) %>%
  select(strain, n.rep.chrom.ampC, n.rep.plasmid.ampC) %>% 
  mutate(n.rep.total.ampC = n.rep.chrom.ampC + n.rep.plasmid.ampC)


features_strain <- left_join(features_strain, repeat_counts_ampC, by = "strain")

head(features_strain)
```

### AR length

On chromosome, on plasmid, both

```{r}
med_ar_len_split_ampC <- features_ampC %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.AR.len.ampC = median(AR_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.AR.len.ampC", fill = 0) %>% 
  rename("strain" = strain, 
         "med.AR.len.chrom.ampC" = no, 
         "med.AR.len.plasmid.ampC" = yes) %>% 
  select(strain, med.AR.len.chrom.ampC, med.AR.len.plasmid.ampC)

med_ar_len_ampC <- features_ampC %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.AR.len.ampC = median(AR_length, na.rm = T))

# add
features_strain <- list(features_strain, med_ar_len_split_ampC, med_ar_len_ampC) %>% 
  reduce(left_join, by = "strain")

head(features_strain)
```

### Repeat length

On chromosome, on plasmid, both

```{r}
med_rep_len_split_ampC <- features_ampC %>% 
  filter(is.beta.lac) %>% 
  group_by(strain, on.plasmid) %>% 
  summarize(med.rep.len.ampC = median(repeat_length, na.rm = T)) %>% 
  spread(key = "on.plasmid", value = "med.rep.len.ampC", fill = 0) %>% 
  rename("strain" = strain, 
         "med.rep.len.chrom.ampC" = no,
         "med.rep.len.plasmid.ampC" = yes) %>% 
  select(strain, med.rep.len.chrom.ampC, med.rep.len.plasmid.ampC)

med_rep_len_ampC <- features_ampC %>% 
  filter(is.beta.lac) %>% 
  group_by(strain) %>% 
  summarize(med.rep.len.ampC = median(repeat_length, na.rm = T))


# add both
features_strain <- list(features_strain, med_rep_len_split_ampC, med_rep_len_ampC) %>% 
  reduce(left_join, by = "strain")


head(features_strain)
```

## AMR genes counts per strain for the heatmap

**OBS** Not every gene here is a beta-lactamase!

```{r}
# get unique AMR types
amr_types <- unique(features$AMR.Gene.Family)

# get unique gene rows with AMR.Gene.Family
amr_gene_types <- features %>%
  select(strain, record_id, AMR.Gene.Family) %>% 
  distinct()

# make a DF of each AMR type counts in each gene
amr_gene_presence <- as_tibble(
  as.data.frame(
    map(amr_types, function(x) ifelse(str_detect(amr_gene_types$AMR.Gene.Family, x), 1, 0)),
    col.names = amr_types))

# add strain and summarize counts
amr_gene_presence$strain <- amr_gene_types$strain
amr_gene_presence <- relocate(amr_gene_presence, strain, .before = "ampC.type.beta.lactamase")

# here sum is applied to all variables
amr_types_strain <- amr_gene_presence %>% 
  group_by(strain) %>% 
  summarise(across(.cols = everything(), .fns = sum))

# we need shorter names
#names(amr_types_strain) <- c("strain", "ampC", "DFR", "APH6", "APH3.1", "SUL", "TEM", "SAT", "ANT3", "MPH", "APH3.2", "CTX.M", "CAT", "AAC3", "OXA", "AAC6", "ANT2", "FTT", "SHV", "TR.RPP", "APH4", "QNR")

# this table will be written to a file for EDA + shiny
```

## Add AMR-type counts to features_bl_strain

```{r}
features_strain <- left_join(features_strain, amr_types_strain, by = "strain") 

head(features_strain)
```

## Write AMP tables required for EDA to files

Resistance testing will be added later in the EDA section

```{r}
write.csv(n.beta.lac, "/home/andrei/Data/HeteroR/results/tables/n_beta_lac.csv", row.names = F)

write.csv(features_strain, "/home/andrei/Data/HeteroR/results/tables/features_strain.csv", row.names = F)

write.csv(features, "/home/andrei/Data/HeteroR/results/tables/features.csv", row.names = F)

# write amp amr types to a file
write.csv(amr_types_strain, "/home/andrei/Data/HeteroR/results/tables/amr_types_strain.csv", row.names = FALSE)
```

# Save the workspace

```{r, eval=TRUE}
save.image(f = "/home/andrei/Data/HeteroR/notebooks/features.RData")
```
