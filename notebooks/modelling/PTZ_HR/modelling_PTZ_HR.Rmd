---
title: "Modelling PTZ HR"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
output:
  html_document:
    toc: yes
    df_print: paged
    code_folding: hide
    fig_width: 10
    fig_height: 6
    theme: cerulean
    highlight: kate
    toc_float: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 10, fig.height = 5, message = F, warning = F, cache = T)
library(tidyverse)
library(caret)
library(ROCR)
library(DMwR)
```

# Read data

Here I use processed and scaled data from EDA_PTZ

```{r}
feat <- read_csv("data/features_ptz_hr_scaled.csv")

# replace HR/R with HR.R otherwise train() will complain
feat$resistance <- as.factor(str_replace(feat$resistance, "HR/R", "HR.R"))

feat %>% group_by(resistance) %>% 
  summarize(N = n())
```


# RF

ROC-optimization is better for imbalanced data

## Split data

Imbalanced data - use SMOTE to create training data set, but not testing data set

```{r}
set.seed(123)

sample_set <- createDataPartition(y = feat$resistance, p = .75, list = FALSE)

df_train <- feat[sample_set,]
df_test <- feat[-sample_set,]

df_train <- SMOTE(resistance ~ ., data.frame(df_train), perc.over = 200, perc.under = 150)

```

In new training data target classes look like this:

```{r}

df_train %>% group_by(resistance) %>% 
     summarize(N = n())
```

## Hyperparameters and training

```{r, message=FALSE, warning=FALSE}
set.seed(122)

library(doParallel)

cl <- makePSOCKcluster(18)
registerDoParallel(cl)

fit_ctrl_roc <- trainControl(method = "repeatedcv",
                           number = 5,
                           repeats = 10, 
                           allowParallel = T,
                           classProbs = T,
                           summaryFunction = twoClassSummary)


fit_rf <- train(resistance ~ ., 
                 data = df_train, 
                 metric = "ROC", 
                 method = "rf", 
                 trControl = fit_ctrl_roc,
                 tuneGrid = expand.grid(.mtry = seq(from = 9, to = 12, by = 0.5)),
                 verbosity = 0,
                 verbose = FALSE)

stopCluster(cl)

fit_rf
```

## Testing

```{r}
predClasses_rf <- predict(fit_rf, newdata=df_test)

cm_rf <- confusionMatrix(data = predClasses_rf, 
                reference = df_test$resistance,
                mode="everything",
                positive="HR.R")

cm_rf
```



## Feature importance

```{r, fig.height=8}
imp_vars_rf <- varImp(fit_rf)

plot(imp_vars_rf, main="Variable Importance with RF")
```

## ROC

A function for ROC

```{r}
get_roc <- function(fit.obj, testing.df){
  pred_prob <- predict.train(fit.obj, newdata = testing.df, type="prob")
  pred_roc <- prediction(predictions = pred_prob$nonHR, labels = testing.df$resistance)
  perf_roc <- performance(pred_roc, measure="tpr", x.measure = "fpr")
  return(list(perf_roc, pred_roc))
}
```



```{r}
# calculate ROC
perf_pred <- get_roc(fit_rf, df_test)
perf_rf <- perf_pred[[1]]
pred_rf <- perf_pred[[2]]

# take AUC 
auc_rf <- round(unlist(slot(performance(pred_rf, measure = "auc"), "y.values")), 3)

# plot
plot(perf_rf, main = "RF ROC curve", col = "steelblue", lwd = 3)
abline(a = 0, b = 1, lwd = 3, lty = 2, col = 1)
legend(x = 0.7, y = 0.3, legend = paste0("AUC = ", auc_rf))
```


```{r}
save.image("data/workspace.RData")
```

