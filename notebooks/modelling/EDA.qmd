---
title: "Exploratory Data Analysis of Pip/Tazo HR strains"
author: "by A.G."
date: "last update: `r format(Sys.Date(), format = '%d %B %Y')`"
format: 
  html:
    theme: "sandstone"
    toc: true
    toc-depth: 2
    toc-title: Contents
    toc-location: left
    df-print: paged
    standalone: true
    code-fold: true
editor: visual
---

```{r, message=FALSE, warning=FALSE}
library(tidymodels)
library(ggpubr)
library(factoextra)
library(cluster)
library(skimr)
library(readr)
library(themis) # smote
library(ggforce) # for plot_validation_results()
library(embed) # for umap and PCA variants
source("functions.R")
```

# Intro

Here I explore features of strains tested as HR and non-HR according to the most recent update from Karin.

AB is Piperacillin/Tazobactam

------------------------------------------------------------------------

# Read the data

Data set `data_strain` has been made earlier in `features.qmd`

Look at target class distribution in full data set (500 strains)

We have two classifications of HR:

1.  Groups I and II are considered HR

2.  Groups II and III are considered HR

With the 1st classification and a single best model (XGBTree), I got decent results:

|            |     |       |
|------------|-----|-------|
|            | HR  | nonHR |
| HR pred    | 12  | 9     |
| nonHR pred | 4   | 46    |

So, the results below will look different depending on the classification scheme chosen!

Copy the most up to date version of features tables to `data/`

```{bash}
#| eval: FALSE
# should work but might need fixing because of changed absolute path
rsync ~/Data/HeteroR/results/tables/features.csv ./data
rsync ~/Data/HeteroR/results/tables/features_strain.csv ./data
rsync ~/Data/HeteroR/results/tables/amr_types_strain.csv ./data
```

Read features and classification labels

```{r, message=FALSE}
data <- read_csv("data/features.csv")

data_strain <- read_csv("data/features_strain.csv", na = c("NA", "-Inf"))
  
# TWO SCHEMES IN TWO FILES
hr_testing12 <- read_csv("data/heteroresistance_testing.csv", col_select = c(strain, Gr12)) %>% 
  filter(!is.na(strain)) %>% 
  rename("resistance" = Gr12 )

hr_testing13 <- read_csv("data/heteroresistance_testing.csv", col_select = c(strain, Gr13)) %>% 
  filter(!is.na(strain)) %>% 
  rename("resistance" = Gr13 )

# THIS ONE YOU MAKE YOURSELF
hr_testing <- left_join(hr_testing12, hr_testing13, by = "strain") %>% 
  mutate(resistance = case_when(resistance.x == "HR" | resistance.y == "HR" ~ "HR",
                              resistance.x == "R" | resistance.y == "R" ~ "R",
                              is.na(resistance.x) & resistance.y == "nonHR" ~ "nonHR", # NA only in resistance.x which is Gr12
                              resistance.x == "nonHR" & resistance.y == "nonHR" ~ "nonHR")) %>% 
  select(strain, resistance)

# WRITE IT
#write_csv(hr_testing, "data/heteroresistance_testing_gr123.csv")
#write_csv(hr_testing12, "data/heteroresistance_testing_gr12.csv")
#write_csv(hr_testing13, "data/heteroresistance_testing_gr13.csv")

```

**NB**: Some strains are in HR labels data; some are on Argos, and some are assembled.

```{r}
# strains tested
length(hr_testing$strain) # 500
# strains available
strains_on_argos <- dir("/mnt/data/andrei/Data/Argos/imb_sal_raw/Sequenced_reference_strains/Sequencing/Strains/", pattern = "DA") # 540
strains_assembled <- dir("/mnt/data/andrei/Data/HeteroR/resources/data_raw/", pattern="DA") # 526

# strains on Argos and in tested
length(intersect(strains_on_argos, hr_testing$strain))
```

Which strain that are tested, but are not on Argos yet?

```{r}
setdiff(hr_testing$strain, strains_on_argos) # 12 = 500 - 488
```

Which strains were tested, but are not assembled yet?

```{r}
setdiff(hr_testing$strain, strains_assembled)
```

The same 12 strains, which means the rest were sequenced and assembled.

Classes in `hr_testing12`

```{r}
hr_testing12 %>% 
  group_by(resistance) %>% 
  count()
```

Classes in `hr_testing13`

```{r}
hr_testing13 %>% 
  group_by(resistance) %>% 
  count()
```

NAs in HR12 and HR13

```{r}
left_join(hr_testing12, hr_testing13, by = "strain") %>% 
  filter(is.na(resistance.x), is.na(resistance.y))
```

Classes in `hr_testing` (I+II+III)

```{r}
hr_testing %>% 
  group_by(resistance) %>% 
  count()
```

We have very imbalanced target class with any classification scheme.

Look at target class distribution in the data set you're working with (521 strains)

## Choose the HR classification scheme

```{r}
# consider different classification schemes
data_strain <- data_strain %>% 
  left_join(hr_testing12, by = "strain")

data_strain %>% 
  group_by(resistance) %>% 
  count()
```

On the fully tested data set I will start from classification 1+2+3, because it performed the best during previous attempts with 483 strains tested

## Some additional features and filtering

1.  Add BL genes counts as ordered factor and as binary features (if BL \> 3)

2.  Filter/Rename HR labels (we're not doing this)

3.  Remove R strains

```{r}
# keep strains elsewhere
strains <- data_strain$strain

data_strain <- data_strain %>% 
  #mutate(n.beta.lac.3 = factor(ifelse(n.beta.lac > 3, "yes", "no"))) %>% 
  mutate(n.beta.lac.4 = factor(ifelse(n.beta.lac > 4, "yes", "no"))) %>% 
  relocate(n.beta.lac.4, .before = "n.plasmids") %>% 
  filter(resistance != "R", strain != "DA63310") %>% 
  mutate(resistance = factor(resistance, levels = c("HR", "nonHR")),
         chrom.status = factor(chrom.status))
  
data_strain
```

# Descriptive stats

## Factors

```{r}
skim(data_strain) %>% 
  yank("factor")
```

## Circularity in tested strains

```{r}
data_strain %>% 
  group_by(resistance, chrom.status) %>% 
  count() %>% 
  ggplot(aes(chrom.status, n)) +
  geom_col(position = "dodge") + 
  facet_grid(cols = vars(resistance))
```

## Numerical

```{r}
skim(data_strain) %>% 
  yank("numeric")
```

All the missing values should be replaced with zero except N50.

N50 statistic comes only from Unicycler logs, that's why it is not available for that many strains

I will remove it.

```{r}
data_strain$N50 <- NULL
```

### n.plasmids outliers

I have fixed this filtering by plasmid length in `features.qmd`

```{r}
data_strain %>% 
  filter(n.plasmids > 20) %>% 
  select(strain, chrom.status, resistance, n.plasmids)
```

# NAs to 0s

```{r}
data_strain[is.na(data_strain)] <- 0
```

# Write the first processed version of the data set to shiny's data directory

```{r, eval=FALSE}
write.csv(data_strain, file = "EDA_app/data/features_strain.csv", row.names = FALSE)
```

All pre-processing will be done with `recipes`

------------------------------------------------------------------------

# EDA

## Correlation plot

```{r, fig.width=14, fig.height=10, warning=FALSE}
# without resistance
cor_matrix <- data_strain %>%
  select(-c(
    strain,
    resistance,
    n.beta.lac.4,
    chrom.status,
    contains(c("APH", "ANT", "PH", "CAT", "AAC", "SAT", "DHA", "qnr"), ignore.case = FALSE)
  )) %>%
  cor(use = "pairwise.complete.obs", method = "spearman")

corrplot::corrplot(cor_matrix, type = "upper", tl.col = "black", tl.cex = 0.6)
```

We see a lot of correlated features.

## PCA

### ORQ Normalization

ORQ normalization is used here, regular `step_normalize()` is not really needed.

```{r}
library(bestNormalize)

orq_recipe <- recipe(resistance ~., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_orderNorm(all_numeric_predictors()) %>% 
  step_dummy(all_nominal_predictors())
  #step_normalize(all_predictors())

data_prep <- orq_recipe %>% prep() %>% juice()

# processed data 
data_prep
```

```{r, fig.width=12, fig.height=12, warning=FALSE}
# without resistance
cor_matrix_norm <- data_prep %>% 
  select(-c(strain, resistance)) %>%
  cor(use = "pairwise.complete.obs", method = "spearman")

corrplot::corrplot(cor_matrix_norm, type = "upper", tl.col = "black", tl.cex = 0.6)
```

#### Compare distributions

Choose the variable of interest in the function below or check the **shiny app** out!

```{r, fig.width = 10, fig.height=5}
library(patchwork)

plots <- comp_plots("n.c.plasmids", data_strain, data_prep)

# patchwork's syntax
(plots[[1]] | plots[[2]])
```

### Yeo-Johnson transformation

```{r}
yj_recipe <- recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_YeoJohnson(all_numeric_predictors()) %>% 
  #step_normalize(all_numeric_predictors()) %>% 
  step_dummy(all_nominal_predictors())
```

#### Check the distributions

```{r}
data_prep_yj <- yj_recipe %>% prep() %>% juice()

plots <- comp_plots("coverage", data_strain, data_prep_yj)
```

```{r, fig.width = 12, fig.height=5}
(plots[[1]] | plots[[2]])
```

**NB**: Yeo-Johnson transformation works comparable or worse than ORQ normalization

### PCA plot

based on recipe with ORQ normalization

```{r}
# the winning PCA recipe from modelling.Rmd
pcayj_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
  step_pca(all_numeric_predictors(), num_comp = 4) %>% 
  step_normalize(all_numeric_predictors())

Fig_6A <- pcayj_recipe %>% 
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("PC1", "PC2", "PC3", "PC4")) +
  ggtitle("Principal Component Analysis")
Fig_6A
```

### Explained variance percentage

```{r}
# find the step number corresponding to PCA, here it's 5
data_pca <- prep(pcayj_recipe, retain = TRUE)
sdev <- data_pca$steps[[5]]$res$sdev
percent_variation <- sdev^2 / sum(sdev^2)

var_df <- data.frame(PC = paste0("PC", 1:length(sdev)),
                     var_explained = percent_variation,
                     stringsAsFactors = FALSE)

var_df <- var_df %>% 
  mutate(var_cum_sum = cumsum(var_explained))

var_df
```

10 PCs explain 70% of variation 18 PCs needed to explain 80% of variation 30 PCs needed to explain 90% of variation

Plot

```{r, fig.width=12, fig.height=6}
var_df %>%
  mutate(PC = forcats::fct_inorder(PC)) %>%
  slice_head(n = 20) %>% 
  ggplot(aes(x = PC, y = var_explained)) + 
  geom_col(aes(fill = var_cum_sum)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 15)) +
  scale_fill_continuous(type = "viridis") +
  xlab("")
```

### Top loadings

10 PCs that explain 70% of variance

```{r, message=FALSE, warning=FALSE, fig.width=15, fig.height=6}
if (!require(learntidymodels, quietly = TRUE))  
  devtools::install_github("tidymodels/learntidymodels")

data_pca %>%
  plot_top_loadings(component_number <= 11, n = 5) + 
  scale_fill_brewer(palette = "Paired") +
  ggtitle("Principal Component Analysis")
```

## Polynomial k-basis PCA

Kernel principal component analysis (kPCA) is an extension of a PCA analysis that conducts the calculations in a broader dimensionality defined by a kernel function

```{r}
kpcayj_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
  step_kpca_poly(all_numeric_predictors(), num_comp = 9) %>% 
  step_normalize(all_numeric_predictors())

Fig_6B <- kpcayj_recipe %>% 
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("kPC1", "kPC2", "kPC3", "kPC4")) +
  ggtitle("Kernel Principal Component Analysis")
Fig_6B
```

## ICA - Independent Component Analysis

```{r, message=FALSE, warning=FALSE}
if (!require(fastICA)) 
  install.packages("fastICA")

ica_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
  step_ica(all_numeric_predictors(), num_comp = 5) %>% 
  step_normalize(all_numeric_predictors())

data_ica <- prep(ica_recipe, retain = TRUE)

data_ica$template %>% 
  plot_validation_results(c("IC1", "IC2", "IC3", "IC4")) + 
  ggtitle("Independent Component Analysis")
```

## Isomap Embedding

```{r}
# if (!require(dimRed)){
#   install.packages("dimRed")
# }
# 
# if (!require(RSpectra)){
#   install.packages("RSpectra")
# }

isomap_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
  step_isomap(all_numeric_predictors(), num_terms = 5, neighbors = 10) %>% 
  step_normalize(all_numeric_predictors())

isomap_recipe %>% 
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("Isomap1", "Isomap2", "Isomap3", "Isomap4")) + 
  ggtitle("Isomap Embedding")
```

## PLS

it's a supervised version of PCA, be careful!

```{r}
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# if (!require(mixOmics, quietly = TRUE))
#   BiocManager::install("mixOmics")

pls_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
  step_pls(all_numeric_predictors(), num_comp = 4, outcome = "resistance") %>% 
  step_normalize(all_numeric_predictors())

pls_recipe %>% 
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("PLS1", "PLS2", "PLS3")) + 
  ggtitle("PLS")
```

## UMAP - uniform manifold approximation and projection

> while high values will push UMAP towards representing the big-picture structure while losing fine detail.

### Unsupervised

```{r, message=FALSE, warning=FALSE, fig.width=8}

umapuyj_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
    step_umap(
    all_numeric_predictors(),
    num_comp = 10,
    min_dist = 0.8,
    neighbors = 25
  ) %>% 
  step_normalize(all_numeric_predictors())

umapu_recipe <- orq_recipe %>%
  step_umap(
    all_numeric_predictors(),
    num_comp = 10,
    min_dist = 0.8,
    neighbors = 25
  )

Fig_6C <- umapuyj_recipe %>%
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("UMAP01", "UMAP02", "UMAP03", "UMAP04")) +
  ggtitle("UMAP unsupervised")
Fig_6C
```

### Supervised

Supervised UMAP look really promising. HR clusters are more compact and some of them are more distant from non-HR ones.

```{r, message=FALSE, warning=FALSE, fig.width=8}
umapsyj_recipe <- 
  recipe(resistance ~ ., data = data_strain) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_YeoJohnson(all_numeric_predictors())  %>%
  step_normalize(all_numeric_predictors()) %>% 
    step_umap(
    all_numeric_predictors(),
    outcome = "resistance",
    num_comp = 10,
    min_dist = 0.8,
    neighbors = 25
  ) %>% 
  step_normalize(all_numeric_predictors())

umaps_recipe <- orq_recipe %>%
  step_umap(
    all_numeric_predictors(),
    outcome = "resistance",
    num_comp = 10,
    min_dist = 0.8,
    neighbors = 25
  )

Fig_6D <- umaps_recipe %>%
  prep() %>% 
  juice() %>% 
  plot_validation_results(c("UMAP01", "UMAP02", "UMAP03", "UMAP04")) +
  ggtitle("UMAP supervised")
Fig_6D
```

Fig_6

```{r,fig.height=10, fig.width=10}
Fig_6 <- ggarrange(Fig_6A, Fig_6B, Fig_6C, Fig_6D,
                    labels = c("A", "B", "C", "D"),
                    ncol = 2, nrow = 2, common.legend = TRUE)
Fig_6
```



### With added FP and FN

They come from modelling of course (the last fit + extract predictions)

```{r, fig.width=10, fig.height = 8}
#| eval: false

# to add falsely and correctly identified by the final fit
# go to modelling -> extract predictions, that table is there

umap2_postEDA <- left_join(data_umap_sup$template, pred_df, by = "strain")

umap2_postEDA[is.na(umap2_postEDA)] <- "COR"

umap2_postEDA %>% 
  ggplot(aes(UMAP1, UMAP2)) +
  geom_point(aes(color = resistance, shape = prediction), alpha = 0.6, size = 2) +
  scale_color_brewer(palette = "Set1") +
  ggtitle("Supervised UMAP (HR12)")

# save for the shiny app
#write.csv(umap2_postEDA, "EDA_app/data/data_umap12_postEDA.csv", row.names = F)
```

### On 'captured variance'

The [answer](https://github.com/lmcinnes/umap/issues/122) of Leland McInnes himself:

> As a non-linear manifold learning technique that ultimately works with metric spaces at its heart rather than feature based data UMAP doesn't really have a notion of explained variance the way algorithms like PCA do. A colleague is working on developing some alternative measures of how well an embedding has performed, but that is still preliminary work and we don't have any published code for that yet -- ultimately UMAP remains a research project with additional features and utilities still being developed.

## UMAP on separate HR groups

Non-supervised

```{r}

hr_groups <- left_join(hr_testing12, hr_testing13, by = "strain") %>% 
  mutate(hr.group = case_when(resistance.x == "HR" & resistance.y == "HR" ~ "group_1",
                              resistance.x == "HR" & resistance.y == "nonHR" ~ "group_2",
                              resistance.x == "nonHR" & resistance.y == "HR" ~ "group_3",
                              resistance.x == "nonHR" & resistance.y == "nonHR" ~ "nonHR")) %>% 
  select(strain, hr.group)

hr_groups
```

```{r, warning=FALSE, fig.width=9, fig.height=9}
data_groups <- data_strain %>% 
  select(-resistance) %>% 
  left_join(hr_groups, by = "strain")

umap_groups_recipe <- recipe(hr.group ~., data = data_groups) %>%
  update_role(strain, new_role = "ID") %>%
  step_nzv(all_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_orderNorm(all_numeric_predictors()) %>% 
  step_normalize(all_predictors()) %>% 
  step_umap(all_numeric_predictors(), 
            #outcome = "hr.group", 
            num_comp = 6, 
            min_dist = 0.02, 
            neighbors = 25)

data_umap_groups <- prep(umap_groups_recipe, retain = TRUE)

data_umap_groups$template %>% 
    select(-strain) %>% 
    ggplot(aes(x = .panel_x, y = .panel_y, color = hr.group, fill = hr.group)) +
    geom_point(alpha = 0.4, size = 1, aes(shape = hr.group)) +
    facet_matrix(vars(-hr.group), layer.diag = 2) + 
    scale_color_brewer(palette = "Set1", direction = 1) + 
    scale_shape_manual(values = c(21, 24, 22, 3)) +
    theme_bw() +
    ggtitle("(un)Supervised UMAP (HR groups)")
```

### Remove nonHR

to better see clustering of HRs

```{r, fig.width=10}
data_umap_groups$template %>% 
  filter(hr.group != "nonHR") %>% 
    select(-c(strain, UMAP4, UMAP5, UMAP6)) %>% 
    ggplot(aes(x = .panel_x, y = .panel_y, color = hr.group, fill = hr.group)) +
    geom_point(alpha = 0.5, size = 2, aes(shape = hr.group)) +
    facet_matrix(vars(-hr.group), layer.diag = 2) + 
    scale_color_brewer(palette = "Set1", direction = 1) + 
    scale_shape_manual(values = c(21, 24, 22, 20)) +
    theme_bw() +
    ggtitle("(un)Supervised UMAP (HR groups)")
```

groups 1,2 and 3 are very similar to each other

### 3D version

```{r, eval=FALSE}
library(plotly)

umap3d <-
  plot_ly(
    data_umap_groups$template,
    x = ~ UMAP1,
    y = ~ UMAP2,
    z = ~ UMAP3,
    color = ~ data_umap_groups$template$hr.group,
    colors = c('#cf280c', '#1b56f7', '#FFC300', '#035a10')
  )

umap3d <- umap3d %>% 
  add_markers(size = 2, text = ~ data_umap_groups$template$strain)

umap3d <- umap3d %>% 
  layout(scene = list(
    xaxis = list(title = 'UMAP1'),
    yaxis = list(title = 'UMAP2'),
    zaxis = list(title = 'UMAP3')
))

umap3d

```

## RG counts distribution

### In strains tested for AMP

```{r}
rg_n_genes <- data %>% 
  select(strain, record_id) %>% 
  distinct() %>% 
  group_by(strain) %>% 
  count()

ggplot(rg_n_genes, aes(n)) + 
  geom_histogram(fill = "steelblue", binwidth = 1) +
  xlab("RG count") +
  ylab("Strains count")


```

```{r}
summary(rg_n_genes$n)
```

Same number as in the total data set.

### In strains with beta-lactamases genes only

```{r}
betaL_n_genes <- data %>% 
  filter(grepl("beta-lactamase", AMR.Gene.Family)) %>% 
  select(strain, record_id) %>% 
  distinct() %>% 
  group_by(strain) %>% 
  count()

ggplot(betaL_n_genes, aes(n)) + 
  geom_histogram(fill="steelblue", binwidth = 1)+
  xlab("BL count")+
  ylab("Strains count")

```

```{r}
summary(betaL_n_genes$n)
```

Every strain has at least one beta-lactamase gene.

## Gene presence

This supposed to be the main predictor of HR

### Number of beta-lactamases

#### Bar plot

because number of BL genes is count data.

```{r}
#data_strain$resistance <- factor()

ggplot(data_strain, aes(n.beta.lac)) +
  geom_bar(aes(fill = resistance), position = "dodge") +
  scale_fill_brewer(palette = "Set1") +
  xlab("n beta-lactamases") +
  ylab("n strains") +
  theme(legend.title = element_blank()) +
  scale_x_continuous(breaks = c(1,2,3,4,5,6))
```

There is a strain without a single beta-lactamase

```{r}
data_strain %>% filter(n.beta.lac == 0)
```

Low coverage, incomplete assembly, susceptible, no repeats.

#### Proportion

```{r}
ggplot(data_strain, aes(n.beta.lac)) +
  geom_bar(aes(fill = resistance), position = "fill") +
  scale_fill_brewer(palette = "Set1") +
  xlab("n beta-lactamases") +
  ylab("proportion") +
  theme(legend.title = element_blank()) +
  scale_x_continuous(breaks = c(1,2,3,4,5,6))
```

**OBS!**

1.  If number of BL-genes is higher than 4, the strain is more likely to be HR

2.  There are `r nrow(data_strain %>% filter(n.beta.lac == 1, resistance == "HR"))` HR strain with only 1 beta-lactamase (which is *ampC*)

#### BL \> 4 proportion

When number of BL genes is greater than 3, quite likely that the strain is HR or R

```{r}
Fig_3A <- ggplot(data_strain, aes(n.beta.lac.4)) +
  geom_bar(aes(fill = resistance), position = "fill") +
  scale_fill_brewer(palette="Set1") +
  xlab("N beta-lactamase") +
  ylab("proportion of strains") +
  scale_x_discrete(labels = c("no" = "≤4", "yes" = ">4")) +
  theme(legend.title=element_blank())
Fig_3A

```


Now the chance of being HR is higher than the chance of being nonHR

#### Number of Beta-lactamases vs resistance

Let's fit a logistic regression

```{r}
logreg_nbl_fit <- glm(resistance ~ n.beta.lac, data = data_strain, family = "binomial")
summary(logreg_nbl_fit)
```

```{r}
exp(coef(logreg_nbl_fit))
```

### Beta-lactamases on plasmids and chromosome

Variable `n.genes.plasmids` means number of **beta-lactamases** on plasmids (it was renamed).

Let's check this.

It should always be less or equal than `n.beta.lac`.

How many strains in our data set `n.beta.lac` greater or equal `n.beta.lac.plasmid`: `r sum(data_strain$n.beta.lac >= data_strain$n.beta.lac.plasmid)`

How many strains in total: `r nrow(data_strain)`

These numbers must be equal.

#### Number of beta-lact on plasmids

```{r}
ggplot(data_strain, aes(n.beta.lac.plasmid)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  scale_x_continuous(breaks = c(0,1,2,3,4,5,6,7,8)) +
  xlab("n beta-lactamases on plasmids") +
  ylab("n strains")
```

As a proportion

```{r}
ggplot(data_strain, aes(n.beta.lac.plasmid)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  scale_x_continuous(breaks = c(0,1,2,3,4,5,6)) +
  xlab("n beta-lactamases on plasmids") +
  ylab("n strains")
```

Starting from 4 bl genes (on plasmids), it seems to be a very good predictor.

#### Number of beta-lact on chrom

Classic bar plot

```{r}
ggplot(data_strain, aes(n.beta.lac.chrom)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  scale_x_continuous(breaks = c(0,1,2,3,4,5)) +
  xlab("n beta-lactamases on chromosome") +
  ylab("n strains")
```

As proportion:

```{r}
ggplot(data_strain, aes(n.beta.lac.chrom)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  scale_x_continuous(breaks = c(0,1,2,3,4,5)) +
  xlab("n beta-lactamases on chromosome") +
  ylab("proportion")
```

#### Proportion bar plot

```{r}
bl_loc_sum <- data_strain %>% 
  select(resistance, n.beta.lac.plasmid, n.beta.lac.chrom) %>% 
  gather("loc", "N", 2:3) %>% 
  filter(N > 0) %>% 
  group_by(resistance, loc) %>% 
  summarise(sum.n = sum(N))

ggplot(bl_loc_sum, aes(loc, sum.n)) +
  geom_col(aes(fill = resistance), position = "fill") +
  scale_fill_brewer(palette = "Set1") +
  xlab("") +
  ylab("proportion") +
  scale_x_discrete(labels = c("on chromosome", "on plasmids")) +
  theme(legend.title = element_blank())
```

If a strain has BL genes on chromosome only it's more likely to be non-HR than HR

#### On chromosomes and plasmids among HR and nonHR

```{r}
ggplot(bl_loc_sum, aes(resistance, sum.n)) +
  geom_col(aes(fill = loc), position = "fill") +
  scale_fill_brewer(palette = "Set2") +
  xlab("") +
  ylab("proportion") +
  #scale_x_discrete(labels = c("on chromosome", "on plasmids")) +
  theme(legend.title = element_blank())
```

### Beta-lactamases on plus strand

#### Total

```{r}
ggplot(data_strain, aes(n.beta.lac.plus)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand") +
  ylab("n strains") 
```

As proportion

```{r}
ggplot(data_strain, aes(n.beta.lac.plus)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand") +
  ylab("proportion") 
```

#### On plasmids

```{r}
ggplot(data_strain, aes(n.beta.lac.plus.plasmid)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand on plasmids") +
  ylab("n strains") 
```

As proportion:

```{r}
ggplot(data_strain, aes(n.beta.lac.plus.plasmid)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand on plasmids") +
  ylab("proportion") 
```

#### On chromosomes

```{r}
ggplot(data_strain, aes(n.beta.lac.plus.chrom)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand on chromosome") +
  ylab("n strains") 
```

As proportion

```{r}
ggplot(data_strain, aes(n.beta.lac.plus.chrom)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n beta-lactamases on plus strand on chromosome") +
  ylab("proportion") 
```

### ampC and non-ampC beta-lactamases

```{r}
bl_type_count <- data_strain %>% 
  select(resistance, n.beta.lac, ampC.type.beta.lactamase) %>% 
  mutate(non.ampC = n.beta.lac - ampC.type.beta.lactamase) %>% 
  select(-n.beta.lac)

bl_type_count_tidy <- gather(bl_type_count, key = "gene", value = "n", 2:3) %>% 
  group_by(resistance, gene) %>% 
  summarize(sum=sum(n))


ggplot(bl_type_count_tidy, aes(gene, sum))+
  geom_col(aes(fill=resistance), position = "fill", alpha = 1) + 
  # scale_fill_viridis_d(option = "inferno", begin = 0.2, end = 0.7) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("") +
  ylab("proportion")+
  scale_x_discrete(labels = c("ampC", "non-ampC"))
  
```

Among strains having only ampC beta-lactamases, the majority is non-HR

Among strains having non-ampC beta-lactamases majority is HR

### ampC bar plot

```{r}
ggplot(data_strain, aes(ampC.type.beta.lactamase)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n ampC beta-lactamases") +
  ylab("n strains") 
```

As proportion:

```{r}
ggplot(data_strain, aes(ampC.type.beta.lactamase)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n ampC beta-lactamases") +
  ylab("proportoion") 
```

### non-ampC bar plot

```{r}
ggplot(bl_type_count, aes(non.ampC)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n non-ampC beta-lactamases") +
  ylab("n strains") 
```

As proportion

```{r}
ggplot(bl_type_count, aes(non.ampC)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("n non-ampC beta-lactamases") +
  ylab("proportion") 
```

## TEM beta-lactamase

```{r}
ggplot(data_strain, aes(TEM.beta.lactamase)) +
  geom_bar(aes(fill = resistance), position = "dodge", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("TEM beta-lactamase") +
  ylab("n strains") 
```

As proportion:

```{r}
Fig_3B <- ggplot(data_strain, aes(TEM.beta.lactamase)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "") +
  xlab("TEM beta-lactamase") +
  ylab("proportion")
Fig_3B
```

```{r}
Fig_3 <- ggarrange(Fig_3A , Fig_3B + ylab("") ,
                    labels = c("A", "B"),
                    ncol = 2, nrow = 1, common.legend = TRUE)
Fig_3
```

### Other TEM columns

```{r}
data_strain %>% select(contains("TEM", ignore.case=T)) %>% names()
```

### Repeat count without 0s

```{r}
data_strain %>% 
  filter(n.rep.plasmid.TEM > 0) %>% 
  ggplot(aes(resistance, n.rep.plasmid.TEM)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y="sqrt") +
  ylab("") +
  guides(fill="none")
```

### Median AR length without 0s

```{r}
data_strain %>% 
  filter(med.AR.len.chrom.TEM > 0) %>% 
  ggplot(aes(resistance, med.AR.len.chrom.TEM)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = F, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y="sqrt") +
  ylab("") +
  guides(fill="none")
```

### Median repeat length on plasmids

```{r}
data_strain %>% 
  filter(med.rep.len.plasmid.TEM > 0) %>% 
  ggplot(aes(resistance, med.rep.len.plasmid.TEM)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = F, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y="sqrt") +
  ylab("") +
  guides(fill="none")
```

## Beta-lactamases heatmap

### AMR types in each strain

highlight BLs somehow!

```{r, fig.width=20, fig.height=6}
# I read in amr type counts form the table made in features.qmd

amr_types_strain <- read_csv("data/amr_types_strain.csv", show_col_types = FALSE)

# make tidy for ggplot
amr_types_strain_td <- gather(amr_types_strain, key = "AMR.type", value = "N", 2:ncol(amr_types_strain))

# amr_gene_types <- features %>%
#   select(strain, record_id, AMR.Gene.Family) %>% 
#   distinct() %>% 
#   filter(!is.na(AMR.Gene.Family)) %>% 
#   mutate(AMR.Gene.Family = sub("\\'+)$", "')", AMR.Gene.Family))
# 
# amr_gene_types_count <-
#   amr_gene_types %>% group_by(strain, AMR.Gene.Family) %>% count()

# make a plot
ggplot(amr_types_strain_td, aes(strain, AMR.type)) + 
  geom_tile(aes(fill = N)) +
  theme(axis.text.x = element_text(
    angle = 45,
    vjust = 0.2,
    hjust = 1,
    size = 3
  )) +
  xlab("") +
  scale_fill_gradient2(high = "blue")
```

*ampC* is present in every strain

#### Interactive version

```{r, eval=F, fig.width=12, eval=FALSE}
library(plotly)

vals <- scales::rescale(c(0:max(amr_types_strain_td$N)))
o <- order(vals, decreasing = FALSE)
cols <- scales::col_numeric("Blues", domain = NULL)(vals)
colz <- setNames(data.frame(vals[o], cols[o]), NULL)
fig <- plot_ly(z = amr_types_strain_td$N, 
               x = amr_types_strain_td$strain, 
               y = amr_types_strain_td$AMR.type, 
               type = "heatmap", 
               colorscale = colz)
fig
```

## Coverage

### Plot

```{r}
data_strain %>% 
    ggplot(aes(resistance, coverage)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

### KW test

```{r}
kruskal.test(data_strain$coverage, data_strain$resistance)
```

### Medians

```{r}
data_strain %>% group_by(resistance) %>% summarise(median=median(coverage))
```

## Sequencing reads lengths

```{r}
data_strain %>% 
    ggplot(aes(resistance, read.max.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

## Read length vs Coverage

```{r}
data_strain %>% 
  ggplot(aes(read.max.len, coverage)) +
  geom_point(aes(color = resistance), alpha=0.6) +
  scale_color_brewer(palette = "Set1") +
  ggtitle("") +
  guides(fill = "none")
```

```{r}
cor.test(data_strain$read.max.len, data_strain$coverage, method = "kendall")
```

## Number of plasmids

Per strain, doesn't depend on beta-lactamase presence or absence

### Box plot

```{r}
data_strain %>%
  ggplot(aes(resistance, n.plasmids)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

### Medians

```{r}
data_strain %>% group_by(resistance) %>% summarise(median=median(n.plasmids))
```

### Poisson model for count data

```{r}
summary(glm(n.plasmids ~ resistance, data=data_strain, family = "poisson"))
```

### Bar plot - filtered version

```{r}
data_strain %>% 
  #filter(n.plasmids < 50) %>% 
  ggplot(aes(n.plasmids)) +
  geom_bar(aes(fill = resistance), position = "fill", alpha = 1) +
  scale_fill_brewer(palette = "Set1", name = "")+
  xlab("n plasmids") +
  ylab("n strains")
```

### Plasmids vs Coverage

```{r}
data_strain %>%
  ggplot(aes(coverage, n.plasmids)) +
  geom_point(aes(color = resistance), alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("n") +
  xlab("coverage") +
  guides(fill = "none")
```

### Poisson model for count data

```{r}
pois_fit <- glm(n.plasmids ~ coverage, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

Increase of `coverage` by 1 unit decreases `n.plasmids` 0.99 times - which is very slow decrease, though (and barely significant)

## Number of plasmids vs completeness

### Plot

```{r}
data_strain %>%
  ggplot(aes(chrom.status, n.plasmids)) +
  geom_violin(aes(fill = chrom.status), alpha = 0.7) +
  geom_boxplot(
    aes(fill = chrom.status),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set2") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

### Poisson model for count data

```{r}
pois_fit <- glm(n.plasmids ~ chrom.status, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

'linearity' increases `n.plasmids` in 1.6 times

## Plasmid copy number

```{r}
data_strain %>%
  ggplot(aes(resistance, n.c.plasmids)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none") 
  #coord_trans(y="sqrt")
```

#### Poisson model for count data

```{r}
pois_fit <- glm(n.c.plasmids ~ resistance, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

nonHR decreases `n.c.plasmids` times 0.6

### Copy number vs Coverage

```{r}
data_strain %>%
  ggplot(aes(coverage, n.c.plasmids)) +
  geom_point(aes(color = resistance), alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("plasmid copy number") +
  xlab("coverage") +
  guides(fill = "none")
```

#### Poisson model for count data

```{r}
pois_fit <- glm(n.c.plasmids ~ coverage, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

Increase in `coverage` slowly decreases `n.c.plasmids`, but now it's significant.

## Copy number vs number of plasmids

```{r}
data_strain %>%
  ggplot(aes(n.plasmids, n.c.plasmids)) +
  geom_point(aes(color = resistance), alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  ggtitle("") +
  ylab("cn") +
  xlab("n") +
  guides(fill = "none")
```

### Poisson model for count data

```{r}
pois_fit <- glm(n.c.plasmids ~ n.plasmids, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

increase in `n.plasmids` by 1 unit increases `n.c.plasmids` 1.4 times

## Copy number of plasmids and completeness

```{r}
data_strain %>%
  ggplot(aes(chrom.status, n.c.plasmids)) +
  geom_violin(aes(fill = chrom.status), alpha = 0.7) +
  geom_boxplot(
    aes(fill = chrom.status),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set2") +
  ggtitle("") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

### Poisson model for count data

```{r}
pois_fit <- glm(n.c.plasmids ~ chrom.status, data=data_strain, family = "poisson")
summary(pois_fit)
```

```{r}
exp(coef(pois_fit))
```

'linearity' increases `n.c.plasmids`

## Median total repeat length

```{r}
med_rep_len <- data_strain %>% 
  select(resistance, med.tot.rep.len.chrom, med.tot.rep.len.plasmid, med.tot.rep.len) %>% 
  gather("location", "med.len", 2:4) 

facet_names <- c("med.tot.rep.len.chrom" = "chromosome",
                 "med.tot.rep.len.plasmid" = "plasmids",
                 "med.tot.rep.len" = "total")

med_rep_len %>% 
  filter(med.len > 0) %>% 
  ggplot(aes(resistance, med.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("avg repeat length") +
  xlab("") +
  guides(fill = "none")
```

```{r}
med_rep_len %>% 
  filter(location=="med.tot.rep.len.plasmid",
         med.len > 0) %>% 
  group_by(resistance) %>% 
  summarise(median = median(med.len))
```

### Average total

```{r}
data_strain %>% 
  filter(med.tot.rep.len > 0) %>% 
  ggplot(aes(resistance, med.tot.rep.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  ylab("med repeat length") +
  xlab("") +
  guides(fill = "none")
```

### Average on chromosome

```{r}
data_strain %>% 
  filter(med.tot.rep.len.chrom > 0) %>% 
  ggplot(aes(resistance, med.tot.rep.len.chrom)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  ylab("med repeat length") +
  xlab("") +
  guides(fill = "none")
```

### Average on plasmids

```{r}
data_strain %>% 
  filter(med.tot.rep.len.plasmid > 0) %>% 
  ggplot(aes(resistance, med.tot.rep.len.plasmid)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  ylab("med repeat length") +
  xlab("") +
  guides(fill = "none")
```

## Median repeat length

```{r}
med_rep_len <- data_strain %>% 
  select(resistance, med.rep.len.chrom, med.rep.len.plasmid, med.rep.len) %>% 
  gather("location", "med.len", 2:4)

med_rep_len$med.len <- if_else(med_rep_len$med.len == 0, 1, med_rep_len$med.len)

facet_names <- c("med.rep.len.chrom" = "chromosome",
                 "med.rep.len.plasmid" = "plasmids",
                 "med.rep.len" = "total")

med_rep_len %>% 
  filter(med.len > 1) %>%
  ggplot(aes(resistance, med.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T,
    outlier.shape = NA
  ) +
  geom_jitter(
    alpha = 0.2,
    width = 0.05,
    height = 0.1,
    size = 0.8
  ) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "log") +
  #scale_y_continuous(trans = "pseudo_log") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("median repeat length") +
  xlab("") +
  guides(fill = "none")
```

```{r}
med_rep_len %>% 
  filter(location == "med.rep.len.plasmid") %>% 
  ggplot(aes(resistance, med.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  ylab("median repeat length") +
  xlab("") +
  guides(fill = "none")
```

## Maximum repeat length

```{r}
max_rep_len <- data_strain %>% 
  select(resistance, max.rep.len.chrom, max.rep.len.plasmid, max.rep.len) %>% 
  gather("location", "max.len", 2:4)

max_rep_len$max.len <- if_else(max_rep_len$max.len == 0, 1, max_rep_len$max.len)

facet_names <- c("max.rep.len.chrom" = "chromosome",
                 "max.rep.len.plasmid" = "plasmids",
                 "max.rep.len" = "total")

ggplot(max_rep_len, aes(resistance, max.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("max repeat length") +
  xlab("") +
  guides(fill = "none")
```

```{r}
max_rep_len %>% 
  filter(location == "max.rep.len") %>% 
  group_by(resistance) %>% 
  summarise(median = median(max.len))
```

```{r}
max_rep_len %>% 
  filter(location == "max.rep.len.plasmid") %>% 
  group_by(resistance) %>% 
  summarise(median = median(max.len))
```

```{r}
ggplot(max_rep_len %>% filter(location == "max.rep.len.plasmid"), aes(resistance, max.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  ylab("max repeat length") +
  xlab("") +
  guides(fill = "none")
```

## Repeat counts

```{r}
rep_count <- data_strain %>% 
  select(resistance, n.rep.chrom, n.rep.plasmid, n.rep.total) %>% 
  gather("location", "n.rep", 2:4)

rep_count$n.rep <- if_else(rep_count$n.rep == 0, 1, rep_count$n.rep) 

facet_names <- c("n.rep.chrom" = "chromosome",
                 "n.rep.plasmid" = "plasmids",
                 "n.rep.total" = "total")

Fig_4A <-  ggplot(rep_count, aes(resistance, n.rep)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("n repeats") +
  xlab("") +
  guides(fill = "none")
Fig_4A
```

```{r}
ggplot(rep_count %>% filter(location == "n.rep.plasmid"), aes(resistance, n.rep)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt")+
  ylab("n repeats") +
  xlab("") +
  guides(fill = "none")
```

```{r}
rep_count %>% 
  filter(location == "n.rep.plasmid") %>% 
  group_by(resistance) %>% 
  summarise(median = median(n.rep))
```

```{r}
rep_count %>% 
  filter(location == "n.rep.total") %>% 
  group_by(resistance) %>% 
  summarise(median = median(n.rep))
```

## Amplifiable region size

```{r}
ar_len <- data_strain %>% 
  select(resistance, med.AR.len.chrom, med.AR.len.plasmid, med.AR.len) %>% 
  gather("location", "ar.len", 2:4)

facet_names <- c("med.AR.len.chrom" = "chromosome",
                 "med.AR.len.plasmid" = "plasmids",
                 "med.AR.len" = "total")

Fig_4B <- ar_len %>% 
  filter(ar.len > 0) %>% 
  ggplot(aes(resistance, ar.len)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  #coord_trans(y = "sqrt") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("avg AR length") +
  xlab("") +
  guides(fill = "none")
Fig_4B
```

```{r}
ar_len %>% 
  group_by(location, resistance) %>%
  summarise(median = median(ar.len))
```

## Distance to oriC

### Min distance on chromnomsome, on plasmids, both

```{r}
min_ori <- data_strain %>% 
  select(resistance, min.dist.oriC.chrom, min.dist.oriC.plasmid, min.dist.oriC) %>% 
  gather("location", "dist", 2:4)

# for plots
min_ori$dist <- if_else(min_ori$dist == 0, 1, min_ori$dist)

facet_names <- c("min.dist.oriC.chrom" = "chromosome",
                 "min.dist.oriC.plasmid" = "plasmids",
                 "min.dist.oriC" = "both")

Fig_4C <- ggplot(min_ori, aes(resistance, dist)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(aes(fill = resistance), alpha = 0.2, notch = F, varwidth = T, outlier.shape = NA) +
  geom_jitter(alpha = 0.2, width = 0.05, height = 0.1, size = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  coord_trans(y = "sqrt") +
  facet_grid(cols = vars(location), labeller = as_labeller(facet_names)) +
  ylab("min dist oriC") +
  xlab("") +
  guides(fill = "none")
Fig_4C
```

Fig4 

```{r,fig.height=10, fig.width=6}
Fig_4 <- ggarrange(Fig_4A, Fig_4B, Fig_4C,
                    labels = c("A", "B", "C"),
                    ncol = 1, nrow = 3)
Fig_4
```


```{r}
min_ori %>% 
  group_by(location, resistance) %>% 
  summarise(median = median(dist))
```

## Number of genes on plus strand

### On chromosome, on plasmids, both

```{r, fig.width=6, fig.height=4}
ggplot(data_strain, aes(n.beta.lac.plus))+
  geom_bar(aes(fill=resistance), position="fill")+
  scale_fill_brewer(palette="Set1")+
  xlab("number of genes")+
  ylab("number of strains")+
  ggtitle("Beta-lactamase genes on plus-strand")
```

## ampC-type beta-lactamases

Statistics based on BL of ampC-type only

### Total repeat count

#### As a box plot

`n.rep.total.ampC` was removed from the table created in `features.qmd` in the new table and are replaced with `n.rep.plasmid.ampC` and `n.rep.chrom.ampC` whose sum would be equal to `n.rep.total.ampC` and therefore redundant. We reintroduce it here since the table `data_strain` will be used only here in this notebook.

```{r}
data_strain <- data_strain %>% mutate(n.rep.total.ampC = n.rep.plasmid.ampC + n.rep.chrom.ampC )
```

```{r, fig.width=8, fig.height=4, warning=FALSE}
library(patchwork)

y_max <- max(data_strain %>% select(n.rep.total.ampC, n.rep.chrom.ampC,n.rep.plasmid.ampC))

p1 <- ggplot(data_strain, aes(resistance, n.rep.total.ampC))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("total")+
  ylab("N")+ xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p2 <- ggplot(data_strain, aes(resistance, n.rep.chrom.ampC))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("chromosomal")+
  ylab("") + xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p3 <- ggplot(data_strain, aes(resistance, n.rep.plasmid.ampC))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("plasmid")+
  ylab("") + xlab("") + 
  guides(fill="none") +
  ylim(0,y_max)

p1 + p2 + p3+ 
  plot_annotation(title = 'ampC-type BL repeat count')

```

#### As distributions

```{r, fig.width=6, fig.height=4}
ggplot(data_strain, aes(n.rep.total.ampC))+
  geom_area(aes(fill=resistance), stat="bin", alpha=0.6)+
  scale_fill_brewer(palette="Set1")+
  ggtitle("ampC-type BL: total repeat count distribution")+
  xlab("number of repeats")+
  ylab("number of strains")
```

### Median repeat length

```{r, fig.width=6, fig.height=4}
ggplot(data_strain %>% filter(med.rep.len.ampC > 0), aes(resistance, med.rep.len.ampC))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = F, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("ampC-type BL: median repeat length")+
  ylab("length")+
  guides(fill="none")
```

### Median AR size

```{r}
ggplot(data_strain %>% filter(med.AR.len.ampC > 0), aes(resistance, med.AR.len.ampC))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("ampC-type BL: median AR size")+
  ylab("AR size")+
  guides(fill="none")

```

TEM - like above

```{r}
data_strain <- data_strain %>% mutate(n.rep.total.TEM = n.rep.plasmid.TEM + n.rep.chrom.TEM )
```

```{r, fig.width=8, fig.height=4, warning=FALSE}

y_max <- max(data_strain %>% select(n.rep.total.TEM, n.rep.chrom.TEM,n.rep.plasmid.TEM))

p1 <- ggplot(data_strain, aes(resistance, n.rep.total.TEM))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("total")+
  ylab("N")+ xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p2 <- ggplot(data_strain, aes(resistance, n.rep.chrom.TEM))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("chromosomal")+
  ylab("") + xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p3 <- ggplot(data_strain, aes(resistance, n.rep.plasmid.TEM))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("plasmid")+
  ylab("") + xlab("") + 
  guides(fill="none") +
  ylim(0,y_max)

p1 + p2 + p3+ 
  plot_annotation(title = 'TEM-type BL repeat count')
```

### Median repeat length

```{r, fig.width=6, fig.height=4}
ggplot(data_strain %>% filter(med.rep.len.TEM > 0), aes(resistance, med.rep.len.TEM ))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = F, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("TEM C-type BL: median repeat length")+
  ylab("length")+
  guides(fill="none")
```

### Median AR size

```{r}
ggplot(data_strain %>% filter(med.AR.len.TEM > 0), aes(resistance, med.AR.len.TEM))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("TEM-type BL: median AR size")+
  ylab("AR size")+
  guides(fill="none")

```

CTX - like above

```{r}
data_strain <- data_strain %>% mutate(n.rep.total.CTX = n.rep.plasmid.CTX + n.rep.chrom.CTX )
```

```{r, fig.width=8, fig.height=4, warning=FALSE}

y_max <- max(data_strain %>% select(n.rep.total.CTX, n.rep.chrom.CTX,n.rep.plasmid.CTX))

p1 <- ggplot(data_strain, aes(resistance, n.rep.total.CTX))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("total")+
  ylab("N")+ xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p2 <- ggplot(data_strain, aes(resistance, n.rep.chrom.CTX))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("chromosomal")+
  ylab("") + xlab("") +
  guides(fill="none") +
  ylim(0,y_max)

p3 <- ggplot(data_strain, aes(resistance, n.rep.plasmid.CTX))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("plasmid")+
  ylab("") + xlab("") + 
  guides(fill="none") +
  ylim(0,y_max)

p1 + p2 + p3+ 
  plot_annotation(title = 'CTX-type BL repeat count')
```

### Median repeat length

```{r, fig.width=6, fig.height=4}
ggplot(data_strain %>% filter(med.rep.len.CTX > 0), aes(resistance, med.rep.len.CTX ))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = F, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("CTX C-type BL: median repeat length")+
  ylab("length")+
  guides(fill="none")
```

### Median AR size

```{r}
ggplot(data_strain %>% filter(med.AR.len.CTX > 0), aes(resistance, med.AR.len.CTX))+
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Set1")+
  coord_trans(y="sqrt") +
  ggtitle("CTX-type BL: median AR size")+
  ylab("AR size")+
  guides(fill="none")

```

## IS sequences

### IS family count

```{r}
colnames <- data_strain %>% 
  select(strain, resistance, new, contains("IS", ignore.case = FALSE)) %>% names()

data_strain %>% 
  select(strain, resistance, new, contains("IS", ignore.case = FALSE)) %>% 
  pivot_longer(cols = colnames[3:23], names_to = "is.family", values_to = "n") %>% 
  ggplot(aes(is.family, n)) +
  geom_col(aes(fill=resistance), position = "fill") +
  scale_fill_brewer(palette = "Set1", name = "") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) +
  xlab("") +
  ylab("proportion")
```

### ISAS1

This IS family was the only predictor used by rbfSVM + ncor+yj+rfe

What's so special about it?

```{r}
data_strain %>%
  ggplot(aes(resistance, ISAS1)) +
  geom_violin(aes(fill = resistance), alpha = 0.7) +
  geom_boxplot(
    aes(fill = resistance),
    alpha = 0.2,
    notch = F,
    varwidth = T
  ) +
  geom_jitter(alpha = 0.2,
              width = 0.15,
              height = 0.1) +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("ISAS1 count") +
  ylab("n") +
  xlab("") +
  guides(fill = "none")
```

### IS max length

```{r}
Fig_5A <- data_strain %>% 
  ggplot(aes(resistance, max.is.len)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Pastel1") +
  coord_trans(y="sqrt") +
  ylab("max IS length") +
  guides(fill="none")
Fig_5A
```

```{r}
data_strain %>% 
  group_by(resistance) %>% 
  summarise(median = median(max.is.len))
```

```{r}
kruskal.test(data_strain$max.is.len, data_strain$resistance)
```

### IS copies count

```{r}
Fig_5C <- data_strain %>% 
  ggplot(aes(resistance, n.is.tot)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Pastel1") +
  coord_trans(y="sqrt") +
  ylab("IS copy number") +
  guides(fill="none")
Fig_5C
```

```{r}
data_strain %>% 
  group_by(resistance) %>% 
  summarise(median = median(n.is.tot))
```

```{r}
kruskal.test(data_strain$n.is.tot, data_strain$resistance)
```

### Total family number

```{r}
Fig_5B <- data_strain %>% 
  ggplot(aes(resistance, n.is.fam)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Pastel1") +
  ylab("IS families") +
  guides(fill="none")
Fig_5B
```

```{r}
data_strain %>% 
  group_by(resistance) %>% 
  summarise(median = median(n.is.fam))
```

```{r}
isfam_pois_fit <- glm(n.is.fam ~resistance, data = data_strain, family="poisson")

summary(isfam_pois_fit)
```

```{r}
exp(coef(isfam_pois_fit))
```

### min IS distance to the gene

```{r}
Fig_5D <- data_strain %>% 
  ggplot(aes(resistance, min_distance_is_gene)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Pastel1") +
  ylab("min distance") +
  guides(fill="none")
Fig_5D
```

```{r,fig.height=8, fig.width=9}
Fig_5 <- ggarrange(Fig_5A, Fig_5B, Fig_5C,Fig_5D,
                    labels = c("A", "B", "C", "D"),
                    ncol = 2, nrow = 2)
Fig_5
```


```{r}
data_strain %>% 
  group_by(resistance) %>% 
  summarise(median = median(min_distance_is_gene, na.rm = T))
```

```{r}
kruskal.test(data_strain$min_distance_is_gene, data_strain$resistance)
```

### Interrupted genes

```{r}
data_strain %>% 
  ggplot(aes(resistance, n.interrupted.genes)) +
  geom_violin(aes(fill=resistance), alpha=0.7)+
  geom_boxplot(aes(fill=resistance), alpha=0.2, notch = T, varwidth = T)+
  geom_jitter(alpha=0.2, width=0.15, height = 0.1)+
  scale_fill_brewer(palette = "Pastel1") +
  ylab("N interrupted genes") +
  guides(fill="none")
```

Too few observations to compare.
