---
title: "Genome assemblies summary"
author: "by AG"
date: "last update: `r format(Sys.time(), format = '%d %B %Y, %H:%M CET')`"
output:
  html_document:
    fig_width: 8
    code_folding: hide
    df_print: paged
    toc: true
    toc_float: true
    rmdformats:
      theme: cerulean
      highlight: github
---

```{r, include=F}
knitr::opts_chunk$set(fig.width=10, fig.height=5, message = F, warning = F)
library(dplyr)
library(tidyr)
library(plotly)
library(ggplot2)
library(purrr)
library(GGally)
library(caret)
#library(ggpubr)
```

# Assemblies summary table

```{r, message = FALSE, warning = FALSE}
# just in case
setwd("/home/andrei/Data/HeteroR/notebooks")

summary_files <- dir(path="../results/assemblies_joined",  pattern = "summary.tsv", recursive=TRUE)
summary_table <- lapply(summary_files, function(x){
  df <- read.delim(paste0("../results/assemblies_joined/", x), stringsAsFactors = TRUE)
  df$Links <- as.integer(gsub(",", "", df$Links, fixed=TRUE))
  df$Length <- as.integer(gsub(",", "", df$Length, fixed=TRUE))
  df$N50 <- as.integer(gsub(",", "", df$N50, fixed=TRUE))
  df$Longest_component <- as.integer(gsub(",", "", df$Longest_component, fixed=TRUE))
  return(df)
  })


summary_table <- bind_rows(summary_table)

# add wet-lab-biologist-readable Status
status_new <- sub("incomplete", "linear", summary_table$Status)
status_new <- sub("complete", "circular", status_new)
status_new <- sub("scaffold", "additional_plasmid", status_new)
status_new <- factor(status_new, levels = c("circular", "linear", "additional_plasmid"))

summary_table$Status2 <- status_new

write.csv(summary_table, "/home/andrei/Data/HeteroR/results/genome_assembly_summary.csv")
```

Assembly summary information has been taken from Unicycler log files, total number of summary files `r length(summary_files)`

```{r}
summary_table
```

## Short summary of the full table

```{r}
summary(summary_table)
```


## Incomplete assemblies

```{r}
incomplete_assemblies <- summary_table %>% filter(Status=="incomplete")
incomplete_assemblies
```

Total number of strains `r length(unique(summary_table$Strain))`

Number of strains with at least one incomplete assembly `r length(unique(incomplete_assemblies$Strain))`

## Circular vs Coverage

Is coverage affecting circularity?

To calculate coverage use script `coverage.py`

```{bash, eval=FALSE}
# cd Data/HeteroR
workflow/scripts/coverage.py strains414.txt 5131220 coverage_414.tsv raw

# Batch coverage:
# min = 0.871354
# avg = 59.095106
# max = 352.535841
# Coverage ~25x or less is sparse, good for Unicycler.
# Now you can create config and run the pipeline

```

## Data 

Read and process coverage data

```{r}
coverage <- read.delim("~/Data/HeteroR/results/coverage/coverage_414.tsv")
coverage$Strain <- map_chr(coverage$file, function(x) strsplit(x, "/")[[1]][3])
coverage <- select(coverage, -c(file, type, format)) %>% filter(!is.na(Strain))
```

Join with summary

```{r}
summary_table <- left_join(summary_table, coverage, by="Strain")
summary_table
```


Is circular == complete? Yes

```{r}
summary_table %>% filter(Status=="incomplete" & Status2 == "circular")
```

### Plots

#### Pairs plot

```{r, fig.width=12, fig.height=12}
summary_num_scaled <- as.data.frame(
  scale(
    summary_table %>% 
          filter(Status2 != "additional_plasmid") %>% 
          select(names(summary_table)[c(2,3,4,5,6,11,12,13,14,15,16)])
    ))

ggpairs(summary_num_scaled)
```

Find linear combos

```{r}
findLinearCombos(summary_num_scaled)
```


#### Circularity vs Coverage

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, coverage)) +
  geom_boxplot(aes(fill=Type), notch=T, varwidth = T) +
  scale_fill_brewer(palette = "Set2")

```

Coverage as well as Type may be good predictors for Circularity

#### Circularity vs Longest component

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, Longest_component)) +
  geom_boxplot(aes(fill=Type), notch=F, varwidth = T) +
  coord_trans(y="log") +
  scale_fill_brewer(palette = "Set2")
```

#### Circularity vs max length

```{r, fig.width=9, fig.height=4}
ggplot(summary_table %>% filter(Status2 != "additional_plasmid"), aes(Status2, max_len)) +
  geom_boxplot(aes(fill=Type), notch=T, varwidth = T) +
  scale_fill_brewer(palette = "Set2")

```


### Model

```{r}
rsquared <- function(created_model) {
  dev <- created_model$deviance
  null_dev <- created_model$null.deviance
  model_n <- length(created_model$fitted.values)
  R_l <- 1 - dev / null_dev
  R_cs <- 1 - exp(-(null_dev - dev) / model_n)
  R_n <- R_cs / (1 - exp(-(null_dev / model_n)))
  cat("Pseudo R-squared for logistic regression model\n\n")
  cat("Hosmer and Lemeshow R-squared\t", round(R_l, 3), "\n")
  cat("Cox and Snell R-squared\t\t\t", round(R_cs, 3), "\n")
  cat("Nagelkerke R-squared\t\t\t\t", round(R_n, 3), "\n")
}


fit.coverage <- glm(Status2 ~ coverage + Type, data = summary_table %>% filter(Status2 != "additional_plasmid"), family="binomial")
summary(fit.coverage)
```

R-squared

```{r}
rsquared(fit.coverage)
```



## Number of plasmids per strain

```{r, message = FALSE}
plasmids_count <- summary_table %>% group_by(Strain, Type) %>% summarise(Count = n()) %>% filter(Type=="Plasmid")
plasmids_count
```

Total number of strains with plasmids identified `r length(plasmids_count$Strain)`

Could not find any plasmids in `r length(unique(summary_table$Strain)) - length(plasmids_count$Strain)` strains


### Plasmid counts per strain

**All following plots are interactive (zoomable, clickable and draggable), in case of problems reload the page**

```{r, message=FALSE, warning=FALSE, fig.width=12}
plasmids_count <- arrange(plasmids_count, -Count)

bar_plasmid <- plot_ly(
  x = plasmids_count$Strain,
  y = plasmids_count$Count,
  type = "bar" 
)

bar_plasmid %>% layout(title="Plasmids count per strain")
```


### Plasmid counts distribution


```{r, message=FALSE, warning=FALSE, fig.width=12}
# boxplot and violin plot
box_plasmid <- plasmids_count %>%
  plot_ly(
    y = ~Count,
    type = 'violin',
    box = list(
      visible = T
    ),
    meanline = list(
      visible = T
    ),
    x0 = 'Plasmid'
  )

box_plasmid <- box_plasmid %>%
  layout(
    yaxis = list(
      title = "Count",
      zeroline = F
    )
  )

box_plasmid <- box_plasmid %>% layout(title="Distribuiton of plasmid counts")

# histogram
hist_plasmids <- plasmids_count %>% 
  plot_ly(y = ~Count, type = "histogram") %>% 
  layout(title="Distribuiton of plasmid counts")

# combined
fig <- subplot(box_plasmid, hist_plasmids) %>% 

  layout(title = 'Plasmids counts distribution', showlegend=FALSE)

fig
```


## Number of complete and incomplete segments per strain

```{r, warning = FALSE, message = FALSE, fig.width=12}
complete_incomplete <- summary_table %>% group_by(Strain, Status2) %>% summarise(Count = n())

bar_complete <- plot_ly(data = complete_incomplete,
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Status2
)

bar_complete <- bar_complete %>% layout(yaxis = list(title='Count'), barmode='stack', legend = list(title=list(text='<b> Assembly type </b>')), title = "Number of assembly types per strain") 

bar_complete
```

Note:

- "complete" - circular assembly (by Unicycler)

- "incomplete" - linear assembly (by Unicycler)

- "scaffold" - linear assembly (assembly made by SPAdes in a 'plasmid' mode)


### Strain DA68966 sticks out

```{r}
DA68966_summary <- summary_table %>% filter(Strain=="DA68966")
DA68966_summary
```

### DA68966 assembly graph

![assembly graph](/home/andrei/Data/HeteroR/results/assemblies/DA68966/graph.png){width=100%}


## Summary table of plasmids assembled by SPAdes 

```{r}
summary_table %>% filter(Status=="scaffold")
```

## Genome length distribution

Both chromosomes and plasmids

```{r, fig.width=10}
hist_chrom_plasm_len <- plot_ly(data = summary_table,
        alpha=0.9,
        x=~Length,
        color = ~Type,
        colors = c("#377EB8", "#FF7F00"),
        type = "histogram") %>% 
  layout(barmode = "overlay")

hist_chrom_plasm_len
```


These longest outliers among plasmids (250k, 400k, 700k and 900k) are parts of incomplete chromosomes

### "Plasmids" sorted by length

```{r}
summary_table %>% filter(Type=='Plasmid') %>% arrange(-Length)
```

#### Summary table for DA63676

```{r}
summary_table %>% filter(Strain=="DA63676")
```

Chromosome is incomplete and adds up to 5 Mbp together with the longest 'plasmid'

#### Summary table for DA63676

```{r}
summary_table %>% filter(Strain=="DA63914")
```

Same here...


# Benchmarking Universal Single-Copy Orthologues

[Link](https://busco.ezlab.org/busco_userguide.html#interpreting-the-results) to the tool description.

## Summary table of BUSCO-analysis results

```{r}
busco_path <- "/home/andrei/Data/HeteroR/results/qualcheck_assembly/"
busco_filename <- "short_summary.specific.gammaproteobacteria_odb10.busco_results.txt"

busco_files <- dir(path = busco_path, pattern = busco_filename, recursive = TRUE)

busco_list <- lapply(busco_files, function(x){
  strain <- strsplit(x, "/")[[1]][1]
  t <- read.delim(paste0(busco_path, x), skip = 9, header = FALSE, nrows = 6)
  t$Strain <- strain
  return(t)
})

busco_table <- bind_rows(busco_list) %>% select(-c(V1, V4, V5, V6))
names(busco_table) <- c("Count", "Category", "Strain")

busco_table <- busco_table %>% filter(!grepl("DA70*", Strain))

busco_table
```

### Barplot

```{r, fig.width=12}

bar_busco <- plot_ly(data = busco_table %>% filter(Category != "Total BUSCO groups searched"),
  x = ~Strain,
  y = ~Count,
  type = "bar",
  color = ~Category
)

bar_busco <- bar_busco %>% 
  layout(yaxis = list(title='Count'), 
         barmode='group', 
         legend = list(title=list(text='<b> BUSCO categories count </b>')), 
         title = "Assembly completeness as assessed by BUSCO") 

bar_busco
```


## Summary by category

### Complete

>If found to be complete, whether single-copy or duplicated, the BUSCO matches have scored within the expected range of scores and within the expected range of length alignments to the BUSCO profile. If in fact an ortholog is not present in the input dataset, or the ortholog is only partially present (highly fragmented), and a high-identity full-length homolog is present, it is possible that this homolog could be mistakenly identified as the complete BUSCO. The score thresholds are optimised to minimise this possibility, but it can still occur.

Counts

```{r}
busco_table %>% filter(Category == "Complete BUSCOs (C)") %>% summary()
```

### Complete and single-copy

Counts

```{r}
busco_table %>% filter(Category == "Complete and single-copy BUSCOs (S)") %>% summary()
```

### Fragmented

>If found to be fragmented, the BUSCO matches have scored within the range of scores but not within the range of length alignments to the BUSCO profile. For genome assemblies this could indicate either that the gene is only partially present or that the sequence search and gene prediction steps failed to produce a full-length gene model even though the full gene could indeed be present in the assembly.

Counts

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)") %>% summary()
```

```{r}
busco_table %>% filter(Category == "Fragmented BUSCOs (F)" & Count > 0)
```

### Missing

>If found to be missing, there were either no significant matches at all, or the BUSCO matches scored below the range of scores for the BUSCO profile. For genome assemblies this could indicate either that these orthologs are indeed missing, or that the sequence search step failed to identify any significant matches, or that the gene prediction step failed to produce even a partial gene model that might have been recognised as a fragmented BUSCO match.

Counts

```{r}
busco_table %>% filter(Category == "Missing BUSCOs (MFragmented)") %>% summary()
```

# Save workspace

```{r}
save.image(f="/home/andrei/Data/HeteroR/notebooks/genome_assembly_summary.RData")
```
