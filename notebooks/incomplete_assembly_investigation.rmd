---
title: "On the reasons of incomplete assemblies"
author: "AG"
date: "last update: `r format(Sys.time(), format = '%d %B %Y, %H:%M CET')`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    toc: true
    toc_float: true
    rmdformats:
      theme: cerulean
      highlight: github
---

# Introduction

Having analysed assemblies' summaries I found out that a lot of them (n=89) are incomplete, i.e. not circularised by Unicycler.
One possible reason can be that they were trimmed to harshly by *filtlong*.

![Fig.1 Assembly completeness as reported by Unicycler](../images/assembly_completeness_barplot.png)

I have a table with incomplete assemblies
```{r}
library(dplyr)

# just in case
my_path <- "/home/andrei/Data/HeteroR/results/assemblies_joined"

summary_files <- dir(path=my_path,  pattern = "summary.tsv", recursive=TRUE)
summary_table <- lapply(summary_files, function(x){read.delim(paste0("results/assemblies_joined/", x), stringsAsFactors = TRUE)})

summary_table <- bind_rows(summary_table)
# replace commas in Length, N50 and Longest component
summary_table$Length <- as.integer(gsub(",", "", summary_table$Length, fixed=TRUE))
summary_table$N50 <- as.integer(gsub(",", "", summary_table$N50, fixed=TRUE))
summary_table$Longest_component <- as.integer(gsub(",", "", summary_table$Longest_component, fixed=TRUE))
summary_table
```
```{r, eval=FALSE}
write.delim(summary_table %>% filter(Status == "incomplete"), "/home/andrei/Data/HeteroR/incomplete_assemblies.tsv", sep="\t", quote=F)
```
```{r}
incomplete_assemblies <- read.delim("/home/andrei/Data/HeteroR/incomplete_assemblies.tsv")
incomplete_assemblies
```

Then I ran *coverage.py* on both raw and filtered Nanopore reads in hope to capture the difference...

```
python  workflow/scripts/coverage.py resources/strain_lists/incomplete_assemblies_strains_80.txt 5131220 results/coverage/incomplete_assemblies_strains_80_coverage.tsv raw
python  workflow/scripts/coverage.py resources/strain_lists/incomplete_assemblies_strains_80.txt 5131220 results/coverage/incomplete_assemblies_strains_80_coverage_filtered.tsv filtered
```

Let's look at results

```{r}
coverage_raw <- read.delim("/home/andrei/Data/HeteroR/results/coverage/incomplete_assemblies_strains_80_coverage.tsv")
coverage_raw$strain <- sapply(coverage_raw$file, function(x){strsplit(x, "/")[[1]][3]})
coverage_raw$filtered <- "no"

coverage_filtered <- read.delim("/home/andrei/Data/HeteroR/results/coverage/incomplete_assemblies_strains_80_coverage_filtered.tsv")
coverage_filtered$strain <- sapply(coverage_filtered$file, function(x){strsplit(x, "/")[[1]][3]})
coverage_filtered <- select(coverage_filtered, -c(file, format, type))
coverage_filtered$filtered <- "yes"

coverage_joined <- bind_rows(coverage_raw, coverage_filtered)
coverage_joined <- select(coverage_joined, -c(file, format, type))
coverage_joined
```

# Plots

## Number of sequences

```{r}
library(ggplot2)

ggplot(coverage_joined, aes(strain, num_seqs))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Number of reads")+
        ylab("")+
        xlab("")

#+coord_trans(y="sqrt")
```

## Coverage

```{r}
ggplot(coverage_joined, aes(strain, coverage))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Coverage")+
        ylab("")+
        xlab("")

```

## Summary length

```{r}
ggplot(coverage_joined, aes(strain, sum_len))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Total read length")+
        ylab("")+
        xlab("")
```

## Minimum length

```{r}
ggplot(coverage_joined, aes(strain, min_len))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Minimum read length")+
        ylab("")+
        xlab("")
```

## Average length

```{r}
ggplot(coverage_joined, aes(strain, avg_len))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Average read length")+
        ylab("")+
        xlab("")
```

## Maximum length

```{r}
ggplot(coverage_joined, aes(strain, max_len))+
         geom_col(aes(fill=filtered), position="dodge")+
        theme(axis.text.x = element_text(size = 7, angle = 90))+
        ggtitle("Maximum read length")+
        ylab("")+
        xlab("")
```
Max length didn't suffer much, while minimum and average lengths actually improved

filtlong command looks like this:
```
filtlong --min_length 5000 --length_weight 1 --keep_percent 20 --target_bases 260000000 {input} 2> {log} | pigz -c -p {threads} > {output}
```

# Coverage as predictor of an assembly's circularization

I need data on coverage

## Before filtering

Not used in the following analysis.
When it was used, the coverage coefficient and R-squared were a bit lower

```{r, eval=FALSE}
coverage_path <- "/home/andrei/Data/HeteroR/results/coverage/"
coverage_files <- dir(coverage_path, pattern="nanopore_coverage[0-9,-]*.tsv")

coverage_table <- lapply(coverage_files, function(x){read.delim(paste0(coverage_path, x), stringsAsFactors = FALSE)})
coverage_table <- bind_rows(coverage_table)
coverage_table <- filter(coverage_table, !is.na(coverage))
coverage_table$Strain <- sapply(coverage_table$file, function(x){substr(tail(strsplit(x, "/")[[1]], 1), 1, 7)})
coverage_table
```

## After filtering (used for actual assembling)

That's what's used in the following analysis

```{r}
coverage_table <- read.delim("/home/andrei/Data/HeteroR/results/coverage/nanopore_coverage1-216.tsv")
coverage_table <- filter(coverage_table, !is.na(coverage))
coverage_table$Strain <- sapply(coverage_table$file, function(x){substr(tail(strsplit(x, "/")[[1]], 1), 1, 7)})
coverage_table
```


Add completeness information from the summaries
```{r}
summary_chrom <- summary_table %>% filter(Type=="Chromosome")
summary_coverage <- left_join(coverage_table, summary_chrom, by="Strain") %>% filter(!is.na(Status))
summary_coverage
```

## Plot potential predictors

```{r}
cov_plot <- ggplot(summary_coverage, aes(Status, coverage))+geom_boxplot()+geom_violin(alpha=0.0)+xlab("")
maxlen_plot <- ggplot(summary_coverage, aes(Status, max_len))+geom_boxplot()+geom_violin(alpha=0.0)+xlab("")
avglen_plot <- ggplot(summary_coverage, aes(Status, avg_len))+geom_boxplot()+geom_violin(alpha=0.0)+xlab("")
sumlen_plot <- ggplot(summary_coverage, aes(Status, sum_len))+geom_boxplot()+geom_violin(alpha=0.0)+xlab("")
numseq_plot <- ggplot(summary_coverage, aes(Status, num_seqs))+geom_boxplot()+geom_violin(alpha=0.0)+xlab("")
plot_grid(cov_plot, maxlen_plot, avglen_plot, sumlen_plot, numseq_plot, nrow=2)
```

## Regression analysis

### Only coverage

```{r}
fit_coverage <- glm(Status ~ coverage, data=summary_coverage, family = "binomial")
summary(fit_coverage)
```

```{r}
rsquared <- function(created_model) {
  dev <- created_model$deviance
  null_dev <- created_model$null.deviance
  model_n <- length(created_model$fitted.values)
  R_l <- 1 - dev / null_dev
  R_cs <- 1 - exp(-(null_dev - dev) / model_n)
  R_n <- R_cs / (1 - exp(-(null_dev / model_n)))
  cat("Pseudo R-squared for logistic regression model\n\n")
  cat("Hosmer and Lemeshow R-squared\t", round(R_l, 3), "\n")
  cat("Cox and Snell R-squared\t\t\t", round(R_cs, 3), "\n")
  cat("Nagelkerke R-squared\t\t\t\t", round(R_n, 3), "\n")
}

rsquared(fit_coverage)
```

### Coverage + the rest

```{r}
fit_everything <- glm(Status ~ coverage + avg_len + max_len + sum_len + num_seqs, data=summary_coverage, family = "binomial")
summary(fit_everything)
```

```{r}
rsquared(fit_everything)
```

## Conclusion

Coverage and number of sequences seem to be main predictors of the completeness (among the data that we have)
